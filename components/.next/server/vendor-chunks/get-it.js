"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/get-it";
exports.ids = ["vendor-chunks/get-it"];
exports.modules = {

/***/ "(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-CXwrNjme.cjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/defaultOptionsValidator-CXwrNjme.cjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nconst isReactNative = typeof navigator > \"u\" ? !1 : navigator.product === \"ReactNative\", defaultOptions = {\n    timeout: isReactNative ? 6e4 : 12e4\n}, processOptions = function(opts) {\n    const options = {\n        ...defaultOptions,\n        ...typeof opts == \"string\" ? {\n            url: opts\n        } : opts\n    }, { searchParams } = new URL(options.url, \"http://localhost\");\n    if (options.timeout = normalizeTimeout(options.timeout), options.query) {\n        for (const [key, value] of Object.entries(options.query))if (value !== void 0) if (Array.isArray(value)) for (const v of value)searchParams.append(key, v);\n        else searchParams.append(key, value);\n    }\n    const [url] = options.url.split(\"?\"), search = searchParams.toString();\n    return search && (options.url = `${url}?${search}`), options.method = options.body && !options.method ? \"POST\" : (options.method || \"GET\").toUpperCase(), options;\n};\nfunction normalizeTimeout(time) {\n    if (time === !1 || time === 0) return !1;\n    if (time.connect || time.socket) return time;\n    const delay = Number(time);\n    return isNaN(delay) ? normalizeTimeout(defaultOptions.timeout) : {\n        connect: delay,\n        socket: delay\n    };\n}\nconst validUrl = /^https?:\\/\\//i, validateOptions = function(options) {\n    if (!validUrl.test(options.url)) throw new Error(`\"${options.url}\" is not a valid URL`);\n};\nexports.processOptions = processOptions;\nexports.validateOptions = validateOptions; //# sourceMappingURL=defaultOptionsValidator-CXwrNjme.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1DWHdyTmptZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixNQUFNQSxnQkFBZ0IsT0FBT0MsWUFBWSxNQUFNLENBQUMsSUFBSUEsVUFBVUMsT0FBTyxLQUFLLGVBQWVDLGlCQUFpQjtJQUFFQyxTQUFTSixnQkFBZ0IsTUFBTTtBQUFLLEdBQUdLLGlCQUFpQixTQUFTQyxJQUFJO0lBQy9LLE1BQU1DLFVBQVU7UUFDZCxHQUFHSixjQUFjO1FBQ2pCLEdBQUcsT0FBT0csUUFBUSxXQUFXO1lBQUVFLEtBQUtGO1FBQUssSUFBSUEsSUFBSTtJQUNuRCxHQUFHLEVBQUVHLFlBQVksRUFBRSxHQUFHLElBQUlDLElBQUlILFFBQVFDLEdBQUcsRUFBRTtJQUMzQyxJQUFJRCxRQUFRSCxPQUFPLEdBQUdPLGlCQUFpQkosUUFBUUgsT0FBTyxHQUFHRyxRQUFRSyxLQUFLLEVBQUU7UUFDdEUsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDVCxRQUFRSyxLQUFLLEVBQ3JELElBQUlFLFVBQVUsS0FBSyxHQUNqQixJQUFJRyxNQUFNQyxPQUFPLENBQUNKLFFBQ2hCLEtBQUssTUFBTUssS0FBS0wsTUFDZEwsYUFBYVcsTUFBTSxDQUFDUCxLQUFLTTthQUUzQlYsYUFBYVcsTUFBTSxDQUFDUCxLQUFLQztJQUNqQztJQUNBLE1BQU0sQ0FBQ04sSUFBSSxHQUFHRCxRQUFRQyxHQUFHLENBQUNhLEtBQUssQ0FBQyxNQUFNQyxTQUFTYixhQUFhYyxRQUFRO0lBQ3BFLE9BQU9ELFVBQVdmLENBQUFBLFFBQVFDLEdBQUcsR0FBRyxDQUFDLEVBQUVBLElBQUksQ0FBQyxFQUFFYyxPQUFPLENBQUMsR0FBR2YsUUFBUWlCLE1BQU0sR0FBR2pCLFFBQVFrQixJQUFJLElBQUksQ0FBQ2xCLFFBQVFpQixNQUFNLEdBQUcsU0FBUyxDQUFDakIsUUFBUWlCLE1BQU0sSUFBSSxLQUFJLEVBQUdFLFdBQVcsSUFBSW5CO0FBQzVKO0FBQ0EsU0FBU0ksaUJBQWlCZ0IsSUFBSTtJQUM1QixJQUFJQSxTQUFTLENBQUMsS0FBS0EsU0FBUyxHQUMxQixPQUFPLENBQUM7SUFDVixJQUFJQSxLQUFLQyxPQUFPLElBQUlELEtBQUtFLE1BQU0sRUFDN0IsT0FBT0Y7SUFDVCxNQUFNRyxRQUFRQyxPQUFPSjtJQUNyQixPQUFPSyxNQUFNRixTQUFTbkIsaUJBQWlCUixlQUFlQyxPQUFPLElBQUk7UUFBRXdCLFNBQVNFO1FBQU9ELFFBQVFDO0lBQU07QUFDbkc7QUFDQSxNQUFNRyxXQUFXLGlCQUFpQkMsa0JBQWtCLFNBQVMzQixPQUFPO0lBQ2xFLElBQUksQ0FBQzBCLFNBQVNFLElBQUksQ0FBQzVCLFFBQVFDLEdBQUcsR0FDNUIsTUFBTSxJQUFJNEIsTUFBTSxDQUFDLENBQUMsRUFBRTdCLFFBQVFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQztBQUN6RDtBQUNBNkIsc0JBQXNCLEdBQUdoQztBQUN6QmdDLHVCQUF1QixHQUFHSCxpQkFDMUIsNkRBQTZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L19jaHVua3MvZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3ItQ1h3ck5qbWUuY2pzP2NlMTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciA+IFwidVwiID8gITEgOiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiLCBkZWZhdWx0T3B0aW9ucyA9IHsgdGltZW91dDogaXNSZWFjdE5hdGl2ZSA/IDZlNCA6IDEyZTQgfSwgcHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4udHlwZW9mIG9wdHMgPT0gXCJzdHJpbmdcIiA/IHsgdXJsOiBvcHRzIH0gOiBvcHRzXG4gIH0sIHsgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKG9wdGlvbnMudXJsLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gIGlmIChvcHRpb25zLnRpbWVvdXQgPSBub3JtYWxpemVUaW1lb3V0KG9wdGlvbnMudGltZW91dCksIG9wdGlvbnMucXVlcnkpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnF1ZXJ5KSlcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKVxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHYpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgfVxuICBjb25zdCBbdXJsXSA9IG9wdGlvbnMudXJsLnNwbGl0KFwiP1wiKSwgc2VhcmNoID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gIHJldHVybiBzZWFyY2ggJiYgKG9wdGlvbnMudXJsID0gYCR7dXJsfT8ke3NlYXJjaH1gKSwgb3B0aW9ucy5tZXRob2QgPSBvcHRpb25zLmJvZHkgJiYgIW9wdGlvbnMubWV0aG9kID8gXCJQT1NUXCIgOiAob3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIikudG9VcHBlckNhc2UoKSwgb3B0aW9ucztcbn07XG5mdW5jdGlvbiBub3JtYWxpemVUaW1lb3V0KHRpbWUpIHtcbiAgaWYgKHRpbWUgPT09ICExIHx8IHRpbWUgPT09IDApXG4gICAgcmV0dXJuICExO1xuICBpZiAodGltZS5jb25uZWN0IHx8IHRpbWUuc29ja2V0KVxuICAgIHJldHVybiB0aW1lO1xuICBjb25zdCBkZWxheSA9IE51bWJlcih0aW1lKTtcbiAgcmV0dXJuIGlzTmFOKGRlbGF5KSA/IG5vcm1hbGl6ZVRpbWVvdXQoZGVmYXVsdE9wdGlvbnMudGltZW91dCkgOiB7IGNvbm5lY3Q6IGRlbGF5LCBzb2NrZXQ6IGRlbGF5IH07XG59XG5jb25zdCB2YWxpZFVybCA9IC9eaHR0cHM/OlxcL1xcLy9pLCB2YWxpZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICghdmFsaWRVcmwudGVzdChvcHRpb25zLnVybCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7b3B0aW9ucy51cmx9XCIgaXMgbm90IGEgdmFsaWQgVVJMYCk7XG59O1xuZXhwb3J0cy5wcm9jZXNzT3B0aW9ucyA9IHByb2Nlc3NPcHRpb25zO1xuZXhwb3J0cy52YWxpZGF0ZU9wdGlvbnMgPSB2YWxpZGF0ZU9wdGlvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1DWHdyTmptZS5janMubWFwXG4iXSwibmFtZXMiOlsiaXNSZWFjdE5hdGl2ZSIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJkZWZhdWx0T3B0aW9ucyIsInRpbWVvdXQiLCJwcm9jZXNzT3B0aW9ucyIsIm9wdHMiLCJvcHRpb25zIiwidXJsIiwic2VhcmNoUGFyYW1zIiwiVVJMIiwibm9ybWFsaXplVGltZW91dCIsInF1ZXJ5Iiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwiQXJyYXkiLCJpc0FycmF5IiwidiIsImFwcGVuZCIsInNwbGl0Iiwic2VhcmNoIiwidG9TdHJpbmciLCJtZXRob2QiLCJib2R5IiwidG9VcHBlckNhc2UiLCJ0aW1lIiwiY29ubmVjdCIsInNvY2tldCIsImRlbGF5IiwiTnVtYmVyIiwiaXNOYU4iLCJ2YWxpZFVybCIsInZhbGlkYXRlT3B0aW9ucyIsInRlc3QiLCJFcnJvciIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-CXwrNjme.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/get-it/dist/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: !0\n}));\nvar defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-CXwrNjme.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-CXwrNjme.cjs\"), decompressResponse = __webpack_require__(/*! decompress-response */ \"(ssr)/./node_modules/decompress-response/index.js\"), follow = __webpack_require__(/*! follow-redirects */ \"(ssr)/./node_modules/follow-redirects/index.js\"), http = __webpack_require__(/*! http */ \"http\"), https = __webpack_require__(/*! https */ \"https\"), toStream = __webpack_require__(/*! into-stream */ \"(ssr)/./node_modules/into-stream/index.js\"), isStream = __webpack_require__(/*! is-stream */ \"(ssr)/./node_modules/is-stream/index.js\"), progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\"), qs = __webpack_require__(/*! querystring */ \"querystring\"), url = __webpack_require__(/*! url */ \"url\"), tunnel = __webpack_require__(/*! tunnel-agent */ \"(ssr)/./node_modules/tunnel-agent/index.js\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e == \"object\" && \"default\" in e ? e : {\n        default: e\n    };\n}\nfunction _interopNamespaceCompat(e) {\n    if (e && typeof e == \"object\" && \"default\" in e) return e;\n    var n = /* @__PURE__ */ Object.create(null);\n    return e && Object.keys(e).forEach(function(k) {\n        if (k !== \"default\") {\n            var d = Object.getOwnPropertyDescriptor(e, k);\n            Object.defineProperty(n, k, d.get ? d : {\n                enumerable: !0,\n                get: function() {\n                    return e[k];\n                }\n            });\n        }\n    }), n.default = e, Object.freeze(n);\n}\nvar decompressResponse__default = /* @__PURE__ */ _interopDefaultCompat(decompressResponse), follow__default = /* @__PURE__ */ _interopDefaultCompat(follow), http__default = /* @__PURE__ */ _interopDefaultCompat(http), https__default = /* @__PURE__ */ _interopDefaultCompat(https), toStream__default = /* @__PURE__ */ _interopDefaultCompat(toStream), isStream__default = /* @__PURE__ */ _interopDefaultCompat(isStream), progressStream__default = /* @__PURE__ */ _interopDefaultCompat(progressStream), qs__default = /* @__PURE__ */ _interopDefaultCompat(qs), url__default = /* @__PURE__ */ _interopDefaultCompat(url), tunnel__namespace = /* @__PURE__ */ _interopNamespaceCompat(tunnel);\nconst middlewareReducer = (middleware)=>function(hook, defaultValue, ...args) {\n        const bailEarly = hook === \"onError\";\n        let value = defaultValue;\n        for(let i = 0; i < middleware[hook].length; i++){\n            const handler = middleware[hook][i];\n            if (value = handler(value, ...args), bailEarly && !value) break;\n        }\n        return value;\n    };\nfunction createPubSub() {\n    const subscribers = /* @__PURE__ */ Object.create(null);\n    let nextId = 0;\n    function subscribe(subscriber) {\n        const id = nextId++;\n        return subscribers[id] = subscriber, function() {\n            delete subscribers[id];\n        };\n    }\n    function publish(event) {\n        for(const id in subscribers)subscribers[id](event);\n    }\n    return {\n        publish,\n        subscribe\n    };\n}\nconst channelNames = [\n    \"request\",\n    \"response\",\n    \"progress\",\n    \"error\",\n    \"abort\"\n], middlehooks = [\n    \"processOptions\",\n    \"validateOptions\",\n    \"interceptRequest\",\n    \"finalizeOptions\",\n    \"onRequest\",\n    \"onResponse\",\n    \"onError\",\n    \"onReturn\",\n    \"onHeaders\"\n];\nfunction createRequester(initMiddleware, httpRequest) {\n    const loadedMiddleware = [], middleware = middlehooks.reduce((ware, name)=>(ware[name] = ware[name] || [], ware), {\n        processOptions: [\n            defaultOptionsValidator.processOptions\n        ],\n        validateOptions: [\n            defaultOptionsValidator.validateOptions\n        ]\n    });\n    function request(opts) {\n        const onResponse = (reqErr, res, ctx)=>{\n            let error = reqErr, response = res;\n            if (!error) try {\n                response = applyMiddleware(\"onResponse\", res, ctx);\n            } catch (err) {\n                response = null, error = err;\n            }\n            error = error && applyMiddleware(\"onError\", error, ctx), error ? channels.error.publish(error) : response && channels.response.publish(response);\n        }, channels = channelNames.reduce((target, name)=>(target[name] = createPubSub(), target), {}), applyMiddleware = middlewareReducer(middleware), options = applyMiddleware(\"processOptions\", opts);\n        applyMiddleware(\"validateOptions\", options);\n        const context = {\n            options,\n            channels,\n            applyMiddleware\n        };\n        let ongoingRequest;\n        const unsubscribe = channels.request.subscribe((ctx)=>{\n            ongoingRequest = httpRequest(ctx, (err, res)=>onResponse(err, res, ctx));\n        });\n        channels.abort.subscribe(()=>{\n            unsubscribe(), ongoingRequest && ongoingRequest.abort();\n        });\n        const returnValue = applyMiddleware(\"onReturn\", channels, context);\n        return returnValue === channels && channels.request.publish(context), returnValue;\n    }\n    return request.use = function(newMiddleware) {\n        if (!newMiddleware) throw new Error(\"Tried to add middleware that resolved to falsey value\");\n        if (typeof newMiddleware == \"function\") throw new Error(\"Tried to add middleware that was a function. It probably expects you to pass options to it.\");\n        if (newMiddleware.onReturn && middleware.onReturn.length > 0) throw new Error(\"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\");\n        return middlehooks.forEach((key)=>{\n            newMiddleware[key] && middleware[key].push(newMiddleware[key]);\n        }), loadedMiddleware.push(newMiddleware), request;\n    }, request.clone = ()=>createRequester(loadedMiddleware, httpRequest), initMiddleware.forEach(request.use), request;\n}\nfunction lowerCaseHeaders(headers) {\n    return Object.keys(headers || {}).reduce((acc, header)=>(acc[header.toLowerCase()] = headers[header], acc), {});\n}\nfunction formatHostname(hostname) {\n    return hostname.replace(/^\\.*/, \".\").toLowerCase();\n}\nfunction parseNoProxyZone(zoneStr) {\n    const zone = zoneStr.trim().toLowerCase(), zoneParts = zone.split(\":\", 2), zoneHost = formatHostname(zoneParts[0]), zonePort = zoneParts[1], hasPort = zone.indexOf(\":\") > -1;\n    return {\n        hostname: zoneHost,\n        port: zonePort,\n        hasPort\n    };\n}\nfunction uriInNoProxy(uri, noProxy) {\n    const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\"), hostname = formatHostname(uri.hostname);\n    return noProxy.split(\",\").map(parseNoProxyZone).some((noProxyZone)=>{\n        const isMatchedAt = hostname.indexOf(noProxyZone.hostname), hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;\n        return noProxyZone.hasPort ? port === noProxyZone.port && hostnameMatched : hostnameMatched;\n    });\n}\nfunction getProxyFromUri(uri) {\n    const noProxy = process.env.NO_PROXY || process.env.no_proxy || \"\";\n    return noProxy === \"*\" || noProxy !== \"\" && uriInNoProxy(uri, noProxy) ? null : uri.protocol === \"http:\" ? process.env.HTTP_PROXY || process.env.http_proxy || null : uri.protocol === \"https:\" && (process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy) || null;\n}\nfunction getHostFromUri(uri) {\n    let host = uri.host;\n    return uri.port && (uri.port === \"80\" && uri.protocol === \"http:\" || uri.port === \"443\" && uri.protocol === \"https:\") && (host = uri.hostname), host;\n}\nfunction getHostHeaderWithPort(uri) {\n    const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\");\n    return `${uri.hostname}:${port}`;\n}\nfunction rewriteUriForProxy(reqOpts, uri, proxy) {\n    const headers = reqOpts.headers || {}, options = Object.assign({}, reqOpts, {\n        headers\n    });\n    return headers.host = headers.host || getHostHeaderWithPort(uri), options.protocol = proxy.protocol || options.protocol, options.hostname = proxy.host.replace(/:\\d+/, \"\"), options.port = proxy.port, options.host = getHostFromUri(Object.assign({}, uri, proxy)), options.href = `${options.protocol}//${options.host}${options.path}`, options.path = url__default.default.format(uri), options;\n}\nfunction getProxyOptions(options) {\n    let proxy;\n    if (options.hasOwnProperty(\"proxy\")) proxy = options.proxy;\n    else {\n        const uri = url__default.default.parse(options.url);\n        proxy = getProxyFromUri(uri);\n    }\n    return typeof proxy == \"string\" ? url__default.default.parse(proxy) : proxy;\n}\n/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ function concat(stream, cb) {\n    const chunks = [];\n    stream.on(\"data\", function(chunk) {\n        chunks.push(chunk);\n    }), stream.once(\"end\", function() {\n        cb && cb(null, Buffer.concat(chunks)), cb = null;\n    }), stream.once(\"error\", function(err) {\n        cb && cb(err), cb = null;\n    });\n}\nfunction timedOut(req, time) {\n    if (req.timeoutTimer) return req;\n    const delays = isNaN(time) ? time : {\n        socket: time,\n        connect: time\n    }, hostHeader = req.getHeader(\"host\"), host = hostHeader ? \" to \" + hostHeader : \"\";\n    delays.connect !== void 0 && (req.timeoutTimer = setTimeout(function() {\n        req.abort();\n        const e = new Error(\"Connection timed out on request\" + host);\n        e.code = \"ETIMEDOUT\", req.emit(\"error\", e);\n    }, delays.connect)), req.on(\"socket\", function(socket) {\n        if (!(socket.connecting || socket._connecting)) {\n            connect();\n            return;\n        }\n        socket.once(\"connect\", connect);\n    });\n    function clear() {\n        req.timeoutTimer && (clearTimeout(req.timeoutTimer), req.timeoutTimer = null);\n    }\n    function connect() {\n        clear(), delays.socket !== void 0 && req.setTimeout(delays.socket, function() {\n            req.abort();\n            const e = new Error(\"Socket timed out on request\" + host);\n            e.code = \"ESOCKETTIMEDOUT\", req.emit(\"error\", e);\n        });\n    }\n    return req.on(\"error\", clear);\n}\nconst uriParts = [\n    \"protocol\",\n    \"slashes\",\n    \"auth\",\n    \"host\",\n    \"port\",\n    \"hostname\",\n    \"hash\",\n    \"search\",\n    \"query\",\n    \"pathname\",\n    \"path\",\n    \"href\"\n], defaultProxyHeaderWhiteList = [\n    \"accept\",\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"accept-language\",\n    \"accept-ranges\",\n    \"cache-control\",\n    \"content-encoding\",\n    \"content-language\",\n    \"content-location\",\n    \"content-md5\",\n    \"content-range\",\n    \"content-type\",\n    \"connection\",\n    \"date\",\n    \"expect\",\n    \"max-forwards\",\n    \"pragma\",\n    \"referer\",\n    \"te\",\n    \"user-agent\",\n    \"via\"\n], defaultProxyHeaderExclusiveList = [\n    \"proxy-authorization\"\n];\nfunction shouldEnable(options) {\n    return typeof options.tunnel < \"u\" ? !!options.tunnel : url__default.default.parse(options.url).protocol === \"https:\";\n}\nfunction applyAgent(opts = {}, proxy) {\n    const options = Object.assign({}, opts), proxyHeaderWhiteList = defaultProxyHeaderWhiteList.concat(options.proxyHeaderWhiteList || []).map((header)=>header.toLowerCase()), proxyHeaderExclusiveList = defaultProxyHeaderExclusiveList.concat(options.proxyHeaderExclusiveList || []).map((header)=>header.toLowerCase()), proxyHeaders = getAllowedProxyHeaders(options.headers, proxyHeaderWhiteList);\n    proxyHeaders.host = constructProxyHost(options), options.headers = Object.keys(options.headers || {}).reduce((headers, header)=>(proxyHeaderExclusiveList.indexOf(header.toLowerCase()) === -1 && (headers[header] = options.headers[header]), headers), {});\n    const tunnelFn = getTunnelFn(options, proxy), tunnelOptions = constructTunnelOptions(options, proxy, proxyHeaders);\n    return options.agent = tunnelFn(tunnelOptions), options;\n}\nfunction getTunnelFn(options, proxy) {\n    const uri = getUriParts(options), tunnelFnName = constructTunnelFnName(uri, proxy);\n    return tunnel__namespace[tunnelFnName];\n}\nfunction getUriParts(options) {\n    return uriParts.reduce((uri, part)=>(uri[part] = options[part], uri), {});\n}\nfunction constructTunnelFnName(uri, proxy) {\n    const uriProtocol = uri.protocol === \"https:\" ? \"https\" : \"http\", proxyProtocol = proxy.protocol === \"https:\" ? \"Https\" : \"Http\";\n    return `${uriProtocol}Over${proxyProtocol}`;\n}\nfunction constructProxyHost(uri) {\n    const port = uri.port, protocol = uri.protocol;\n    let proxyHost = `${uri.hostname}:`;\n    return port ? proxyHost += port : protocol === \"https:\" ? proxyHost += \"443\" : proxyHost += \"80\", proxyHost;\n}\nfunction getAllowedProxyHeaders(headers, whiteList) {\n    return Object.keys(headers).filter((header)=>whiteList.indexOf(header.toLowerCase()) !== -1).reduce((set, header)=>(set[header] = headers[header], set), {});\n}\nfunction constructTunnelOptions(options, proxy, proxyHeaders) {\n    return {\n        proxy: {\n            host: proxy.hostname,\n            port: +proxy.port,\n            proxyAuth: proxy.auth,\n            headers: proxyHeaders\n        },\n        headers: options.headers,\n        ca: options.ca,\n        cert: options.cert,\n        key: options.key,\n        passphrase: options.passphrase,\n        pfx: options.pfx,\n        ciphers: options.ciphers,\n        rejectUnauthorized: options.rejectUnauthorized,\n        secureOptions: options.secureOptions,\n        secureProtocol: options.secureProtocol\n    };\n}\nconst adapter = \"node\", reduceResponse = (res, reqUrl, method, body)=>({\n        body,\n        url: reqUrl,\n        method,\n        headers: res.headers,\n        statusCode: res.statusCode,\n        statusMessage: res.statusMessage\n    }), httpRequester = (context, cb)=>{\n    const { options } = context, uri = Object.assign({}, url__default.default.parse(options.url));\n    if (typeof fetch == \"function\" && options.fetch) {\n        const controller = new AbortController(), reqOpts2 = context.applyMiddleware(\"finalizeOptions\", {\n            ...uri,\n            method: options.method,\n            headers: {\n                ...typeof options.fetch == \"object\" && options.fetch.headers ? lowerCaseHeaders(options.fetch.headers) : {},\n                ...lowerCaseHeaders(options.headers)\n            },\n            maxRedirects: options.maxRedirects\n        }), fetchOpts = {\n            credentials: options.withCredentials ? \"include\" : \"omit\",\n            ...typeof options.fetch == \"object\" ? options.fetch : {},\n            method: reqOpts2.method,\n            headers: reqOpts2.headers,\n            body: options.body,\n            signal: controller.signal\n        }, injectedResponse2 = context.applyMiddleware(\"interceptRequest\", void 0, {\n            adapter,\n            context\n        });\n        if (injectedResponse2) {\n            const cbTimer = setTimeout(cb, 0, null, injectedResponse2);\n            return {\n                abort: ()=>clearTimeout(cbTimer)\n            };\n        }\n        const request2 = fetch(options.url, fetchOpts);\n        return context.applyMiddleware(\"onRequest\", {\n            options,\n            adapter,\n            request: request2,\n            context\n        }), request2.then(async (res)=>{\n            const body = options.rawBody ? res.body : await res.text(), headers = {};\n            res.headers.forEach((value, key)=>{\n                headers[key] = value;\n            }), cb(null, {\n                body,\n                url: res.url,\n                method: options.method,\n                headers,\n                statusCode: res.status,\n                statusMessage: res.statusText\n            });\n        }).catch((err)=>{\n            err.name != \"AbortError\" && cb(err);\n        }), {\n            abort: ()=>controller.abort()\n        };\n    }\n    const bodyType = isStream__default.default(options.body) ? \"stream\" : typeof options.body;\n    if (bodyType !== \"undefined\" && bodyType !== \"stream\" && bodyType !== \"string\" && !Buffer.isBuffer(options.body)) throw new Error(`Request body must be a string, buffer or stream, got ${bodyType}`);\n    const lengthHeader = {};\n    options.bodySize ? lengthHeader[\"content-length\"] = options.bodySize : options.body && bodyType !== \"stream\" && (lengthHeader[\"content-length\"] = Buffer.byteLength(options.body));\n    let aborted = !1;\n    const callback = (err, res)=>!aborted && cb(err, res);\n    context.channels.abort.subscribe(()=>{\n        aborted = !0;\n    });\n    let reqOpts = Object.assign({}, uri, {\n        method: options.method,\n        headers: Object.assign({}, lowerCaseHeaders(options.headers), lengthHeader),\n        maxRedirects: options.maxRedirects\n    });\n    const proxy = getProxyOptions(options), tunnel2 = proxy && shouldEnable(options), injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n        adapter,\n        context\n    });\n    if (injectedResponse) {\n        const cbTimer = setImmediate(callback, null, injectedResponse);\n        return {\n            abort: ()=>clearImmediate(cbTimer)\n        };\n    }\n    if (options.maxRedirects !== 0 && (reqOpts.maxRedirects = options.maxRedirects || 5), proxy && tunnel2 ? reqOpts = applyAgent(reqOpts, proxy) : proxy && !tunnel2 && (reqOpts = rewriteUriForProxy(reqOpts, uri, proxy)), !tunnel2 && proxy && proxy.auth && !reqOpts.headers[\"proxy-authorization\"]) {\n        const [username, password] = proxy.auth.username ? [\n            proxy.auth.username,\n            proxy.auth.password\n        ] : proxy.auth.split(\":\").map((item)=>qs__default.default.unescape(item)), authBase64 = Buffer.from(`${username}:${password}`, \"utf8\").toString(\"base64\");\n        reqOpts.headers[\"proxy-authorization\"] = `Basic ${authBase64}`;\n    }\n    const transport = getRequestTransport(reqOpts, proxy, tunnel2);\n    typeof options.debug == \"function\" && proxy && options.debug(\"Proxying using %s\", reqOpts.agent ? \"tunnel agent\" : `${reqOpts.host}:${reqOpts.port}`);\n    const tryCompressed = reqOpts.method !== \"HEAD\";\n    tryCompressed && !reqOpts.headers[\"accept-encoding\"] && options.compress !== !1 && (reqOpts.headers[\"accept-encoding\"] = \"br, gzip, deflate\");\n    const finalOptions = context.applyMiddleware(\"finalizeOptions\", reqOpts), request = transport.request(finalOptions, (response)=>{\n        const res = tryCompressed ? decompressResponse__default.default(response) : response, resStream = context.applyMiddleware(\"onHeaders\", res, {\n            headers: response.headers,\n            adapter,\n            context\n        }), reqUrl = \"responseUrl\" in response ? response.responseUrl : options.url;\n        if (options.stream) {\n            callback(null, reduceResponse(res, reqUrl, reqOpts.method, resStream));\n            return;\n        }\n        concat(resStream, (err, data)=>{\n            if (err) return callback(err);\n            const body = options.rawBody ? data : data.toString(), reduced = reduceResponse(res, reqUrl, reqOpts.method, body);\n            return callback(null, reduced);\n        });\n    });\n    options.timeout && timedOut(request, options.timeout), request.once(\"error\", callback);\n    const { bodyStream, progress } = getProgressStream(options);\n    return context.applyMiddleware(\"onRequest\", {\n        options,\n        adapter,\n        request,\n        context,\n        progress\n    }), bodyStream ? bodyStream.pipe(request) : request.end(options.body), {\n        abort: ()=>request.abort()\n    };\n};\nfunction getProgressStream(options) {\n    if (!options.body) return {};\n    const bodyIsStream = isStream__default.default(options.body), length = options.bodySize || (bodyIsStream ? null : Buffer.byteLength(options.body));\n    if (!length) return bodyIsStream ? {\n        bodyStream: options.body\n    } : {};\n    const progress = progressStream__default.default({\n        time: 16,\n        length\n    });\n    return {\n        bodyStream: (bodyIsStream ? options.body : toStream__default.default(options.body)).pipe(progress),\n        progress\n    };\n}\nfunction getRequestTransport(reqOpts, proxy, tunnel2) {\n    const isHttpsRequest = reqOpts.protocol === \"https:\", transports = reqOpts.maxRedirects === 0 ? {\n        http: http__default.default,\n        https: https__default.default\n    } : {\n        http: follow__default.default.http,\n        https: follow__default.default.https\n    };\n    if (!proxy || tunnel2) return isHttpsRequest ? transports.https : transports.http;\n    let isHttpsProxy = proxy.port === 443;\n    return proxy.protocol && (isHttpsProxy = /^https:?/.test(proxy.protocol)), isHttpsProxy ? transports.https : transports.http;\n}\nconst getIt = (initMiddleware = [], httpRequest = httpRequester)=>createRequester(initMiddleware, httpRequest), environment = \"node\";\nexports.adapter = adapter;\nexports.environment = environment;\nexports.getIt = getIt; //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPLENBQUM7QUFBRSxDQUFDLEVBQUM7QUFDM0QsSUFBSUMsMEJBQTBCQyxtQkFBT0EsQ0FBQyxxSUFBZ0QsR0FBR0MscUJBQXFCRCxtQkFBT0EsQ0FBQyw4RUFBcUIsR0FBR0UsU0FBU0YsbUJBQU9BLENBQUMsd0VBQWtCLEdBQUdHLE9BQU9ILG1CQUFPQSxDQUFDLGtCQUFNLEdBQUdJLFFBQVFKLG1CQUFPQSxDQUFDLG9CQUFPLEdBQUdLLFdBQVdMLG1CQUFPQSxDQUFDLDhEQUFhLEdBQUdNLFdBQVdOLG1CQUFPQSxDQUFDLDBEQUFXLEdBQUdPLGlCQUFpQlAsbUJBQU9BLENBQUMsc0VBQWlCLEdBQUdRLEtBQUtSLG1CQUFPQSxDQUFDLGdDQUFhLEdBQUdTLE1BQU1ULG1CQUFPQSxDQUFDLGdCQUFLLEdBQUdVLFNBQVNWLG1CQUFPQSxDQUFDLGdFQUFjO0FBQ3phLFNBQVNXLHNCQUFzQkMsQ0FBQztJQUM5QixPQUFPQSxLQUFLLE9BQU9BLEtBQUssWUFBWSxhQUFhQSxJQUFJQSxJQUFJO1FBQUVDLFNBQVNEO0lBQUU7QUFDeEU7QUFDQSxTQUFTRSx3QkFBd0JGLENBQUM7SUFDaEMsSUFBSUEsS0FBSyxPQUFPQSxLQUFLLFlBQVksYUFBYUEsR0FDNUMsT0FBT0E7SUFDVCxJQUFJRyxJQUFJLGFBQWEsR0FBR3BCLE9BQU9xQixNQUFNLENBQUM7SUFDdEMsT0FBT0osS0FBS2pCLE9BQU9zQixJQUFJLENBQUNMLEdBQUdNLE9BQU8sQ0FBQyxTQUFTQyxDQUFDO1FBQzNDLElBQUlBLE1BQU0sV0FBVztZQUNuQixJQUFJQyxJQUFJekIsT0FBTzBCLHdCQUF3QixDQUFDVCxHQUFHTztZQUMzQ3hCLE9BQU9DLGNBQWMsQ0FBQ21CLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtnQkFDdENHLFlBQVksQ0FBQztn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QUksQ0FBQ3BJLE1BQU1wQixRQUFRLElBQUl1SixlQUFlRCxXQUFXaFEsS0FBSyxHQUFHZ1EsV0FBV2pRLElBQUk7QUFDOUg7QUFDQSxNQUFNb1EsUUFBUSxDQUFDaE4saUJBQWlCLEVBQUUsRUFBRUMsY0FBY3FKLGFBQWEsR0FBS3ZKLGdCQUFnQkMsZ0JBQWdCQyxjQUFjZ04sY0FBYztBQUNoSTNRLGVBQWUsR0FBR3lNO0FBQ2xCek0sbUJBQW1CLEdBQUcyUTtBQUN0QjNRLGFBQWEsR0FBRzBRLE9BQ2hCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9nZXQtaXQvZGlzdC9pbmRleC5janM/MjlhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi9fY2h1bmtzL2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLUNYd3JOam1lLmNqc1wiKSwgZGVjb21wcmVzc1Jlc3BvbnNlID0gcmVxdWlyZShcImRlY29tcHJlc3MtcmVzcG9uc2VcIiksIGZvbGxvdyA9IHJlcXVpcmUoXCJmb2xsb3ctcmVkaXJlY3RzXCIpLCBodHRwID0gcmVxdWlyZShcImh0dHBcIiksIGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpLCB0b1N0cmVhbSA9IHJlcXVpcmUoXCJpbnRvLXN0cmVhbVwiKSwgaXNTdHJlYW0gPSByZXF1aXJlKFwiaXMtc3RyZWFtXCIpLCBwcm9ncmVzc1N0cmVhbSA9IHJlcXVpcmUoXCJwcm9ncmVzcy1zdHJlYW1cIiksIHFzID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpLCB1cmwgPSByZXF1aXJlKFwidXJsXCIpLCB0dW5uZWwgPSByZXF1aXJlKFwidHVubmVsLWFnZW50XCIpO1xuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0Q29tcGF0KGUpIHtcbiAgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBcImRlZmF1bHRcIiBpbiBlID8gZSA6IHsgZGVmYXVsdDogZSB9O1xufVxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2VDb21wYXQoZSkge1xuICBpZiAoZSAmJiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIFwiZGVmYXVsdFwiIGluIGUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciBuID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBlICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmIChrICE9PSBcImRlZmF1bHRcIikge1xuICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGVba107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIG4uZGVmYXVsdCA9IGUsIE9iamVjdC5mcmVlemUobik7XG59XG52YXIgZGVjb21wcmVzc1Jlc3BvbnNlX19kZWZhdWx0ID0gLyogQF9fUFVSRV9fICovIF9pbnRlcm9wRGVmYXVsdENvbXBhdChkZWNvbXByZXNzUmVzcG9uc2UpLCBmb2xsb3dfX2RlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BEZWZhdWx0Q29tcGF0KGZvbGxvdyksIGh0dHBfX2RlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BEZWZhdWx0Q29tcGF0KGh0dHApLCBodHRwc19fZGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyBfaW50ZXJvcERlZmF1bHRDb21wYXQoaHR0cHMpLCB0b1N0cmVhbV9fZGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyBfaW50ZXJvcERlZmF1bHRDb21wYXQodG9TdHJlYW0pLCBpc1N0cmVhbV9fZGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyBfaW50ZXJvcERlZmF1bHRDb21wYXQoaXNTdHJlYW0pLCBwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyBfaW50ZXJvcERlZmF1bHRDb21wYXQocHJvZ3Jlc3NTdHJlYW0pLCBxc19fZGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyBfaW50ZXJvcERlZmF1bHRDb21wYXQocXMpLCB1cmxfX2RlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BEZWZhdWx0Q29tcGF0KHVybCksIHR1bm5lbF9fbmFtZXNwYWNlID0gLyogQF9fUFVSRV9fICovIF9pbnRlcm9wTmFtZXNwYWNlQ29tcGF0KHR1bm5lbCk7XG5jb25zdCBtaWRkbGV3YXJlUmVkdWNlciA9IChtaWRkbGV3YXJlKSA9PiBmdW5jdGlvbihob29rLCBkZWZhdWx0VmFsdWUsIC4uLmFyZ3MpIHtcbiAgY29uc3QgYmFpbEVhcmx5ID0gaG9vayA9PT0gXCJvbkVycm9yXCI7XG4gIGxldCB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaWRkbGV3YXJlW2hvb2tdLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IG1pZGRsZXdhcmVbaG9va11baV07XG4gICAgaWYgKHZhbHVlID0gaGFuZGxlcih2YWx1ZSwgLi4uYXJncyksIGJhaWxFYXJseSAmJiAhdmFsdWUpXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuZnVuY3Rpb24gY3JlYXRlUHViU3ViKCkge1xuICBjb25zdCBzdWJzY3JpYmVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbmV4dElkID0gMDtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICBjb25zdCBpZCA9IG5leHRJZCsrO1xuICAgIHJldHVybiBzdWJzY3JpYmVyc1tpZF0gPSBzdWJzY3JpYmVyLCBmdW5jdGlvbigpIHtcbiAgICAgIGRlbGV0ZSBzdWJzY3JpYmVyc1tpZF07XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBwdWJsaXNoKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiBzdWJzY3JpYmVycylcbiAgICAgIHN1YnNjcmliZXJzW2lkXShldmVudCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwdWJsaXNoLFxuICAgIHN1YnNjcmliZVxuICB9O1xufVxuY29uc3QgY2hhbm5lbE5hbWVzID0gW1xuICBcInJlcXVlc3RcIixcbiAgXCJyZXNwb25zZVwiLFxuICBcInByb2dyZXNzXCIsXG4gIFwiZXJyb3JcIixcbiAgXCJhYm9ydFwiXG5dLCBtaWRkbGVob29rcyA9IFtcbiAgXCJwcm9jZXNzT3B0aW9uc1wiLFxuICBcInZhbGlkYXRlT3B0aW9uc1wiLFxuICBcImludGVyY2VwdFJlcXVlc3RcIixcbiAgXCJmaW5hbGl6ZU9wdGlvbnNcIixcbiAgXCJvblJlcXVlc3RcIixcbiAgXCJvblJlc3BvbnNlXCIsXG4gIFwib25FcnJvclwiLFxuICBcIm9uUmV0dXJuXCIsXG4gIFwib25IZWFkZXJzXCJcbl07XG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0ZXIoaW5pdE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KSB7XG4gIGNvbnN0IGxvYWRlZE1pZGRsZXdhcmUgPSBbXSwgbWlkZGxld2FyZSA9IG1pZGRsZWhvb2tzLnJlZHVjZShcbiAgICAod2FyZSwgbmFtZSkgPT4gKHdhcmVbbmFtZV0gPSB3YXJlW25hbWVdIHx8IFtdLCB3YXJlKSxcbiAgICB7XG4gICAgICBwcm9jZXNzT3B0aW9uczogW2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLnByb2Nlc3NPcHRpb25zXSxcbiAgICAgIHZhbGlkYXRlT3B0aW9uczogW2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLnZhbGlkYXRlT3B0aW9uc11cbiAgICB9XG4gICk7XG4gIGZ1bmN0aW9uIHJlcXVlc3Qob3B0cykge1xuICAgIGNvbnN0IG9uUmVzcG9uc2UgPSAocmVxRXJyLCByZXMsIGN0eCkgPT4ge1xuICAgICAgbGV0IGVycm9yID0gcmVxRXJyLCByZXNwb25zZSA9IHJlcztcbiAgICAgIGlmICghZXJyb3IpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhcHBseU1pZGRsZXdhcmUoXCJvblJlc3BvbnNlXCIsIHJlcywgY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBudWxsLCBlcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgZXJyb3IgPSBlcnJvciAmJiBhcHBseU1pZGRsZXdhcmUoXCJvbkVycm9yXCIsIGVycm9yLCBjdHgpLCBlcnJvciA/IGNoYW5uZWxzLmVycm9yLnB1Ymxpc2goZXJyb3IpIDogcmVzcG9uc2UgJiYgY2hhbm5lbHMucmVzcG9uc2UucHVibGlzaChyZXNwb25zZSk7XG4gICAgfSwgY2hhbm5lbHMgPSBjaGFubmVsTmFtZXMucmVkdWNlKCh0YXJnZXQsIG5hbWUpID0+ICh0YXJnZXRbbmFtZV0gPSBjcmVhdGVQdWJTdWIoKSwgdGFyZ2V0KSwge30pLCBhcHBseU1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlUmVkdWNlcihtaWRkbGV3YXJlKSwgb3B0aW9ucyA9IGFwcGx5TWlkZGxld2FyZShcInByb2Nlc3NPcHRpb25zXCIsIG9wdHMpO1xuICAgIGFwcGx5TWlkZGxld2FyZShcInZhbGlkYXRlT3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICBjb25zdCBjb250ZXh0ID0geyBvcHRpb25zLCBjaGFubmVscywgYXBwbHlNaWRkbGV3YXJlIH07XG4gICAgbGV0IG9uZ29pbmdSZXF1ZXN0O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gY2hhbm5lbHMucmVxdWVzdC5zdWJzY3JpYmUoKGN0eCkgPT4ge1xuICAgICAgb25nb2luZ1JlcXVlc3QgPSBodHRwUmVxdWVzdChjdHgsIChlcnIsIHJlcykgPT4gb25SZXNwb25zZShlcnIsIHJlcywgY3R4KSk7XG4gICAgfSk7XG4gICAgY2hhbm5lbHMuYWJvcnQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHVuc3Vic2NyaWJlKCksIG9uZ29pbmdSZXF1ZXN0ICYmIG9uZ29pbmdSZXF1ZXN0LmFib3J0KCk7XG4gICAgfSk7XG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSBhcHBseU1pZGRsZXdhcmUoXCJvblJldHVyblwiLCBjaGFubmVscywgY29udGV4dCk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlID09PSBjaGFubmVscyAmJiBjaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2goY29udGV4dCksIHJldHVyblZhbHVlO1xuICB9XG4gIHJldHVybiByZXF1ZXN0LnVzZSA9IGZ1bmN0aW9uKG5ld01pZGRsZXdhcmUpIHtcbiAgICBpZiAoIW5ld01pZGRsZXdhcmUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBhZGQgbWlkZGxld2FyZSB0aGF0IHJlc29sdmVkIHRvIGZhbHNleSB2YWx1ZVwiKTtcbiAgICBpZiAodHlwZW9mIG5ld01pZGRsZXdhcmUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRyaWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRoYXQgd2FzIGEgZnVuY3Rpb24uIEl0IHByb2JhYmx5IGV4cGVjdHMgeW91IHRvIHBhc3Mgb3B0aW9ucyB0byBpdC5cIlxuICAgICAgKTtcbiAgICBpZiAobmV3TWlkZGxld2FyZS5vblJldHVybiAmJiBtaWRkbGV3YXJlLm9uUmV0dXJuLmxlbmd0aCA+IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVHJpZWQgdG8gYWRkIG5ldyBtaWRkbGV3YXJlIHdpdGggYG9uUmV0dXJuYCBoYW5kbGVyLCBidXQgYW5vdGhlciBoYW5kbGVyIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmVudFwiXG4gICAgICApO1xuICAgIHJldHVybiBtaWRkbGVob29rcy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIG5ld01pZGRsZXdhcmVba2V5XSAmJiBtaWRkbGV3YXJlW2tleV0ucHVzaChuZXdNaWRkbGV3YXJlW2tleV0pO1xuICAgIH0pLCBsb2FkZWRNaWRkbGV3YXJlLnB1c2gobmV3TWlkZGxld2FyZSksIHJlcXVlc3Q7XG4gIH0sIHJlcXVlc3QuY2xvbmUgPSAoKSA9PiBjcmVhdGVSZXF1ZXN0ZXIobG9hZGVkTWlkZGxld2FyZSwgaHR0cFJlcXVlc3QpLCBpbml0TWlkZGxld2FyZS5mb3JFYWNoKHJlcXVlc3QudXNlKSwgcmVxdWVzdDtcbn1cbmZ1bmN0aW9uIGxvd2VyQ2FzZUhlYWRlcnMoaGVhZGVycykge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycyB8fCB7fSkucmVkdWNlKChhY2MsIGhlYWRlcikgPT4gKGFjY1toZWFkZXIudG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJzW2hlYWRlcl0sIGFjYyksIHt9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEhvc3RuYW1lKGhvc3RuYW1lKSB7XG4gIHJldHVybiBob3N0bmFtZS5yZXBsYWNlKC9eXFwuKi8sIFwiLlwiKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gcGFyc2VOb1Byb3h5Wm9uZSh6b25lU3RyKSB7XG4gIGNvbnN0IHpvbmUgPSB6b25lU3RyLnRyaW0oKS50b0xvd2VyQ2FzZSgpLCB6b25lUGFydHMgPSB6b25lLnNwbGl0KFwiOlwiLCAyKSwgem9uZUhvc3QgPSBmb3JtYXRIb3N0bmFtZSh6b25lUGFydHNbMF0pLCB6b25lUG9ydCA9IHpvbmVQYXJ0c1sxXSwgaGFzUG9ydCA9IHpvbmUuaW5kZXhPZihcIjpcIikgPiAtMTtcbiAgcmV0dXJuIHsgaG9zdG5hbWU6IHpvbmVIb3N0LCBwb3J0OiB6b25lUG9ydCwgaGFzUG9ydCB9O1xufVxuZnVuY3Rpb24gdXJpSW5Ob1Byb3h5KHVyaSwgbm9Qcm94eSkge1xuICBjb25zdCBwb3J0ID0gdXJpLnBvcnQgfHwgKHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiNDQzXCIgOiBcIjgwXCIpLCBob3N0bmFtZSA9IGZvcm1hdEhvc3RuYW1lKHVyaS5ob3N0bmFtZSk7XG4gIHJldHVybiBub1Byb3h5LnNwbGl0KFwiLFwiKS5tYXAocGFyc2VOb1Byb3h5Wm9uZSkuc29tZSgobm9Qcm94eVpvbmUpID0+IHtcbiAgICBjb25zdCBpc01hdGNoZWRBdCA9IGhvc3RuYW1lLmluZGV4T2Yobm9Qcm94eVpvbmUuaG9zdG5hbWUpLCBob3N0bmFtZU1hdGNoZWQgPSBpc01hdGNoZWRBdCA+IC0xICYmIGlzTWF0Y2hlZEF0ID09PSBob3N0bmFtZS5sZW5ndGggLSBub1Byb3h5Wm9uZS5ob3N0bmFtZS5sZW5ndGg7XG4gICAgcmV0dXJuIG5vUHJveHlab25lLmhhc1BvcnQgPyBwb3J0ID09PSBub1Byb3h5Wm9uZS5wb3J0ICYmIGhvc3RuYW1lTWF0Y2hlZCA6IGhvc3RuYW1lTWF0Y2hlZDtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRQcm94eUZyb21VcmkodXJpKSB7XG4gIGNvbnN0IG5vUHJveHkgPSBwcm9jZXNzLmVudi5OT19QUk9YWSB8fCBwcm9jZXNzLmVudi5ub19wcm94eSB8fCBcIlwiO1xuICByZXR1cm4gbm9Qcm94eSA9PT0gXCIqXCIgfHwgbm9Qcm94eSAhPT0gXCJcIiAmJiB1cmlJbk5vUHJveHkodXJpLCBub1Byb3h5KSA/IG51bGwgOiB1cmkucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IHByb2Nlc3MuZW52LkhUVFBfUFJPWFkgfHwgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSB8fCBudWxsIDogdXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiICYmIChwcm9jZXNzLmVudi5IVFRQU19QUk9YWSB8fCBwcm9jZXNzLmVudi5odHRwc19wcm94eSB8fCBwcm9jZXNzLmVudi5IVFRQX1BST1hZIHx8IHByb2Nlc3MuZW52Lmh0dHBfcHJveHkpIHx8IG51bGw7XG59XG5mdW5jdGlvbiBnZXRIb3N0RnJvbVVyaSh1cmkpIHtcbiAgbGV0IGhvc3QgPSB1cmkuaG9zdDtcbiAgcmV0dXJuIHVyaS5wb3J0ICYmICh1cmkucG9ydCA9PT0gXCI4MFwiICYmIHVyaS5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHVyaS5wb3J0ID09PSBcIjQ0M1wiICYmIHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIikgJiYgKGhvc3QgPSB1cmkuaG9zdG5hbWUpLCBob3N0O1xufVxuZnVuY3Rpb24gZ2V0SG9zdEhlYWRlcldpdGhQb3J0KHVyaSkge1xuICBjb25zdCBwb3J0ID0gdXJpLnBvcnQgfHwgKHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiNDQzXCIgOiBcIjgwXCIpO1xuICByZXR1cm4gYCR7dXJpLmhvc3RuYW1lfToke3BvcnR9YDtcbn1cbmZ1bmN0aW9uIHJld3JpdGVVcmlGb3JQcm94eShyZXFPcHRzLCB1cmksIHByb3h5KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSByZXFPcHRzLmhlYWRlcnMgfHwge30sIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCByZXFPcHRzLCB7IGhlYWRlcnMgfSk7XG4gIHJldHVybiBoZWFkZXJzLmhvc3QgPSBoZWFkZXJzLmhvc3QgfHwgZ2V0SG9zdEhlYWRlcldpdGhQb3J0KHVyaSksIG9wdGlvbnMucHJvdG9jb2wgPSBwcm94eS5wcm90b2NvbCB8fCBvcHRpb25zLnByb3RvY29sLCBvcHRpb25zLmhvc3RuYW1lID0gcHJveHkuaG9zdC5yZXBsYWNlKC86XFxkKy8sIFwiXCIpLCBvcHRpb25zLnBvcnQgPSBwcm94eS5wb3J0LCBvcHRpb25zLmhvc3QgPSBnZXRIb3N0RnJvbVVyaShPYmplY3QuYXNzaWduKHt9LCB1cmksIHByb3h5KSksIG9wdGlvbnMuaHJlZiA9IGAke29wdGlvbnMucHJvdG9jb2x9Ly8ke29wdGlvbnMuaG9zdH0ke29wdGlvbnMucGF0aH1gLCBvcHRpb25zLnBhdGggPSB1cmxfX2RlZmF1bHQuZGVmYXVsdC5mb3JtYXQodXJpKSwgb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGdldFByb3h5T3B0aW9ucyhvcHRpb25zKSB7XG4gIGxldCBwcm94eTtcbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJwcm94eVwiKSlcbiAgICBwcm94eSA9IG9wdGlvbnMucHJveHk7XG4gIGVsc2Uge1xuICAgIGNvbnN0IHVyaSA9IHVybF9fZGVmYXVsdC5kZWZhdWx0LnBhcnNlKG9wdGlvbnMudXJsKTtcbiAgICBwcm94eSA9IGdldFByb3h5RnJvbVVyaSh1cmkpO1xuICB9XG4gIHJldHVybiB0eXBlb2YgcHJveHkgPT0gXCJzdHJpbmdcIiA/IHVybF9fZGVmYXVsdC5kZWZhdWx0LnBhcnNlKHByb3h5KSA6IHByb3h5O1xufVxuLyohIHNpbXBsZS1jb25jYXQuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmZ1bmN0aW9uIGNvbmNhdChzdHJlYW0sIGNiKSB7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICBzdHJlYW0ub24oXCJkYXRhXCIsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICB9KSwgc3RyZWFtLm9uY2UoXCJlbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgY2IgJiYgY2IobnVsbCwgQnVmZmVyLmNvbmNhdChjaHVua3MpKSwgY2IgPSBudWxsO1xuICB9KSwgc3RyZWFtLm9uY2UoXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICBjYiAmJiBjYihlcnIpLCBjYiA9IG51bGw7XG4gIH0pO1xufVxuZnVuY3Rpb24gdGltZWRPdXQocmVxLCB0aW1lKSB7XG4gIGlmIChyZXEudGltZW91dFRpbWVyKVxuICAgIHJldHVybiByZXE7XG4gIGNvbnN0IGRlbGF5cyA9IGlzTmFOKHRpbWUpID8gdGltZSA6IHsgc29ja2V0OiB0aW1lLCBjb25uZWN0OiB0aW1lIH0sIGhvc3RIZWFkZXIgPSByZXEuZ2V0SGVhZGVyKFwiaG9zdFwiKSwgaG9zdCA9IGhvc3RIZWFkZXIgPyBcIiB0byBcIiArIGhvc3RIZWFkZXIgOiBcIlwiO1xuICBkZWxheXMuY29ubmVjdCAhPT0gdm9pZCAwICYmIChyZXEudGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICByZXEuYWJvcnQoKTtcbiAgICBjb25zdCBlID0gbmV3IEVycm9yKFwiQ29ubmVjdGlvbiB0aW1lZCBvdXQgb24gcmVxdWVzdFwiICsgaG9zdCk7XG4gICAgZS5jb2RlID0gXCJFVElNRURPVVRcIiwgcmVxLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgfSwgZGVsYXlzLmNvbm5lY3QpKSwgcmVxLm9uKFwic29ja2V0XCIsIGZ1bmN0aW9uKHNvY2tldCkge1xuICAgIGlmICghKHNvY2tldC5jb25uZWN0aW5nIHx8IHNvY2tldC5fY29ubmVjdGluZykpIHtcbiAgICAgIGNvbm5lY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc29ja2V0Lm9uY2UoXCJjb25uZWN0XCIsIGNvbm5lY3QpO1xuICB9KTtcbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgcmVxLnRpbWVvdXRUaW1lciAmJiAoY2xlYXJUaW1lb3V0KHJlcS50aW1lb3V0VGltZXIpLCByZXEudGltZW91dFRpbWVyID0gbnVsbCk7XG4gIH1cbiAgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICBjbGVhcigpLCBkZWxheXMuc29ja2V0ICE9PSB2b2lkIDAgJiYgcmVxLnNldFRpbWVvdXQoZGVsYXlzLnNvY2tldCwgZnVuY3Rpb24oKSB7XG4gICAgICByZXEuYWJvcnQoKTtcbiAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXCJTb2NrZXQgdGltZWQgb3V0IG9uIHJlcXVlc3RcIiArIGhvc3QpO1xuICAgICAgZS5jb2RlID0gXCJFU09DS0VUVElNRURPVVRcIiwgcmVxLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVxLm9uKFwiZXJyb3JcIiwgY2xlYXIpO1xufVxuY29uc3QgdXJpUGFydHMgPSBbXG4gIFwicHJvdG9jb2xcIixcbiAgXCJzbGFzaGVzXCIsXG4gIFwiYXV0aFwiLFxuICBcImhvc3RcIixcbiAgXCJwb3J0XCIsXG4gIFwiaG9zdG5hbWVcIixcbiAgXCJoYXNoXCIsXG4gIFwic2VhcmNoXCIsXG4gIFwicXVlcnlcIixcbiAgXCJwYXRobmFtZVwiLFxuICBcInBhdGhcIixcbiAgXCJocmVmXCJcbl0sIGRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdCA9IFtcbiAgXCJhY2NlcHRcIixcbiAgXCJhY2NlcHQtY2hhcnNldFwiLFxuICBcImFjY2VwdC1lbmNvZGluZ1wiLFxuICBcImFjY2VwdC1sYW5ndWFnZVwiLFxuICBcImFjY2VwdC1yYW5nZXNcIixcbiAgXCJjYWNoZS1jb250cm9sXCIsXG4gIFwiY29udGVudC1lbmNvZGluZ1wiLFxuICBcImNvbnRlbnQtbGFuZ3VhZ2VcIixcbiAgXCJjb250ZW50LWxvY2F0aW9uXCIsXG4gIFwiY29udGVudC1tZDVcIixcbiAgXCJjb250ZW50LXJhbmdlXCIsXG4gIFwiY29udGVudC10eXBlXCIsXG4gIFwiY29ubmVjdGlvblwiLFxuICBcImRhdGVcIixcbiAgXCJleHBlY3RcIixcbiAgXCJtYXgtZm9yd2FyZHNcIixcbiAgXCJwcmFnbWFcIixcbiAgXCJyZWZlcmVyXCIsXG4gIFwidGVcIixcbiAgXCJ1c2VyLWFnZW50XCIsXG4gIFwidmlhXCJcbl0sIGRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBbXCJwcm94eS1hdXRob3JpemF0aW9uXCJdO1xuZnVuY3Rpb24gc2hvdWxkRW5hYmxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHR5cGVvZiBvcHRpb25zLnR1bm5lbCA8IFwidVwiID8gISFvcHRpb25zLnR1bm5lbCA6IHVybF9fZGVmYXVsdC5kZWZhdWx0LnBhcnNlKG9wdGlvbnMudXJsKS5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbn1cbmZ1bmN0aW9uIGFwcGx5QWdlbnQob3B0cyA9IHt9LCBwcm94eSkge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHByb3h5SGVhZGVyV2hpdGVMaXN0ID0gZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0LmNvbmNhdChvcHRpb25zLnByb3h5SGVhZGVyV2hpdGVMaXN0IHx8IFtdKS5tYXAoKGhlYWRlcikgPT4gaGVhZGVyLnRvTG93ZXJDYXNlKCkpLCBwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0LmNvbmNhdChvcHRpb25zLnByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCB8fCBbXSkubWFwKChoZWFkZXIpID0+IGhlYWRlci50b0xvd2VyQ2FzZSgpKSwgcHJveHlIZWFkZXJzID0gZ2V0QWxsb3dlZFByb3h5SGVhZGVycyhvcHRpb25zLmhlYWRlcnMsIHByb3h5SGVhZGVyV2hpdGVMaXN0KTtcbiAgcHJveHlIZWFkZXJzLmhvc3QgPSBjb25zdHJ1Y3RQcm94eUhvc3Qob3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycyB8fCB7fSkucmVkdWNlKChoZWFkZXJzLCBoZWFkZXIpID0+IChwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgPT09IC0xICYmIChoZWFkZXJzW2hlYWRlcl0gPSBvcHRpb25zLmhlYWRlcnNbaGVhZGVyXSksIGhlYWRlcnMpLCB7fSk7XG4gIGNvbnN0IHR1bm5lbEZuID0gZ2V0VHVubmVsRm4ob3B0aW9ucywgcHJveHkpLCB0dW5uZWxPcHRpb25zID0gY29uc3RydWN0VHVubmVsT3B0aW9ucyhvcHRpb25zLCBwcm94eSwgcHJveHlIZWFkZXJzKTtcbiAgcmV0dXJuIG9wdGlvbnMuYWdlbnQgPSB0dW5uZWxGbih0dW5uZWxPcHRpb25zKSwgb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGdldFR1bm5lbEZuKG9wdGlvbnMsIHByb3h5KSB7XG4gIGNvbnN0IHVyaSA9IGdldFVyaVBhcnRzKG9wdGlvbnMpLCB0dW5uZWxGbk5hbWUgPSBjb25zdHJ1Y3RUdW5uZWxGbk5hbWUodXJpLCBwcm94eSk7XG4gIHJldHVybiB0dW5uZWxfX25hbWVzcGFjZVt0dW5uZWxGbk5hbWVdO1xufVxuZnVuY3Rpb24gZ2V0VXJpUGFydHMob3B0aW9ucykge1xuICByZXR1cm4gdXJpUGFydHMucmVkdWNlKCh1cmksIHBhcnQpID0+ICh1cmlbcGFydF0gPSBvcHRpb25zW3BhcnRdLCB1cmkpLCB7fSk7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RUdW5uZWxGbk5hbWUodXJpLCBwcm94eSkge1xuICBjb25zdCB1cmlQcm90b2NvbCA9IHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiLCBwcm94eVByb3RvY29sID0gcHJveHkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIkh0dHBzXCIgOiBcIkh0dHBcIjtcbiAgcmV0dXJuIGAke3VyaVByb3RvY29sfU92ZXIke3Byb3h5UHJvdG9jb2x9YDtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFByb3h5SG9zdCh1cmkpIHtcbiAgY29uc3QgcG9ydCA9IHVyaS5wb3J0LCBwcm90b2NvbCA9IHVyaS5wcm90b2NvbDtcbiAgbGV0IHByb3h5SG9zdCA9IGAke3VyaS5ob3N0bmFtZX06YDtcbiAgcmV0dXJuIHBvcnQgPyBwcm94eUhvc3QgKz0gcG9ydCA6IHByb3RvY29sID09PSBcImh0dHBzOlwiID8gcHJveHlIb3N0ICs9IFwiNDQzXCIgOiBwcm94eUhvc3QgKz0gXCI4MFwiLCBwcm94eUhvc3Q7XG59XG5mdW5jdGlvbiBnZXRBbGxvd2VkUHJveHlIZWFkZXJzKGhlYWRlcnMsIHdoaXRlTGlzdCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycykuZmlsdGVyKChoZWFkZXIpID0+IHdoaXRlTGlzdC5pbmRleE9mKGhlYWRlci50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpLnJlZHVjZSgoc2V0LCBoZWFkZXIpID0+IChzZXRbaGVhZGVyXSA9IGhlYWRlcnNbaGVhZGVyXSwgc2V0KSwge30pO1xufVxuZnVuY3Rpb24gY29uc3RydWN0VHVubmVsT3B0aW9ucyhvcHRpb25zLCBwcm94eSwgcHJveHlIZWFkZXJzKSB7XG4gIHJldHVybiB7XG4gICAgcHJveHk6IHtcbiAgICAgIGhvc3Q6IHByb3h5Lmhvc3RuYW1lLFxuICAgICAgcG9ydDogK3Byb3h5LnBvcnQsXG4gICAgICBwcm94eUF1dGg6IHByb3h5LmF1dGgsXG4gICAgICBoZWFkZXJzOiBwcm94eUhlYWRlcnNcbiAgICB9LFxuICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICBjYTogb3B0aW9ucy5jYSxcbiAgICBjZXJ0OiBvcHRpb25zLmNlcnQsXG4gICAga2V5OiBvcHRpb25zLmtleSxcbiAgICBwYXNzcGhyYXNlOiBvcHRpb25zLnBhc3NwaHJhc2UsXG4gICAgcGZ4OiBvcHRpb25zLnBmeCxcbiAgICBjaXBoZXJzOiBvcHRpb25zLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBzZWN1cmVPcHRpb25zOiBvcHRpb25zLnNlY3VyZU9wdGlvbnMsXG4gICAgc2VjdXJlUHJvdG9jb2w6IG9wdGlvbnMuc2VjdXJlUHJvdG9jb2xcbiAgfTtcbn1cbmNvbnN0IGFkYXB0ZXIgPSBcIm5vZGVcIiwgcmVkdWNlUmVzcG9uc2UgPSAocmVzLCByZXFVcmwsIG1ldGhvZCwgYm9keSkgPT4gKHtcbiAgYm9keSxcbiAgdXJsOiByZXFVcmwsXG4gIG1ldGhvZCxcbiAgaGVhZGVyczogcmVzLmhlYWRlcnMsXG4gIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXNDb2RlLFxuICBzdGF0dXNNZXNzYWdlOiByZXMuc3RhdHVzTWVzc2FnZVxufSksIGh0dHBSZXF1ZXN0ZXIgPSAoY29udGV4dCwgY2IpID0+IHtcbiAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0LCB1cmkgPSBPYmplY3QuYXNzaWduKHt9LCB1cmxfX2RlZmF1bHQuZGVmYXVsdC5wYXJzZShvcHRpb25zLnVybCkpO1xuICBpZiAodHlwZW9mIGZldGNoID09IFwiZnVuY3Rpb25cIiAmJiBvcHRpb25zLmZldGNoKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSwgcmVxT3B0czIgPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcImZpbmFsaXplT3B0aW9uc1wiLCB7XG4gICAgICAuLi51cmksXG4gICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50eXBlb2Ygb3B0aW9ucy5mZXRjaCA9PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuZmV0Y2guaGVhZGVycyA/IGxvd2VyQ2FzZUhlYWRlcnMob3B0aW9ucy5mZXRjaC5oZWFkZXJzKSA6IHt9LFxuICAgICAgICAuLi5sb3dlckNhc2VIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICAgIH0sXG4gICAgICBtYXhSZWRpcmVjdHM6IG9wdGlvbnMubWF4UmVkaXJlY3RzXG4gICAgfSksIGZldGNoT3B0cyA9IHtcbiAgICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zLndpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJvbWl0XCIsXG4gICAgICAuLi50eXBlb2Ygb3B0aW9ucy5mZXRjaCA9PSBcIm9iamVjdFwiID8gb3B0aW9ucy5mZXRjaCA6IHt9LFxuICAgICAgbWV0aG9kOiByZXFPcHRzMi5tZXRob2QsXG4gICAgICBoZWFkZXJzOiByZXFPcHRzMi5oZWFkZXJzLFxuICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgIH0sIGluamVjdGVkUmVzcG9uc2UyID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJpbnRlcmNlcHRSZXF1ZXN0XCIsIHZvaWQgMCwge1xuICAgICAgYWRhcHRlcixcbiAgICAgIGNvbnRleHRcbiAgICB9KTtcbiAgICBpZiAoaW5qZWN0ZWRSZXNwb25zZTIpIHtcbiAgICAgIGNvbnN0IGNiVGltZXIgPSBzZXRUaW1lb3V0KGNiLCAwLCBudWxsLCBpbmplY3RlZFJlc3BvbnNlMik7XG4gICAgICByZXR1cm4geyBhYm9ydDogKCkgPT4gY2xlYXJUaW1lb3V0KGNiVGltZXIpIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QyID0gZmV0Y2gob3B0aW9ucy51cmwsIGZldGNoT3B0cyk7XG4gICAgcmV0dXJuIGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwib25SZXF1ZXN0XCIsIHsgb3B0aW9ucywgYWRhcHRlciwgcmVxdWVzdDogcmVxdWVzdDIsIGNvbnRleHQgfSksIHJlcXVlc3QyLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMucmF3Qm9keSA/IHJlcy5ib2R5IDogYXdhaXQgcmVzLnRleHQoKSwgaGVhZGVycyA9IHt9O1xuICAgICAgcmVzLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pLCBjYihudWxsLCB7XG4gICAgICAgIGJvZHksXG4gICAgICAgIHVybDogcmVzLnVybCxcbiAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGVyci5uYW1lICE9IFwiQWJvcnRFcnJvclwiICYmIGNiKGVycik7XG4gICAgfSksIHsgYWJvcnQ6ICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSB9O1xuICB9XG4gIGNvbnN0IGJvZHlUeXBlID0gaXNTdHJlYW1fX2RlZmF1bHQuZGVmYXVsdChvcHRpb25zLmJvZHkpID8gXCJzdHJlYW1cIiA6IHR5cGVvZiBvcHRpb25zLmJvZHk7XG4gIGlmIChib2R5VHlwZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBib2R5VHlwZSAhPT0gXCJzdHJlYW1cIiAmJiBib2R5VHlwZSAhPT0gXCJzdHJpbmdcIiAmJiAhQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuYm9keSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0IGJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbSwgZ290ICR7Ym9keVR5cGV9YCk7XG4gIGNvbnN0IGxlbmd0aEhlYWRlciA9IHt9O1xuICBvcHRpb25zLmJvZHlTaXplID8gbGVuZ3RoSGVhZGVyW1wiY29udGVudC1sZW5ndGhcIl0gPSBvcHRpb25zLmJvZHlTaXplIDogb3B0aW9ucy5ib2R5ICYmIGJvZHlUeXBlICE9PSBcInN0cmVhbVwiICYmIChsZW5ndGhIZWFkZXJbXCJjb250ZW50LWxlbmd0aFwiXSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG9wdGlvbnMuYm9keSkpO1xuICBsZXQgYWJvcnRlZCA9ICExO1xuICBjb25zdCBjYWxsYmFjayA9IChlcnIsIHJlcykgPT4gIWFib3J0ZWQgJiYgY2IoZXJyLCByZXMpO1xuICBjb250ZXh0LmNoYW5uZWxzLmFib3J0LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgYWJvcnRlZCA9ICEwO1xuICB9KTtcbiAgbGV0IHJlcU9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB1cmksIHtcbiAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGxvd2VyQ2FzZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKSwgbGVuZ3RoSGVhZGVyKSxcbiAgICBtYXhSZWRpcmVjdHM6IG9wdGlvbnMubWF4UmVkaXJlY3RzXG4gIH0pO1xuICBjb25zdCBwcm94eSA9IGdldFByb3h5T3B0aW9ucyhvcHRpb25zKSwgdHVubmVsMiA9IHByb3h5ICYmIHNob3VsZEVuYWJsZShvcHRpb25zKSwgaW5qZWN0ZWRSZXNwb25zZSA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwiaW50ZXJjZXB0UmVxdWVzdFwiLCB2b2lkIDAsIHtcbiAgICBhZGFwdGVyLFxuICAgIGNvbnRleHRcbiAgfSk7XG4gIGlmIChpbmplY3RlZFJlc3BvbnNlKSB7XG4gICAgY29uc3QgY2JUaW1lciA9IHNldEltbWVkaWF0ZShjYWxsYmFjaywgbnVsbCwgaW5qZWN0ZWRSZXNwb25zZSk7XG4gICAgcmV0dXJuIHsgYWJvcnQ6ICgpID0+IGNsZWFySW1tZWRpYXRlKGNiVGltZXIpIH07XG4gIH1cbiAgaWYgKG9wdGlvbnMubWF4UmVkaXJlY3RzICE9PSAwICYmIChyZXFPcHRzLm1heFJlZGlyZWN0cyA9IG9wdGlvbnMubWF4UmVkaXJlY3RzIHx8IDUpLCBwcm94eSAmJiB0dW5uZWwyID8gcmVxT3B0cyA9IGFwcGx5QWdlbnQocmVxT3B0cywgcHJveHkpIDogcHJveHkgJiYgIXR1bm5lbDIgJiYgKHJlcU9wdHMgPSByZXdyaXRlVXJpRm9yUHJveHkocmVxT3B0cywgdXJpLCBwcm94eSkpLCAhdHVubmVsMiAmJiBwcm94eSAmJiBwcm94eS5hdXRoICYmICFyZXFPcHRzLmhlYWRlcnNbXCJwcm94eS1hdXRob3JpemF0aW9uXCJdKSB7XG4gICAgY29uc3QgW3VzZXJuYW1lLCBwYXNzd29yZF0gPSBwcm94eS5hdXRoLnVzZXJuYW1lID8gW3Byb3h5LmF1dGgudXNlcm5hbWUsIHByb3h5LmF1dGgucGFzc3dvcmRdIDogcHJveHkuYXV0aC5zcGxpdChcIjpcIikubWFwKChpdGVtKSA9PiBxc19fZGVmYXVsdC5kZWZhdWx0LnVuZXNjYXBlKGl0ZW0pKSwgYXV0aEJhc2U2NCA9IEJ1ZmZlci5mcm9tKGAke3VzZXJuYW1lfToke3Bhc3N3b3JkfWAsIFwidXRmOFwiKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICByZXFPcHRzLmhlYWRlcnNbXCJwcm94eS1hdXRob3JpemF0aW9uXCJdID0gYEJhc2ljICR7YXV0aEJhc2U2NH1gO1xuICB9XG4gIGNvbnN0IHRyYW5zcG9ydCA9IGdldFJlcXVlc3RUcmFuc3BvcnQocmVxT3B0cywgcHJveHksIHR1bm5lbDIpO1xuICB0eXBlb2Ygb3B0aW9ucy5kZWJ1ZyA9PSBcImZ1bmN0aW9uXCIgJiYgcHJveHkgJiYgb3B0aW9ucy5kZWJ1ZyhcbiAgICBcIlByb3h5aW5nIHVzaW5nICVzXCIsXG4gICAgcmVxT3B0cy5hZ2VudCA/IFwidHVubmVsIGFnZW50XCIgOiBgJHtyZXFPcHRzLmhvc3R9OiR7cmVxT3B0cy5wb3J0fWBcbiAgKTtcbiAgY29uc3QgdHJ5Q29tcHJlc3NlZCA9IHJlcU9wdHMubWV0aG9kICE9PSBcIkhFQURcIjtcbiAgdHJ5Q29tcHJlc3NlZCAmJiAhcmVxT3B0cy5oZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdICYmIG9wdGlvbnMuY29tcHJlc3MgIT09ICExICYmIChyZXFPcHRzLmhlYWRlcnNbXCJhY2NlcHQtZW5jb2RpbmdcIl0gPSBcImJyLCBnemlwLCBkZWZsYXRlXCIpO1xuICBjb25zdCBmaW5hbE9wdGlvbnMgPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcbiAgICBcImZpbmFsaXplT3B0aW9uc1wiLFxuICAgIHJlcU9wdHNcbiAgKSwgcmVxdWVzdCA9IHRyYW5zcG9ydC5yZXF1ZXN0KGZpbmFsT3B0aW9ucywgKHJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3QgcmVzID0gdHJ5Q29tcHJlc3NlZCA/IGRlY29tcHJlc3NSZXNwb25zZV9fZGVmYXVsdC5kZWZhdWx0KHJlc3BvbnNlKSA6IHJlc3BvbnNlLCByZXNTdHJlYW0gPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcIm9uSGVhZGVyc1wiLCByZXMsIHtcbiAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBhZGFwdGVyLFxuICAgICAgY29udGV4dFxuICAgIH0pLCByZXFVcmwgPSBcInJlc3BvbnNlVXJsXCIgaW4gcmVzcG9uc2UgPyByZXNwb25zZS5yZXNwb25zZVVybCA6IG9wdGlvbnMudXJsO1xuICAgIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgcmVkdWNlUmVzcG9uc2UocmVzLCByZXFVcmwsIHJlcU9wdHMubWV0aG9kLCByZXNTdHJlYW0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uY2F0KHJlc1N0cmVhbSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycilcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5yYXdCb2R5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKSwgcmVkdWNlZCA9IHJlZHVjZVJlc3BvbnNlKHJlcywgcmVxVXJsLCByZXFPcHRzLm1ldGhvZCwgYm9keSk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVkdWNlZCk7XG4gICAgfSk7XG4gIH0pO1xuICBvcHRpb25zLnRpbWVvdXQgJiYgdGltZWRPdXQocmVxdWVzdCwgb3B0aW9ucy50aW1lb3V0KSwgcmVxdWVzdC5vbmNlKFwiZXJyb3JcIiwgY2FsbGJhY2spO1xuICBjb25zdCB7IGJvZHlTdHJlYW0sIHByb2dyZXNzIH0gPSBnZXRQcm9ncmVzc1N0cmVhbShvcHRpb25zKTtcbiAgcmV0dXJuIGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwib25SZXF1ZXN0XCIsIHsgb3B0aW9ucywgYWRhcHRlciwgcmVxdWVzdCwgY29udGV4dCwgcHJvZ3Jlc3MgfSksIGJvZHlTdHJlYW0gPyBib2R5U3RyZWFtLnBpcGUocmVxdWVzdCkgOiByZXF1ZXN0LmVuZChvcHRpb25zLmJvZHkpLCB7IGFib3J0OiAoKSA9PiByZXF1ZXN0LmFib3J0KCkgfTtcbn07XG5mdW5jdGlvbiBnZXRQcm9ncmVzc1N0cmVhbShvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucy5ib2R5KVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgYm9keUlzU3RyZWFtID0gaXNTdHJlYW1fX2RlZmF1bHQuZGVmYXVsdChvcHRpb25zLmJvZHkpLCBsZW5ndGggPSBvcHRpb25zLmJvZHlTaXplIHx8IChib2R5SXNTdHJlYW0gPyBudWxsIDogQnVmZmVyLmJ5dGVMZW5ndGgob3B0aW9ucy5ib2R5KSk7XG4gIGlmICghbGVuZ3RoKVxuICAgIHJldHVybiBib2R5SXNTdHJlYW0gPyB7IGJvZHlTdHJlYW06IG9wdGlvbnMuYm9keSB9IDoge307XG4gIGNvbnN0IHByb2dyZXNzID0gcHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQuZGVmYXVsdCh7IHRpbWU6IDE2LCBsZW5ndGggfSk7XG4gIHJldHVybiB7IGJvZHlTdHJlYW06IChib2R5SXNTdHJlYW0gPyBvcHRpb25zLmJvZHkgOiB0b1N0cmVhbV9fZGVmYXVsdC5kZWZhdWx0KG9wdGlvbnMuYm9keSkpLnBpcGUocHJvZ3Jlc3MpLCBwcm9ncmVzcyB9O1xufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdFRyYW5zcG9ydChyZXFPcHRzLCBwcm94eSwgdHVubmVsMikge1xuICBjb25zdCBpc0h0dHBzUmVxdWVzdCA9IHJlcU9wdHMucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIsIHRyYW5zcG9ydHMgPSByZXFPcHRzLm1heFJlZGlyZWN0cyA9PT0gMCA/IHsgaHR0cDogaHR0cF9fZGVmYXVsdC5kZWZhdWx0LCBodHRwczogaHR0cHNfX2RlZmF1bHQuZGVmYXVsdCB9IDogeyBodHRwOiBmb2xsb3dfX2RlZmF1bHQuZGVmYXVsdC5odHRwLCBodHRwczogZm9sbG93X19kZWZhdWx0LmRlZmF1bHQuaHR0cHMgfTtcbiAgaWYgKCFwcm94eSB8fCB0dW5uZWwyKVxuICAgIHJldHVybiBpc0h0dHBzUmVxdWVzdCA/IHRyYW5zcG9ydHMuaHR0cHMgOiB0cmFuc3BvcnRzLmh0dHA7XG4gIGxldCBpc0h0dHBzUHJveHkgPSBwcm94eS5wb3J0ID09PSA0NDM7XG4gIHJldHVybiBwcm94eS5wcm90b2NvbCAmJiAoaXNIdHRwc1Byb3h5ID0gL15odHRwczo/Ly50ZXN0KHByb3h5LnByb3RvY29sKSksIGlzSHR0cHNQcm94eSA/IHRyYW5zcG9ydHMuaHR0cHMgOiB0cmFuc3BvcnRzLmh0dHA7XG59XG5jb25zdCBnZXRJdCA9IChpbml0TWlkZGxld2FyZSA9IFtdLCBodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0ZXIpID0+IGNyZWF0ZVJlcXVlc3Rlcihpbml0TWlkZGxld2FyZSwgaHR0cFJlcXVlc3QpLCBlbnZpcm9ubWVudCA9IFwibm9kZVwiO1xuZXhwb3J0cy5hZGFwdGVyID0gYWRhcHRlcjtcbmV4cG9ydHMuZW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudDtcbmV4cG9ydHMuZ2V0SXQgPSBnZXRJdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXBcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHRPcHRpb25zVmFsaWRhdG9yIiwicmVxdWlyZSIsImRlY29tcHJlc3NSZXNwb25zZSIsImZvbGxvdyIsImh0dHAiLCJodHRwcyIsInRvU3RyZWFtIiwiaXNTdHJlYW0iLCJwcm9ncmVzc1N0cmVhbSIsInFzIiwidXJsIiwidHVubmVsIiwiX2ludGVyb3BEZWZhdWx0Q29tcGF0IiwiZSIsImRlZmF1bHQiLCJfaW50ZXJvcE5hbWVzcGFjZUNvbXBhdCIsIm4iLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsImRlY29tcHJlc3NSZXNwb25zZV9fZGVmYXVsdCIsImZvbGxvd19fZGVmYXVsdCIsImh0dHBfX2RlZmF1bHQiLCJodHRwc19fZGVmYXVsdCIsInRvU3RyZWFtX19kZWZhdWx0IiwiaXNTdHJlYW1fX2RlZmF1bHQiLCJwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdCIsInFzX19kZWZhdWx0IiwidXJsX19kZWZhdWx0IiwidHVubmVsX19uYW1lc3BhY2UiLCJtaWRkbGV3YXJlUmVkdWNlciIsIm1pZGRsZXdhcmUiLCJob29rIiwiZGVmYXVsdFZhbHVlIiwiYXJncyIsImJhaWxFYXJseSIsImkiLCJsZW5ndGgiLCJoYW5kbGVyIiwiY3JlYXRlUHViU3ViIiwic3Vic2NyaWJlcnMiLCJuZXh0SWQiLCJzdWJzY3JpYmUiLCJzdWJzY3JpYmVyIiwiaWQiLCJwdWJsaXNoIiwiZXZlbnQiLCJjaGFubmVsTmFtZXMiLCJtaWRkbGVob29rcyIsImNyZWF0ZVJlcXVlc3RlciIsImluaXRNaWRkbGV3YXJlIiwiaHR0cFJlcXVlc3QiLCJsb2FkZWRNaWRkbGV3YXJlIiwicmVkdWNlIiwid2FyZSIsIm5hbWUiLCJwcm9jZXNzT3B0aW9ucyIsInZhbGlkYXRlT3B0aW9ucyIsInJlcXVlc3QiLCJvcHRzIiwib25SZXNwb25zZSIsInJlcUVyciIsInJlcyIsImN0eCIsImVycm9yIiwicmVzcG9uc2UiLCJhcHBseU1pZGRsZXdhcmUiLCJlcnIiLCJjaGFubmVscyIsInRhcmdldCIsIm9wdGlvbnMiLCJjb250ZXh0Iiwib25nb2luZ1JlcXVlc3QiLCJ1bnN1YnNjcmliZSIsImFib3J0IiwicmV0dXJuVmFsdWUiLCJ1c2UiLCJuZXdNaWRkbGV3YXJlIiwiRXJyb3IiLCJvblJldHVybiIsImtleSIsInB1c2giLCJjbG9uZSIsImxvd2VyQ2FzZUhlYWRlcnMiLCJoZWFkZXJzIiwiYWNjIiwiaGVhZGVyIiwidG9Mb3dlckNhc2UiLCJmb3JtYXRIb3N0bmFtZSIsImhvc3RuYW1lIiwicmVwbGFjZSIsInBhcnNlTm9Qcm94eVpvbmUiLCJ6b25lU3RyIiwiem9uZSIsInRyaW0iLCJ6b25lUGFydHMiLCJzcGxpdCIsInpvbmVIb3N0Iiwiem9uZVBvcnQiLCJoYXNQb3J0IiwiaW5kZXhPZiIsInBvcnQiLCJ1cmlJbk5vUHJveHkiLCJ1cmkiLCJub1Byb3h5IiwicHJvdG9jb2wiLCJtYXAiLCJzb21lIiwibm9Qcm94eVpvbmUiLCJpc01hdGNoZWRBdCIsImhvc3RuYW1lTWF0Y2hlZCIsImdldFByb3h5RnJvbVVyaSIsInByb2Nlc3MiLCJlbnYiLCJOT19QUk9YWSIsIm5vX3Byb3h5IiwiSFRUUF9QUk9YWSIsImh0dHBfcHJveHkiLCJIVFRQU19QUk9YWSIsImh0dHBzX3Byb3h5IiwiZ2V0SG9zdEZyb21VcmkiLCJob3N0IiwiZ2V0SG9zdEhlYWRlcldpdGhQb3J0IiwicmV3cml0ZVVyaUZvclByb3h5IiwicmVxT3B0cyIsInByb3h5IiwiYXNzaWduIiwiaHJlZiIsInBhdGgiLCJmb3JtYXQiLCJnZXRQcm94eU9wdGlvbnMiLCJoYXNPd25Qcm9wZXJ0eSIsInBhcnNlIiwiY29uY2F0Iiwic3RyZWFtIiwiY2IiLCJjaHVua3MiLCJvbiIsImNodW5rIiwib25jZSIsIkJ1ZmZlciIsInRpbWVkT3V0IiwicmVxIiwidGltZSIsInRpbWVvdXRUaW1lciIsImRlbGF5cyIsImlzTmFOIiwic29ja2V0IiwiY29ubmVjdCIsImhvc3RIZWFkZXIiLCJnZXRIZWFkZXIiLCJzZXRUaW1lb3V0IiwiY29kZSIsImVtaXQiLCJjb25uZWN0aW5nIiwiX2Nvbm5lY3RpbmciLCJjbGVhciIsImNsZWFyVGltZW91dCIsInVyaVBhcnRzIiwiZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0IiwiZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCIsInNob3VsZEVuYWJsZSIsImFwcGx5QWdlbnQiLCJwcm94eUhlYWRlcldoaXRlTGlzdCIsInByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCIsInByb3h5SGVhZGVycyIsImdldEFsbG93ZWRQcm94eUhlYWRlcnMiLCJjb25zdHJ1Y3RQcm94eUhvc3QiLCJ0dW5uZWxGbiIsImdldFR1bm5lbEZuIiwidHVubmVsT3B0aW9ucyIsImNvbnN0cnVjdFR1bm5lbE9wdGlvbnMiLCJhZ2VudCIsImdldFVyaVBhcnRzIiwidHVubmVsRm5OYW1lIiwiY29uc3RydWN0VHVubmVsRm5OYW1lIiwicGFydCIsInVyaVByb3RvY29sIiwicHJveHlQcm90b2NvbCIsInByb3h5SG9zdCIsIndoaXRlTGlzdCIsImZpbHRlciIsInNldCIsInByb3h5QXV0aCIsImF1dGgiLCJjYSIsImNlcnQiLCJwYXNzcGhyYXNlIiwicGZ4IiwiY2lwaGVycyIsInJlamVjdFVuYXV0aG9yaXplZCIsInNlY3VyZU9wdGlvbnMiLCJzZWN1cmVQcm90b2NvbCIsImFkYXB0ZXIiLCJyZWR1Y2VSZXNwb25zZSIsInJlcVVybCIsIm1ldGhvZCIsImJvZHkiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsImh0dHBSZXF1ZXN0ZXIiLCJmZXRjaCIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJyZXFPcHRzMiIsIm1heFJlZGlyZWN0cyIsImZldGNoT3B0cyIsImNyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwic2lnbmFsIiwiaW5qZWN0ZWRSZXNwb25zZTIiLCJjYlRpbWVyIiwicmVxdWVzdDIiLCJ0aGVuIiwicmF3Qm9keSIsInRleHQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiY2F0Y2giLCJib2R5VHlwZSIsImlzQnVmZmVyIiwibGVuZ3RoSGVhZGVyIiwiYm9keVNpemUiLCJieXRlTGVuZ3RoIiwiYWJvcnRlZCIsImNhbGxiYWNrIiwidHVubmVsMiIsImluamVjdGVkUmVzcG9uc2UiLCJzZXRJbW1lZGlhdGUiLCJjbGVhckltbWVkaWF0ZSIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJpdGVtIiwidW5lc2NhcGUiLCJhdXRoQmFzZTY0IiwiZnJvbSIsInRvU3RyaW5nIiwidHJhbnNwb3J0IiwiZ2V0UmVxdWVzdFRyYW5zcG9ydCIsImRlYnVnIiwidHJ5Q29tcHJlc3NlZCIsImNvbXByZXNzIiwiZmluYWxPcHRpb25zIiwicmVzU3RyZWFtIiwicmVzcG9uc2VVcmwiLCJkYXRhIiwicmVkdWNlZCIsInRpbWVvdXQiLCJib2R5U3RyZWFtIiwicHJvZ3Jlc3MiLCJnZXRQcm9ncmVzc1N0cmVhbSIsInBpcGUiLCJlbmQiLCJib2R5SXNTdHJlYW0iLCJpc0h0dHBzUmVxdWVzdCIsInRyYW5zcG9ydHMiLCJpc0h0dHBzUHJveHkiLCJ0ZXN0IiwiZ2V0SXQiLCJlbnZpcm9ubWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/middleware.cjs":
/*!*************************************************!*\
  !*** ./node_modules/get-it/dist/middleware.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: !0\n}));\nvar http = __webpack_require__(/*! http */ \"http\"), https = __webpack_require__(/*! https */ \"https\"), debugIt = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\"), defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-CXwrNjme.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-CXwrNjme.cjs\"), isPlainObject = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.js\"), progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\"), allowed = __webpack_require__(/*! is-retry-allowed */ \"(ssr)/./node_modules/is-retry-allowed/index.js\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e == \"object\" && \"default\" in e ? e : {\n        default: e\n    };\n}\nvar debugIt__default = /* @__PURE__ */ _interopDefaultCompat(debugIt), progressStream__default = /* @__PURE__ */ _interopDefaultCompat(progressStream), allowed__default = /* @__PURE__ */ _interopDefaultCompat(allowed);\nconst isHttpsProto = /^https:/i;\nfunction agent(opts) {\n    const httpAgent = new http.Agent(opts), httpsAgent = new https.Agent(opts), agents = {\n        http: httpAgent,\n        https: httpsAgent\n    };\n    return {\n        finalizeOptions: (options)=>{\n            if (options.agent) return options;\n            if (options.maxRedirects > 0) return {\n                ...options,\n                agents\n            };\n            const isHttps = isHttpsProto.test(options.href || options.protocol);\n            return {\n                ...options,\n                agent: isHttps ? httpsAgent : httpAgent\n            };\n        }\n    };\n}\nconst leadingSlash = /^\\//, trailingSlash = /\\/$/;\nfunction base(baseUrl) {\n    const baseUri = baseUrl.replace(trailingSlash, \"\");\n    return {\n        processOptions: (options)=>{\n            if (/^https?:\\/\\//i.test(options.url)) return options;\n            const url = [\n                baseUri,\n                options.url.replace(leadingSlash, \"\")\n            ].join(\"/\");\n            return Object.assign({}, options, {\n                url\n            });\n        }\n    };\n}\nconst SENSITIVE_HEADERS = [\n    \"cookie\",\n    \"authorization\"\n], hasOwn = Object.prototype.hasOwnProperty, redactKeys = (source, redacted)=>{\n    const target = {};\n    for(const key in source)hasOwn.call(source, key) && (target[key] = redacted.indexOf(key.toLowerCase()) > -1 ? \"<redacted>\" : source[key]);\n    return target;\n};\nfunction debug(opts = {}) {\n    const verbose = opts.verbose, namespace = opts.namespace || \"get-it\", defaultLogger = debugIt__default.default(namespace), log = opts.log || defaultLogger, shortCircuit = log === defaultLogger && !debugIt__default.default.enabled(namespace);\n    let requestId = 0;\n    return {\n        processOptions: (options)=>(options.debug = log, options.requestId = options.requestId || ++requestId, options),\n        onRequest: (event)=>{\n            if (shortCircuit || !event) return event;\n            const options = event.options;\n            if (log(\"[%s] HTTP %s %s\", options.requestId, options.method, options.url), verbose && options.body && typeof options.body == \"string\" && log(\"[%s] Request body: %s\", options.requestId, options.body), verbose && options.headers) {\n                const headers2 = opts.redactSensitiveHeaders === !1 ? options.headers : redactKeys(options.headers, SENSITIVE_HEADERS);\n                log(\"[%s] Request headers: %s\", options.requestId, JSON.stringify(headers2, null, 2));\n            }\n            return event;\n        },\n        onResponse: (res, context)=>{\n            if (shortCircuit || !res) return res;\n            const reqId = context.options.requestId;\n            return log(\"[%s] Response code: %s %s\", reqId, res.statusCode, res.statusMessage), verbose && res.body && log(\"[%s] Response body: %s\", reqId, stringifyBody(res)), res;\n        },\n        onError: (err, context)=>{\n            const reqId = context.options.requestId;\n            return err ? (log(\"[%s] ERROR: %s\", reqId, err.message), err) : (log(\"[%s] Error encountered, but handled by an earlier middleware\", reqId), err);\n        }\n    };\n}\nfunction stringifyBody(res) {\n    return (res.headers[\"content-type\"] || \"\").toLowerCase().indexOf(\"application/json\") !== -1 ? tryFormat(res.body) : res.body;\n}\nfunction tryFormat(body) {\n    try {\n        const parsed = typeof body == \"string\" ? JSON.parse(body) : body;\n        return JSON.stringify(parsed, null, 2);\n    } catch  {\n        return body;\n    }\n}\nfunction headers(_headers, opts = {}) {\n    return {\n        processOptions: (options)=>{\n            const existing = options.headers || {};\n            return options.headers = opts.override ? Object.assign({}, existing, _headers) : Object.assign({}, _headers, existing), options;\n        }\n    };\n}\nclass HttpError extends Error {\n    constructor(res, ctx){\n        super();\n        const truncatedUrl = res.url.length > 400 ? `${res.url.slice(0, 399)}\\u2026` : res.url;\n        let msg = `${res.method}-request to ${truncatedUrl} resulted in `;\n        msg += `HTTP ${res.statusCode} ${res.statusMessage}`, this.message = msg.trim(), this.response = res, this.request = ctx.options;\n    }\n}\nfunction httpErrors() {\n    return {\n        onResponse: (res, ctx)=>{\n            if (!(res.statusCode >= 400)) return res;\n            throw new HttpError(res, ctx);\n        }\n    };\n}\nfunction injectResponse(opts = {}) {\n    if (typeof opts.inject != \"function\") throw new Error(\"`injectResponse` middleware requires a `inject` function\");\n    return {\n        interceptRequest: function(prevValue, event) {\n            const response = opts.inject(event, prevValue);\n            if (!response) return prevValue;\n            const options = event.context.options;\n            return {\n                body: \"\",\n                url: options.url,\n                method: options.method,\n                headers: {},\n                statusCode: 200,\n                statusMessage: \"OK\",\n                ...response\n            };\n        }\n    };\n}\nconst isBuffer = typeof Buffer > \"u\" ? ()=>!1 : (obj)=>Buffer.isBuffer(obj), serializeTypes = [\n    \"boolean\",\n    \"string\",\n    \"number\"\n];\nfunction jsonRequest() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            return !body || !(typeof body.pipe != \"function\" && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || isPlainObject.isPlainObject(body))) ? options : Object.assign({}, options, {\n                body: JSON.stringify(options.body),\n                headers: Object.assign({}, options.headers, {\n                    \"Content-Type\": \"application/json\"\n                })\n            });\n        }\n    };\n}\nfunction jsonResponse(opts) {\n    return {\n        onResponse: (response)=>{\n            const contentType = response.headers[\"content-type\"] || \"\", shouldDecode = opts && opts.force || contentType.indexOf(\"application/json\") !== -1;\n            return !response.body || !contentType || !shouldDecode ? response : Object.assign({}, response, {\n                body: tryParse(response.body)\n            });\n        },\n        processOptions: (options)=>Object.assign({}, options, {\n                headers: Object.assign({\n                    Accept: \"application/json\"\n                }, options.headers)\n            })\n    };\n    function tryParse(body) {\n        try {\n            return JSON.parse(body);\n        } catch (err) {\n            throw err.message = `Failed to parsed response body as JSON: ${err.message}`, err;\n        }\n    }\n}\nfunction isBrowserOptions(options) {\n    return typeof options == \"object\" && options !== null && !(\"protocol\" in options);\n}\nfunction mtls(config = {}) {\n    if (!config.ca) throw new Error('Required mtls option \"ca\" is missing');\n    if (!config.cert) throw new Error('Required mtls option \"cert\" is missing');\n    if (!config.key) throw new Error('Required mtls option \"key\" is missing');\n    return {\n        finalizeOptions: (options)=>{\n            if (isBrowserOptions(options)) return options;\n            const mtlsOpts = {\n                cert: config.cert,\n                key: config.key,\n                ca: config.ca\n            };\n            return Object.assign({}, options, mtlsOpts);\n        }\n    };\n}\nlet actualGlobal = {};\ntypeof globalThis < \"u\" ? actualGlobal = globalThis :  false ? 0 : typeof global < \"u\" ? actualGlobal = global : typeof self < \"u\" && (actualGlobal = self);\nvar global$1 = actualGlobal;\nfunction observable(opts = {}) {\n    const Observable = // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track\n    opts.implementation || global$1.Observable;\n    if (!Observable) throw new Error(\"`Observable` is not available in global scope, and no implementation was passed\");\n    return {\n        onReturn: (channels, context)=>new Observable((observer)=>(channels.error.subscribe((err)=>observer.error(err)), channels.progress.subscribe((event)=>observer.next(Object.assign({\n                        type: \"progress\"\n                    }, event))), channels.response.subscribe((response)=>{\n                    observer.next(Object.assign({\n                        type: \"response\"\n                    }, response)), observer.complete();\n                }), channels.request.publish(context), ()=>channels.abort.publish()))\n    };\n}\nfunction normalizer(stage) {\n    return (prog)=>({\n            stage,\n            percent: prog.percentage,\n            total: prog.length,\n            loaded: prog.transferred,\n            lengthComputable: !(prog.length === 0 && prog.percentage === 0)\n        });\n}\nfunction progress() {\n    return {\n        onHeaders: (response, evt)=>{\n            const _progress = progressStream__default.default({\n                time: 16\n            }), normalize = normalizer(\"download\"), contentLength = response.headers[\"content-length\"], length = contentLength ? Number(contentLength) : 0;\n            return !isNaN(length) && length > 0 && _progress.setLength(length), _progress.on(\"progress\", (prog)=>evt.context.channels.progress.publish(normalize(prog))), response.pipe(_progress);\n        },\n        onRequest: (evt)=>{\n            if (!evt.progress) return;\n            const normalize = normalizer(\"upload\");\n            evt.progress.on(\"progress\", (prog)=>evt.context.channels.progress.publish(normalize(prog)));\n        }\n    };\n}\nconst promise = (options = {})=>{\n    const PromiseImplementation = options.implementation || Promise;\n    if (!PromiseImplementation) throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n    return {\n        onReturn: (channels, context)=>new PromiseImplementation((resolve, reject)=>{\n                const cancel = context.options.cancelToken;\n                cancel && cancel.promise.then((reason)=>{\n                    channels.abort.publish(reason), reject(reason);\n                }), channels.error.subscribe(reject), channels.response.subscribe((response)=>{\n                    resolve(options.onlyBody ? response.body : response);\n                }), setTimeout(()=>{\n                    try {\n                        channels.request.publish(context);\n                    } catch (err) {\n                        reject(err);\n                    }\n                }, 0);\n            })\n    };\n};\nclass Cancel {\n    constructor(message){\n        this.__CANCEL__ = !0, this.message = message;\n    }\n    toString() {\n        return `Cancel${this.message ? `: ${this.message}` : \"\"}`;\n    }\n}\nconst _CancelToken = class {\n    constructor(executor){\n        if (typeof executor != \"function\") throw new TypeError(\"executor must be a function.\");\n        let resolvePromise = null;\n        this.promise = new Promise((resolve)=>{\n            resolvePromise = resolve;\n        }), executor((message)=>{\n            this.reason || (this.reason = new Cancel(message), resolvePromise(this.reason));\n        });\n    }\n};\n_CancelToken.source = ()=>{\n    let cancel;\n    return {\n        token: new _CancelToken((can)=>{\n            cancel = can;\n        }),\n        cancel\n    };\n};\nlet CancelToken = _CancelToken;\nconst isCancel = (value)=>!!(value && value != null && value.__CANCEL__);\npromise.Cancel = Cancel;\npromise.CancelToken = CancelToken;\npromise.isCancel = isCancel;\nfunction proxy(_proxy) {\n    if (_proxy !== !1 && (!_proxy || !_proxy.host)) throw new Error(\"Proxy middleware takes an object of host, port and auth properties\");\n    return {\n        processOptions: (options)=>Object.assign({\n                proxy: _proxy\n            }, options)\n    };\n}\nvar defaultShouldRetry = (err, num, options)=>options.method !== \"GET\" && options.method !== \"HEAD\" || err.response && err.response.statusCode ? !1 : allowed__default.default(err);\nconst isStream = (stream)=>stream !== null && typeof stream == \"object\" && typeof stream.pipe == \"function\";\nvar sharedRetry = (opts)=>{\n    const maxRetries = opts.maxRetries || 5, retryDelay = opts.retryDelay || getRetryDelay, allowRetry = opts.shouldRetry;\n    return {\n        onError: (err, context)=>{\n            const options = context.options, max = options.maxRetries || maxRetries, shouldRetry = options.shouldRetry || allowRetry, attemptNumber = options.attemptNumber || 0;\n            if (isStream(options.body) || !shouldRetry(err, attemptNumber, options) || attemptNumber >= max) return err;\n            const newContext = Object.assign({}, context, {\n                options: Object.assign({}, options, {\n                    attemptNumber: attemptNumber + 1\n                })\n            });\n            return setTimeout(()=>context.channels.request.publish(newContext), retryDelay(attemptNumber)), null;\n        }\n    };\n};\nfunction getRetryDelay(attemptNum) {\n    return 100 * Math.pow(2, attemptNum) + Math.random() * 100;\n}\nconst retry = (opts = {})=>sharedRetry({\n        shouldRetry: defaultShouldRetry,\n        ...opts\n    });\nretry.shouldRetry = defaultShouldRetry;\nfunction encode(data) {\n    const query = new URLSearchParams(), nest = (name, _value)=>{\n        const value = _value instanceof Set ? Array.from(_value) : _value;\n        if (Array.isArray(value)) if (value.length) for(const index in value)nest(`${name}[${index}]`, value[index]);\n        else query.append(`${name}[]`, \"\");\n        else if (typeof value == \"object\" && value !== null) for (const [key, obj] of Object.entries(value))nest(`${name}[${key}]`, obj);\n        else query.append(name, value);\n    };\n    for (const [key, value] of Object.entries(data))nest(key, value);\n    return query.toString();\n}\nfunction urlEncoded() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            return !body || !(typeof body.pipe != \"function\" && !isBuffer(body) && isPlainObject.isPlainObject(body)) ? options : {\n                ...options,\n                body: encode(options.body),\n                headers: {\n                    ...options.headers,\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            };\n        }\n    };\n}\nfunction buildKeepAlive(agent2) {\n    return function(config = {}) {\n        const ms = config.ms || 1e3, maxFree = config.maxFree || 256;\n        return agent2({\n            keepAlive: !0,\n            keepAliveMsecs: ms,\n            maxFreeSockets: maxFree\n        });\n    };\n}\nconst keepAlive = buildKeepAlive(agent);\nexports.processOptions = defaultOptionsValidator.processOptions;\nexports.validateOptions = defaultOptionsValidator.validateOptions;\nexports.Cancel = Cancel;\nexports.CancelToken = CancelToken;\nexports.agent = agent;\nexports.base = base;\nexports.debug = debug;\nexports.headers = headers;\nexports.httpErrors = httpErrors;\nexports.injectResponse = injectResponse;\nexports.jsonRequest = jsonRequest;\nexports.jsonResponse = jsonResponse;\nexports.keepAlive = keepAlive;\nexports.mtls = mtls;\nexports.observable = observable;\nexports.progress = progress;\nexports.promise = promise;\nexports.proxy = proxy;\nexports.retry = retry;\nexports.urlEncoded = urlEncoded; //# sourceMappingURL=middleware.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU8sQ0FBQztBQUFFLENBQUMsRUFBQztBQUMzRCxJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyxrQkFBTSxHQUFHQyxRQUFRRCxtQkFBT0EsQ0FBQyxvQkFBTyxHQUFHRSxVQUFVRixtQkFBT0EsQ0FBQyxzREFBTyxHQUFHRywwQkFBMEJILG1CQUFPQSxDQUFDLHFJQUFnRCxHQUFHSSxnQkFBZ0JKLG1CQUFPQSxDQUFDLHFGQUFpQixHQUFHSyxpQkFBaUJMLG1CQUFPQSxDQUFDLHNFQUFpQixHQUFHTSxVQUFVTixtQkFBT0EsQ0FBQyx3RUFBa0I7QUFDcFMsU0FBU08sc0JBQXNCQyxDQUFDO0lBQzlCLE9BQU9BLEtBQUssT0FBT0EsS0FBSyxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRUMsU0FBU0Q7SUFBRTtBQUN4RTtBQUNBLElBQUlFLG1CQUFtQixhQUFhLEdBQUdILHNCQUFzQkwsVUFBVVMsMEJBQTBCLGFBQWEsR0FBR0osc0JBQXNCRixpQkFBaUJPLG1CQUFtQixhQUFhLEdBQUdMLHNCQUFzQkQ7QUFDak4sTUFBTU8sZUFBZTtBQUNyQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2pCLE1BQU1DLFlBQVksSUFBSWpCLEtBQUtrQixLQUFLLENBQUNGLE9BQU9HLGFBQWEsSUFBSWpCLE1BQU1nQixLQUFLLENBQUNGLE9BQU9JLFNBQVM7UUFBRXBCLE1BQU1pQjtRQUFXZixPQUFPaUI7SUFBVztJQUMxSCxPQUFPO1FBQ0xFLGlCQUFpQixDQUFDQztZQUNoQixJQUFJQSxRQUFRUCxLQUFLLEVBQ2YsT0FBT087WUFDVCxJQUFJQSxRQUFRQyxZQUFZLEdBQUcsR0FDekIsT0FBTztnQkFBRSxHQUFHRCxPQUFPO2dCQUFFRjtZQUFPO1lBQzlCLE1BQU1JLFVBQVVWLGFBQWFXLElBQUksQ0FBQ0gsUUFBUUksSUFBSSxJQUFJSixRQUFRSyxRQUFRO1lBQ2xFLE9BQU87Z0JBQUUsR0FBR0wsT0FBTztnQkFBRVAsT0FBT1MsVUFBVUwsYUFBYUY7WUFBVTtRQUMvRDtJQUNGO0FBQ0Y7QUFDQSxNQUFNVyxlQUFlLE9BQU9DLGdCQUFnQjtBQUM1QyxTQUFTQyxLQUFLQyxPQUFPO0lBQ25CLE1BQU1DLFVBQVVELFFBQVFFLE9BQU8sQ0FBQ0osZUFBZTtJQUMvQyxPQUFPO1FBQ0xLLGdCQUFnQixDQUFDWjtZQUNmLElBQUksZ0JBQWdCRyxJQUFJLENBQUNILFFBQVFhLEdBQUcsR0FDbEMsT0FBT2I7WUFDVCxNQUFNYSxNQUFNO2dCQUFDSDtnQkFBU1YsUUFBUWEsR0FBRyxDQUFDRixPQUFPLENBQUNMLGNBQWM7YUFBSSxDQUFDUSxJQUFJLENBQUM7WUFDbEUsT0FBT3hDLE9BQU95QyxNQUFNLENBQUMsQ0FBQyxHQUFHZixTQUFTO2dCQUFFYTtZQUFJO1FBQzFDO0lBQ0Y7QUFDRjtBQUNBLE1BQU1HLG9CQUFvQjtJQUFDO0lBQVU7Q0FBZ0IsRUFBRUMsU0FBUzNDLE9BQU80QyxTQUFTLENBQUNDLGNBQWMsRUFBRUMsYUFBYSxDQUFDQyxRQUFRQztJQUNySCxNQUFNQyxTQUFTLENBQUM7SUFDaEIsSUFBSyxNQUFNQyxPQUFPSCxPQUNoQkosT0FBT1EsSUFBSSxDQUFDSixRQUFRRyxRQUFTRCxDQUFBQSxNQUFNLENBQUNDLElBQUksR0FBR0YsU0FBU0ksT0FBTyxDQUFDRixJQUFJRyxXQUFXLE1BQU0sQ0FBQyxJQUFJLGVBQWVOLE1BQU0sQ0FBQ0csSUFBSTtJQUNsSCxPQUFPRDtBQUNUO0FBQ0EsU0FBU0ssTUFBTWxDLE9BQU8sQ0FBQyxDQUFDO0lBQ3RCLE1BQU1tQyxVQUFVbkMsS0FBS21DLE9BQU8sRUFBRUMsWUFBWXBDLEtBQUtvQyxTQUFTLElBQUksVUFBVUMsZ0JBQWdCMUMsaUJBQWlCRCxPQUFPLENBQUMwQyxZQUFZRSxNQUFNdEMsS0FBS3NDLEdBQUcsSUFBSUQsZUFBZUUsZUFBZUQsUUFBUUQsaUJBQWlCLENBQUMxQyxpQkFBaUJELE9BQU8sQ0FBQzhDLE9BQU8sQ0FBQ0o7SUFDdE8sSUFBSUssWUFBWTtJQUNoQixPQUFPO1FBQ0x2QixnQkFBZ0IsQ0FBQ1osVUFBYUEsQ0FBQUEsUUFBUTRCLEtBQUssR0FBR0ksS0FBS2hDLFFBQVFtQyxTQUFTLEdBQUduQyxRQUFRbUMsU0FBUyxJQUFJLEVBQUVBLFdBQVduQyxPQUFNO1FBQy9Hb0MsV0FBVyxDQUFDQztZQUNWLElBQUlKLGdCQUFnQixDQUFDSSxPQUNuQixPQUFPQTtZQUNULE1BQU1yQyxVQUFVcUMsTUFBTXJDLE9BQU87WUFDN0IsSUFBSWdDLElBQUksbUJBQW1CaEMsUUFBUW1DLFNBQVMsRUFBRW5DLFFBQVFzQyxNQUFNLEVBQUV0QyxRQUFRYSxHQUFHLEdBQUdnQixXQUFXN0IsUUFBUXVDLElBQUksSUFBSSxPQUFPdkMsUUFBUXVDLElBQUksSUFBSSxZQUFZUCxJQUFJLHlCQUF5QmhDLFFBQVFtQyxTQUFTLEVBQUVuQyxRQUFRdUMsSUFBSSxHQUFHVixXQUFXN0IsUUFBUXdDLE9BQU8sRUFBRTtnQkFDbk8sTUFBTUMsV0FBVy9DLEtBQUtnRCxzQkFBc0IsS0FBSyxDQUFDLElBQUkxQyxRQUFRd0MsT0FBTyxHQUFHcEIsV0FBV3BCLFFBQVF3QyxPQUFPLEVBQUV4QjtnQkFDcEdnQixJQUFJLDRCQUE0QmhDLFFBQVFtQyxTQUFTLEVBQUVRLEtBQUtDLFNBQVMsQ0FBQ0gsVUFBVSxNQUFNO1lBQ3BGO1lBQ0EsT0FBT0o7UUFDVDtRQUNBUSxZQUFZLENBQUNDLEtBQUtDO1lBQ2hCLElBQUlkLGdCQUFnQixDQUFDYSxLQUNuQixPQUFPQTtZQUNULE1BQU1FLFFBQVFELFFBQVEvQyxPQUFPLENBQUNtQyxTQUFTO1lBQ3ZDLE9BQU9ILElBQUksNkJBQTZCZ0IsT0FBT0YsSUFBSUcsVUFBVSxFQUFFSCxJQUFJSSxhQUFhLEdBQUdyQixXQUFXaUIsSUFBSVAsSUFBSSxJQUFJUCxJQUFJLDBCQUEwQmdCLE9BQU9HLGNBQWNMLE9BQU9BO1FBQ3RLO1FBQ0FNLFNBQVMsQ0FBQ0MsS0FBS047WUFDYixNQUFNQyxRQUFRRCxRQUFRL0MsT0FBTyxDQUFDbUMsU0FBUztZQUN2QyxPQUFPa0IsTUFBT3JCLENBQUFBLElBQUksa0JBQWtCZ0IsT0FBT0ssSUFBSUMsT0FBTyxHQUFHRCxHQUFFLElBQU1yQixDQUFBQSxJQUFJLGdFQUFnRWdCLFFBQVFLLEdBQUU7UUFDako7SUFDRjtBQUNGO0FBQ0EsU0FBU0YsY0FBY0wsR0FBRztJQUN4QixPQUFPLENBQUNBLElBQUlOLE9BQU8sQ0FBQyxlQUFlLElBQUksRUFBQyxFQUFHYixXQUFXLEdBQUdELE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJNkIsVUFBVVQsSUFBSVAsSUFBSSxJQUFJTyxJQUFJUCxJQUFJO0FBQzlIO0FBQ0EsU0FBU2dCLFVBQVVoQixJQUFJO0lBQ3JCLElBQUk7UUFDRixNQUFNaUIsU0FBUyxPQUFPakIsUUFBUSxXQUFXSSxLQUFLYyxLQUFLLENBQUNsQixRQUFRQTtRQUM1RCxPQUFPSSxLQUFLQyxTQUFTLENBQUNZLFFBQVEsTUFBTTtJQUN0QyxFQUFFLE9BQU07UUFDTixPQUFPakI7SUFDVDtBQUNGO0FBQ0EsU0FBU0MsUUFBUWtCLFFBQVEsRUFBRWhFLE9BQU8sQ0FBQyxDQUFDO0lBQ2xDLE9BQU87UUFDTGtCLGdCQUFnQixDQUFDWjtZQUNmLE1BQU0yRCxXQUFXM0QsUUFBUXdDLE9BQU8sSUFBSSxDQUFDO1lBQ3JDLE9BQU94QyxRQUFRd0MsT0FBTyxHQUFHOUMsS0FBS2tFLFFBQVEsR0FBR3RGLE9BQU95QyxNQUFNLENBQUMsQ0FBQyxHQUFHNEMsVUFBVUQsWUFBWXBGLE9BQU95QyxNQUFNLENBQUMsQ0FBQyxHQUFHMkMsVUFBVUMsV0FBVzNEO1FBQzFIO0lBQ0Y7QUFDRjtBQUNBLE1BQU02RCxrQkFBa0JDO0lBQ3RCQyxZQUFZakIsR0FBRyxFQUFFa0IsR0FBRyxDQUFFO1FBQ3BCLEtBQUs7UUFDTCxNQUFNQyxlQUFlbkIsSUFBSWpDLEdBQUcsQ0FBQ3FELE1BQU0sR0FBRyxNQUFNLENBQUMsRUFBRXBCLElBQUlqQyxHQUFHLENBQUNzRCxLQUFLLENBQUMsR0FBRyxLQUFLLE1BQU0sQ0FBQyxHQUFHckIsSUFBSWpDLEdBQUc7UUFDdEYsSUFBSXVELE1BQU0sQ0FBQyxFQUFFdEIsSUFBSVIsTUFBTSxDQUFDLFlBQVksRUFBRTJCLGFBQWEsYUFBYSxDQUFDO1FBQ2pFRyxPQUFPLENBQUMsS0FBSyxFQUFFdEIsSUFBSUcsVUFBVSxDQUFDLENBQUMsRUFBRUgsSUFBSUksYUFBYSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNJLE9BQU8sR0FBR2MsSUFBSUMsSUFBSSxJQUFJLElBQUksQ0FBQ0MsUUFBUSxHQUFHeEIsS0FBSyxJQUFJLENBQUN5QixPQUFPLEdBQUdQLElBQUloRSxPQUFPO0lBQ2xJO0FBQ0Y7QUFDQSxTQUFTd0U7SUFDUCxPQUFPO1FBQ0wzQixZQUFZLENBQUNDLEtBQUtrQjtZQUNoQixJQUFJLENBQUVsQixDQUFBQSxJQUFJRyxVQUFVLElBQUksR0FBRSxHQUN4QixPQUFPSDtZQUNULE1BQU0sSUFBSWUsVUFBVWYsS0FBS2tCO1FBQzNCO0lBQ0Y7QUFDRjtBQUNBLFNBQVNTLGVBQWUvRSxPQUFPLENBQUMsQ0FBQztJQUMvQixJQUFJLE9BQU9BLEtBQUtnRixNQUFNLElBQUksWUFDeEIsTUFBTSxJQUFJWixNQUFNO0lBQ2xCLE9BQU87UUFBRWEsa0JBQWtCLFNBQVNDLFNBQVMsRUFBRXZDLEtBQUs7WUFDbEQsTUFBTWlDLFdBQVc1RSxLQUFLZ0YsTUFBTSxDQUFDckMsT0FBT3VDO1lBQ3BDLElBQUksQ0FBQ04sVUFDSCxPQUFPTTtZQUNULE1BQU01RSxVQUFVcUMsTUFBTVUsT0FBTyxDQUFDL0MsT0FBTztZQUNyQyxPQUFPO2dCQUNMdUMsTUFBTTtnQkFDTjFCLEtBQUtiLFFBQVFhLEdBQUc7Z0JBQ2hCeUIsUUFBUXRDLFFBQVFzQyxNQUFNO2dCQUN0QkUsU0FBUyxDQUFDO2dCQUNWUyxZQUFZO2dCQUNaQyxlQUFlO2dCQUNmLEdBQUdvQixRQUFRO1lBQ2I7UUFDRjtJQUFFO0FBQ0o7QUFDQSxNQUFNTyxXQUFXLE9BQU9DLFNBQVMsTUFBTSxJQUFNLENBQUMsSUFBSSxDQUFDQyxNQUFRRCxPQUFPRCxRQUFRLENBQUNFLE1BQU1DLGlCQUFpQjtJQUFDO0lBQVc7SUFBVTtDQUFTO0FBQ2pJLFNBQVNDO0lBQ1AsT0FBTztRQUNMckUsZ0JBQWdCLENBQUNaO1lBQ2YsTUFBTXVDLE9BQU92QyxRQUFRdUMsSUFBSTtZQUN6QixPQUFPLENBQUNBLFFBQVEsQ0FBRSxRQUFPQSxLQUFLMkMsSUFBSSxJQUFJLGNBQWMsQ0FBQ0wsU0FBU3RDLFNBQVV5QyxDQUFBQSxlQUFldEQsT0FBTyxDQUFDLE9BQU9hLFVBQVUsQ0FBQyxLQUFLNEMsTUFBTUMsT0FBTyxDQUFDN0MsU0FBU3hELGNBQWNBLGFBQWEsQ0FBQ3dELEtBQUksQ0FBQyxJQUFLdkMsVUFBVTFCLE9BQU95QyxNQUFNLENBQUMsQ0FBQyxHQUFHZixTQUFTO2dCQUN0TnVDLE1BQU1JLEtBQUtDLFNBQVMsQ0FBQzVDLFFBQVF1QyxJQUFJO2dCQUNqQ0MsU0FBU2xFLE9BQU95QyxNQUFNLENBQUMsQ0FBQyxHQUFHZixRQUFRd0MsT0FBTyxFQUFFO29CQUMxQyxnQkFBZ0I7Z0JBQ2xCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTNkMsYUFBYTNGLElBQUk7SUFDeEIsT0FBTztRQUNMbUQsWUFBWSxDQUFDeUI7WUFDWCxNQUFNZ0IsY0FBY2hCLFNBQVM5QixPQUFPLENBQUMsZUFBZSxJQUFJLElBQUkrQyxlQUFlN0YsUUFBUUEsS0FBSzhGLEtBQUssSUFBSUYsWUFBWTVELE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQztZQUM5SSxPQUFPLENBQUM0QyxTQUFTL0IsSUFBSSxJQUFJLENBQUMrQyxlQUFlLENBQUNDLGVBQWVqQixXQUFXaEcsT0FBT3lDLE1BQU0sQ0FBQyxDQUFDLEdBQUd1RCxVQUFVO2dCQUFFL0IsTUFBTWtELFNBQVNuQixTQUFTL0IsSUFBSTtZQUFFO1FBQ2xJO1FBQ0EzQixnQkFBZ0IsQ0FBQ1osVUFBWTFCLE9BQU95QyxNQUFNLENBQUMsQ0FBQyxHQUFHZixTQUFTO2dCQUN0RHdDLFNBQVNsRSxPQUFPeUMsTUFBTSxDQUFDO29CQUFFMkUsUUFBUTtnQkFBbUIsR0FBRzFGLFFBQVF3QyxPQUFPO1lBQ3hFO0lBQ0Y7SUFDQSxTQUFTaUQsU0FBU2xELElBQUk7UUFDcEIsSUFBSTtZQUNGLE9BQU9JLEtBQUtjLEtBQUssQ0FBQ2xCO1FBQ3BCLEVBQUUsT0FBT2MsS0FBSztZQUNaLE1BQU1BLElBQUlDLE9BQU8sR0FBRyxDQUFDLHdDQUF3QyxFQUFFRCxJQUFJQyxPQUFPLENBQUMsQ0FBQyxFQUFFRDtRQUNoRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTc0MsaUJBQWlCM0YsT0FBTztJQUMvQixPQUFPLE9BQU9BLFdBQVcsWUFBWUEsWUFBWSxRQUFRLENBQUUsZUFBY0EsT0FBTTtBQUNqRjtBQUNBLFNBQVM0RixLQUFLQyxTQUFTLENBQUMsQ0FBQztJQUN2QixJQUFJLENBQUNBLE9BQU9DLEVBQUUsRUFDWixNQUFNLElBQUloQyxNQUFNO0lBQ2xCLElBQUksQ0FBQytCLE9BQU9FLElBQUksRUFDZCxNQUFNLElBQUlqQyxNQUFNO0lBQ2xCLElBQUksQ0FBQytCLE9BQU9yRSxHQUFHLEVBQ2IsTUFBTSxJQUFJc0MsTUFBTTtJQUNsQixPQUFPO1FBQ0wvRCxpQkFBaUIsQ0FBQ0M7WUFDaEIsSUFBSTJGLGlCQUFpQjNGLFVBQ25CLE9BQU9BO1lBQ1QsTUFBTWdHLFdBQVc7Z0JBQ2ZELE1BQU1GLE9BQU9FLElBQUk7Z0JBQ2pCdkUsS0FBS3FFLE9BQU9yRSxHQUFHO2dCQUNmc0UsSUFBSUQsT0FBT0MsRUFBRTtZQUNmO1lBQ0EsT0FBT3hILE9BQU95QyxNQUFNLENBQUMsQ0FBQyxHQUFHZixTQUFTZ0c7UUFDcEM7SUFDRjtBQUNGO0FBQ0EsSUFBSUMsZUFBZSxDQUFDO0FBQ3BCLE9BQU9DLGFBQWEsTUFBTUQsZUFBZUMsYUFBYSxNQUFtQixHQUFHRCxDQUFxQkUsR0FBRyxPQUFPQyxTQUFTLE1BQU1ILGVBQWVHLFNBQVMsT0FBT0MsT0FBTyxPQUFRSixDQUFBQSxlQUFlSSxJQUFHO0FBQzFMLElBQUlDLFdBQVdMO0FBQ2YsU0FBU00sV0FBVzdHLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLE1BQU04RyxhQUNKLDhKQUE4SjtJQUM5SjlHLEtBQUsrRyxjQUFjLElBQUlILFNBQVNFLFVBQVU7SUFFNUMsSUFBSSxDQUFDQSxZQUNILE1BQU0sSUFBSTFDLE1BQ1I7SUFFSixPQUFPO1FBQ0w0QyxVQUFVLENBQUNDLFVBQVU1RCxVQUFZLElBQUl5RCxXQUFXLENBQUNJLFdBQWNELENBQUFBLFNBQVNFLEtBQUssQ0FBQ0MsU0FBUyxDQUFDLENBQUN6RCxNQUFRdUQsU0FBU0MsS0FBSyxDQUFDeEQsT0FBT3NELFNBQVNJLFFBQVEsQ0FBQ0QsU0FBUyxDQUNoSixDQUFDekUsUUFBVXVFLFNBQVNJLElBQUksQ0FBQzFJLE9BQU95QyxNQUFNLENBQUM7d0JBQUVrRyxNQUFNO29CQUFXLEdBQUc1RSxVQUM1RHNFLFNBQVNyQyxRQUFRLENBQUN3QyxTQUFTLENBQUMsQ0FBQ3hDO29CQUM5QnNDLFNBQVNJLElBQUksQ0FBQzFJLE9BQU95QyxNQUFNLENBQUM7d0JBQUVrRyxNQUFNO29CQUFXLEdBQUczQyxZQUFZc0MsU0FBU00sUUFBUTtnQkFDakYsSUFBSVAsU0FBU3BDLE9BQU8sQ0FBQzRDLE9BQU8sQ0FBQ3BFLFVBQVUsSUFBTTRELFNBQVNTLEtBQUssQ0FBQ0QsT0FBTyxFQUFDO0lBQ3RFO0FBQ0Y7QUFDQSxTQUFTRSxXQUFXQyxLQUFLO0lBQ3ZCLE9BQU8sQ0FBQ0MsT0FBVTtZQUNoQkQ7WUFDQUUsU0FBU0QsS0FBS0UsVUFBVTtZQUN4QkMsT0FBT0gsS0FBS3JELE1BQU07WUFDbEJ5RCxRQUFRSixLQUFLSyxXQUFXO1lBQ3hCQyxrQkFBa0IsQ0FBRU4sQ0FBQUEsS0FBS3JELE1BQU0sS0FBSyxLQUFLcUQsS0FBS0UsVUFBVSxLQUFLO1FBQy9EO0FBQ0Y7QUFDQSxTQUFTVjtJQUNQLE9BQU87UUFDTGUsV0FBVyxDQUFDeEQsVUFBVXlEO1lBQ3BCLE1BQU1DLFlBQVkxSSx3QkFBd0JGLE9BQU8sQ0FBQztnQkFBRTZJLE1BQU07WUFBRyxJQUFJQyxZQUFZYixXQUFXLGFBQWFjLGdCQUFnQjdELFNBQVM5QixPQUFPLENBQUMsaUJBQWlCLEVBQUUwQixTQUFTaUUsZ0JBQWdCQyxPQUFPRCxpQkFBaUI7WUFDMU0sT0FBTyxDQUFDRSxNQUFNbkUsV0FBV0EsU0FBUyxLQUFLOEQsVUFBVU0sU0FBUyxDQUFDcEUsU0FBUzhELFVBQVVPLEVBQUUsQ0FBQyxZQUFZLENBQUNoQixPQUFTUSxJQUFJaEYsT0FBTyxDQUFDNEQsUUFBUSxDQUFDSSxRQUFRLENBQUNJLE9BQU8sQ0FBQ2UsVUFBVVgsU0FBU2pELFNBQVNZLElBQUksQ0FBQzhDO1FBQ2hMO1FBQ0E1RixXQUFXLENBQUMyRjtZQUNWLElBQUksQ0FBQ0EsSUFBSWhCLFFBQVEsRUFDZjtZQUNGLE1BQU1tQixZQUFZYixXQUFXO1lBQzdCVSxJQUFJaEIsUUFBUSxDQUFDd0IsRUFBRSxDQUNiLFlBQ0EsQ0FBQ2hCLE9BQVNRLElBQUloRixPQUFPLENBQUM0RCxRQUFRLENBQUNJLFFBQVEsQ0FBQ0ksT0FBTyxDQUFDZSxVQUFVWDtRQUU5RDtJQUNGO0FBQ0Y7QUFDQSxNQUFNaUIsVUFBVSxDQUFDeEksVUFBVSxDQUFDLENBQUM7SUFDM0IsTUFBTXlJLHdCQUF3QnpJLFFBQVF5RyxjQUFjLElBQUlpQztJQUN4RCxJQUFJLENBQUNELHVCQUNILE1BQU0sSUFBSTNFLE1BQU07SUFDbEIsT0FBTztRQUNMNEMsVUFBVSxDQUFDQyxVQUFVNUQsVUFBWSxJQUFJMEYsc0JBQXNCLENBQUNFLFNBQVNDO2dCQUNuRSxNQUFNQyxTQUFTOUYsUUFBUS9DLE9BQU8sQ0FBQzhJLFdBQVc7Z0JBQzFDRCxVQUFVQSxPQUFPTCxPQUFPLENBQUNPLElBQUksQ0FBQyxDQUFDQztvQkFDN0JyQyxTQUFTUyxLQUFLLENBQUNELE9BQU8sQ0FBQzZCLFNBQVNKLE9BQU9JO2dCQUN6QyxJQUFJckMsU0FBU0UsS0FBSyxDQUFDQyxTQUFTLENBQUM4QixTQUFTakMsU0FBU3JDLFFBQVEsQ0FBQ3dDLFNBQVMsQ0FBQyxDQUFDeEM7b0JBQ2pFcUUsUUFBUTNJLFFBQVFpSixRQUFRLEdBQUczRSxTQUFTL0IsSUFBSSxHQUFHK0I7Z0JBQzdDLElBQUk0RSxXQUFXO29CQUNiLElBQUk7d0JBQ0Z2QyxTQUFTcEMsT0FBTyxDQUFDNEMsT0FBTyxDQUFDcEU7b0JBQzNCLEVBQUUsT0FBT00sS0FBSzt3QkFDWnVGLE9BQU92RjtvQkFDVDtnQkFDRixHQUFHO1lBQ0w7SUFDRjtBQUNGO0FBQ0EsTUFBTThGO0lBQ0pwRixZQUFZVCxPQUFPLENBQUU7UUFDbkIsSUFBSSxDQUFDOEYsVUFBVSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM5RixPQUFPLEdBQUdBO0lBQ3ZDO0lBQ0ErRixXQUFXO1FBQ1QsT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMvRixPQUFPLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDQSxPQUFPLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUMzRDtBQUNGO0FBQ0EsTUFBTWdHLGVBQWU7SUFDbkJ2RixZQUFZd0YsUUFBUSxDQUFFO1FBQ3BCLElBQUksT0FBT0EsWUFBWSxZQUNyQixNQUFNLElBQUlDLFVBQVU7UUFDdEIsSUFBSUMsaUJBQWlCO1FBQ3JCLElBQUksQ0FBQ2pCLE9BQU8sR0FBRyxJQUFJRSxRQUFRLENBQUNDO1lBQzFCYyxpQkFBaUJkO1FBQ25CLElBQUlZLFNBQVMsQ0FBQ2pHO1lBQ1osSUFBSSxDQUFDMEYsTUFBTSxJQUFLLEtBQUksQ0FBQ0EsTUFBTSxHQUFHLElBQUlHLE9BQU83RixVQUFVbUcsZUFBZSxJQUFJLENBQUNULE1BQU07UUFDL0U7SUFDRjtBQUNGO0FBQ0FNLGFBQWFqSSxNQUFNLEdBQUc7SUFDcEIsSUFBSXdIO0lBQ0osT0FBTztRQUNMYSxPQUFPLElBQUlKLGFBQWEsQ0FBQ0s7WUFDdkJkLFNBQVNjO1FBQ1g7UUFDQWQ7SUFDRjtBQUNGO0FBQ0EsSUFBSWUsY0FBY047QUFDbEIsTUFBTU8sV0FBVyxDQUFDcEwsUUFBVSxDQUFDLENBQUVBLENBQUFBLFNBQVNBLFNBQVMsUUFBUUEsTUFBTTJLLFVBQVU7QUFDekVaLFFBQVFXLE1BQU0sR0FBR0E7QUFDakJYLFFBQVFvQixXQUFXLEdBQUdBO0FBQ3RCcEIsUUFBUXFCLFFBQVEsR0FBR0E7QUFDbkIsU0FBU0MsTUFBTUMsTUFBTTtJQUNuQixJQUFJQSxXQUFXLENBQUMsS0FBTSxFQUFDQSxVQUFVLENBQUNBLE9BQU9DLElBQUksR0FDM0MsTUFBTSxJQUFJbEcsTUFBTTtJQUNsQixPQUFPO1FBQ0xsRCxnQkFBZ0IsQ0FBQ1osVUFBWTFCLE9BQU95QyxNQUFNLENBQUM7Z0JBQUUrSSxPQUFPQztZQUFPLEdBQUcvSjtJQUNoRTtBQUNGO0FBQ0EsSUFBSWlLLHFCQUFxQixDQUFDNUcsS0FBSzZHLEtBQUtsSyxVQUFZQSxRQUFRc0MsTUFBTSxLQUFLLFNBQVN0QyxRQUFRc0MsTUFBTSxLQUFLLFVBQVVlLElBQUlpQixRQUFRLElBQUlqQixJQUFJaUIsUUFBUSxDQUFDckIsVUFBVSxHQUFHLENBQUMsSUFBSTFELGlCQUFpQkgsT0FBTyxDQUFDaUU7QUFDakwsTUFBTThHLFdBQVcsQ0FBQ0MsU0FBV0EsV0FBVyxRQUFRLE9BQU9BLFVBQVUsWUFBWSxPQUFPQSxPQUFPbEYsSUFBSSxJQUFJO0FBQ25HLElBQUltRixjQUFjLENBQUMzSztJQUNqQixNQUFNNEssYUFBYTVLLEtBQUs0SyxVQUFVLElBQUksR0FBR0MsYUFBYTdLLEtBQUs2SyxVQUFVLElBQUlDLGVBQWVDLGFBQWEvSyxLQUFLZ0wsV0FBVztJQUNySCxPQUFPO1FBQ0x0SCxTQUFTLENBQUNDLEtBQUtOO1lBQ2IsTUFBTS9DLFVBQVUrQyxRQUFRL0MsT0FBTyxFQUFFMkssTUFBTTNLLFFBQVFzSyxVQUFVLElBQUlBLFlBQVlJLGNBQWMxSyxRQUFRMEssV0FBVyxJQUFJRCxZQUFZRyxnQkFBZ0I1SyxRQUFRNEssYUFBYSxJQUFJO1lBQ25LLElBQUlULFNBQVNuSyxRQUFRdUMsSUFBSSxLQUFLLENBQUNtSSxZQUFZckgsS0FBS3VILGVBQWU1SyxZQUFZNEssaUJBQWlCRCxLQUMxRixPQUFPdEg7WUFDVCxNQUFNd0gsYUFBYXZNLE9BQU95QyxNQUFNLENBQUMsQ0FBQyxHQUFHZ0MsU0FBUztnQkFDNUMvQyxTQUFTMUIsT0FBT3lDLE1BQU0sQ0FBQyxDQUFDLEdBQUdmLFNBQVM7b0JBQUU0SyxlQUFlQSxnQkFBZ0I7Z0JBQUU7WUFDekU7WUFDQSxPQUFPMUIsV0FBVyxJQUFNbkcsUUFBUTRELFFBQVEsQ0FBQ3BDLE9BQU8sQ0FBQzRDLE9BQU8sQ0FBQzBELGFBQWFOLFdBQVdLLGlCQUFpQjtRQUNwRztJQUNGO0FBQ0Y7QUFDQSxTQUFTSixjQUFjTSxVQUFVO0lBQy9CLE9BQU8sTUFBTUMsS0FBS0MsR0FBRyxDQUFDLEdBQUdGLGNBQWNDLEtBQUtFLE1BQU0sS0FBSztBQUN6RDtBQUNBLE1BQU1DLFFBQVEsQ0FBQ3hMLE9BQU8sQ0FBQyxDQUFDLEdBQUsySyxZQUFZO1FBQUVLLGFBQWFUO1FBQW9CLEdBQUd2SyxJQUFJO0lBQUM7QUFDcEZ3TCxNQUFNUixXQUFXLEdBQUdUO0FBQ3BCLFNBQVNrQixPQUFPQyxJQUFJO0lBQ2xCLE1BQU1DLFFBQVEsSUFBSUMsbUJBQW1CQyxPQUFPLENBQUNDLE1BQU1DO1FBQ2pELE1BQU1oTixRQUFRZ04sa0JBQWtCQyxNQUFNdkcsTUFBTXdHLElBQUksQ0FBQ0YsVUFBVUE7UUFDM0QsSUFBSXRHLE1BQU1DLE9BQU8sQ0FBQzNHLFFBQ2hCLElBQUlBLE1BQU15RixNQUFNLEVBQ2QsSUFBSyxNQUFNMEgsU0FBU25OLE1BQ2xCOE0sS0FBSyxDQUFDLEVBQUVDLEtBQUssQ0FBQyxFQUFFSSxNQUFNLENBQUMsQ0FBQyxFQUFFbk4sS0FBSyxDQUFDbU4sTUFBTTthQUV4Q1AsTUFBTVEsTUFBTSxDQUFDLENBQUMsRUFBRUwsS0FBSyxFQUFFLENBQUMsRUFBRTthQUN6QixJQUFJLE9BQU8vTSxTQUFTLFlBQVlBLFVBQVUsTUFDN0MsS0FBSyxNQUFNLENBQUMrQyxLQUFLdUQsSUFBSSxJQUFJekcsT0FBT3dOLE9BQU8sQ0FBQ3JOLE9BQ3RDOE0sS0FBSyxDQUFDLEVBQUVDLEtBQUssQ0FBQyxFQUFFaEssSUFBSSxDQUFDLENBQUMsRUFBRXVEO2FBRTFCc0csTUFBTVEsTUFBTSxDQUFDTCxNQUFNL007SUFDdkI7SUFDQSxLQUFLLE1BQU0sQ0FBQytDLEtBQUsvQyxNQUFNLElBQUlILE9BQU93TixPQUFPLENBQUNWLE1BQ3hDRyxLQUFLL0osS0FBSy9DO0lBQ1osT0FBTzRNLE1BQU1oQyxRQUFRO0FBQ3ZCO0FBQ0EsU0FBUzBDO0lBQ1AsT0FBTztRQUNMbkwsZ0JBQWdCLENBQUNaO1lBQ2YsTUFBTXVDLE9BQU92QyxRQUFRdUMsSUFBSTtZQUN6QixPQUFPLENBQUNBLFFBQVEsQ0FBRSxRQUFPQSxLQUFLMkMsSUFBSSxJQUFJLGNBQWMsQ0FBQ0wsU0FBU3RDLFNBQVN4RCxjQUFjQSxhQUFhLENBQUN3RCxLQUFJLElBQUt2QyxVQUFVO2dCQUNwSCxHQUFHQSxPQUFPO2dCQUNWdUMsTUFBTTRJLE9BQU9uTCxRQUFRdUMsSUFBSTtnQkFDekJDLFNBQVM7b0JBQ1AsR0FBR3hDLFFBQVF3QyxPQUFPO29CQUNsQixnQkFBZ0I7Z0JBQ2xCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTd0osZUFBZUMsTUFBTTtJQUM1QixPQUFPLFNBQVNwRyxTQUFTLENBQUMsQ0FBQztRQUN6QixNQUFNcUcsS0FBS3JHLE9BQU9xRyxFQUFFLElBQUksS0FBS0MsVUFBVXRHLE9BQU9zRyxPQUFPLElBQUk7UUFDekQsT0FBT0YsT0FBTztZQUNaRyxXQUFXLENBQUM7WUFDWkMsZ0JBQWdCSDtZQUNoQkksZ0JBQWdCSDtRQUNsQjtJQUNGO0FBQ0Y7QUFDQSxNQUFNQyxZQUFZSixlQUFldk07QUFDakNqQixzQkFBc0IsR0FBR00sd0JBQXdCOEIsY0FBYztBQUMvRHBDLHVCQUF1QixHQUFHTSx3QkFBd0J5TixlQUFlO0FBQ2pFL04sY0FBYyxHQUFHMks7QUFDakIzSyxtQkFBbUIsR0FBR29MO0FBQ3RCcEwsYUFBYSxHQUFHaUI7QUFDaEJqQixZQUFZLEdBQUdnQztBQUNmaEMsYUFBYSxHQUFHb0Q7QUFDaEJwRCxlQUFlLEdBQUdnRTtBQUNsQmhFLGtCQUFrQixHQUFHZ0c7QUFDckJoRyxzQkFBc0IsR0FBR2lHO0FBQ3pCakcsbUJBQW1CLEdBQUd5RztBQUN0QnpHLG9CQUFvQixHQUFHNkc7QUFDdkI3RyxpQkFBaUIsR0FBRzROO0FBQ3BCNU4sWUFBWSxHQUFHb0g7QUFDZnBILGtCQUFrQixHQUFHK0g7QUFDckIvSCxnQkFBZ0IsR0FBR3VJO0FBQ25CdkksZUFBZSxHQUFHZ0s7QUFDbEJoSyxhQUFhLEdBQUdzTDtBQUNoQnRMLGFBQWEsR0FBRzBNO0FBQ2hCMU0sa0JBQWtCLEdBQUd1TixZQUNyQix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5janM/MGVhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpLCBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKSwgZGVidWdJdCA9IHJlcXVpcmUoXCJkZWJ1Z1wiKSwgZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi9fY2h1bmtzL2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLUNYd3JOam1lLmNqc1wiKSwgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoXCJpcy1wbGFpbi1vYmplY3RcIiksIHByb2dyZXNzU3RyZWFtID0gcmVxdWlyZShcInByb2dyZXNzLXN0cmVhbVwiKSwgYWxsb3dlZCA9IHJlcXVpcmUoXCJpcy1yZXRyeS1hbGxvd2VkXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0Q29tcGF0KGUpIHtcbiAgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBcImRlZmF1bHRcIiBpbiBlID8gZSA6IHsgZGVmYXVsdDogZSB9O1xufVxudmFyIGRlYnVnSXRfX2RlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BEZWZhdWx0Q29tcGF0KGRlYnVnSXQpLCBwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyBfaW50ZXJvcERlZmF1bHRDb21wYXQocHJvZ3Jlc3NTdHJlYW0pLCBhbGxvd2VkX19kZWZhdWx0ID0gLyogQF9fUFVSRV9fICovIF9pbnRlcm9wRGVmYXVsdENvbXBhdChhbGxvd2VkKTtcbmNvbnN0IGlzSHR0cHNQcm90byA9IC9eaHR0cHM6L2k7XG5mdW5jdGlvbiBhZ2VudChvcHRzKSB7XG4gIGNvbnN0IGh0dHBBZ2VudCA9IG5ldyBodHRwLkFnZW50KG9wdHMpLCBodHRwc0FnZW50ID0gbmV3IGh0dHBzLkFnZW50KG9wdHMpLCBhZ2VudHMgPSB7IGh0dHA6IGh0dHBBZ2VudCwgaHR0cHM6IGh0dHBzQWdlbnQgfTtcbiAgcmV0dXJuIHtcbiAgICBmaW5hbGl6ZU9wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5hZ2VudClcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5tYXhSZWRpcmVjdHMgPiAwKVxuICAgICAgICByZXR1cm4geyAuLi5vcHRpb25zLCBhZ2VudHMgfTtcbiAgICAgIGNvbnN0IGlzSHR0cHMgPSBpc0h0dHBzUHJvdG8udGVzdChvcHRpb25zLmhyZWYgfHwgb3B0aW9ucy5wcm90b2NvbCk7XG4gICAgICByZXR1cm4geyAuLi5vcHRpb25zLCBhZ2VudDogaXNIdHRwcyA/IGh0dHBzQWdlbnQgOiBodHRwQWdlbnQgfTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBsZWFkaW5nU2xhc2ggPSAvXlxcLy8sIHRyYWlsaW5nU2xhc2ggPSAvXFwvJC87XG5mdW5jdGlvbiBiYXNlKGJhc2VVcmwpIHtcbiAgY29uc3QgYmFzZVVyaSA9IGJhc2VVcmwucmVwbGFjZSh0cmFpbGluZ1NsYXNoLCBcIlwiKTtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmICgvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KG9wdGlvbnMudXJsKSlcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICBjb25zdCB1cmwgPSBbYmFzZVVyaSwgb3B0aW9ucy51cmwucmVwbGFjZShsZWFkaW5nU2xhc2gsIFwiXCIpXS5qb2luKFwiL1wiKTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHVybCB9KTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBTRU5TSVRJVkVfSEVBREVSUyA9IFtcImNvb2tpZVwiLCBcImF1dGhvcml6YXRpb25cIl0sIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIHJlZGFjdEtleXMgPSAoc291cmNlLCByZWRhY3RlZCkgPT4ge1xuICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKVxuICAgIGhhc093bi5jYWxsKHNvdXJjZSwga2V5KSAmJiAodGFyZ2V0W2tleV0gPSByZWRhY3RlZC5pbmRleE9mKGtleS50b0xvd2VyQ2FzZSgpKSA+IC0xID8gXCI8cmVkYWN0ZWQ+XCIgOiBzb3VyY2Vba2V5XSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuZnVuY3Rpb24gZGVidWcob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHZlcmJvc2UgPSBvcHRzLnZlcmJvc2UsIG5hbWVzcGFjZSA9IG9wdHMubmFtZXNwYWNlIHx8IFwiZ2V0LWl0XCIsIGRlZmF1bHRMb2dnZXIgPSBkZWJ1Z0l0X19kZWZhdWx0LmRlZmF1bHQobmFtZXNwYWNlKSwgbG9nID0gb3B0cy5sb2cgfHwgZGVmYXVsdExvZ2dlciwgc2hvcnRDaXJjdWl0ID0gbG9nID09PSBkZWZhdWx0TG9nZ2VyICYmICFkZWJ1Z0l0X19kZWZhdWx0LmRlZmF1bHQuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBsZXQgcmVxdWVzdElkID0gMDtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IChvcHRpb25zLmRlYnVnID0gbG9nLCBvcHRpb25zLnJlcXVlc3RJZCA9IG9wdGlvbnMucmVxdWVzdElkIHx8ICsrcmVxdWVzdElkLCBvcHRpb25zKSxcbiAgICBvblJlcXVlc3Q6IChldmVudCkgPT4ge1xuICAgICAgaWYgKHNob3J0Q2lyY3VpdCB8fCAhZXZlbnQpXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC5vcHRpb25zO1xuICAgICAgaWYgKGxvZyhcIlslc10gSFRUUCAlcyAlc1wiLCBvcHRpb25zLnJlcXVlc3RJZCwgb3B0aW9ucy5tZXRob2QsIG9wdGlvbnMudXJsKSwgdmVyYm9zZSAmJiBvcHRpb25zLmJvZHkgJiYgdHlwZW9mIG9wdGlvbnMuYm9keSA9PSBcInN0cmluZ1wiICYmIGxvZyhcIlslc10gUmVxdWVzdCBib2R5OiAlc1wiLCBvcHRpb25zLnJlcXVlc3RJZCwgb3B0aW9ucy5ib2R5KSwgdmVyYm9zZSAmJiBvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyczIgPSBvcHRzLnJlZGFjdFNlbnNpdGl2ZUhlYWRlcnMgPT09ICExID8gb3B0aW9ucy5oZWFkZXJzIDogcmVkYWN0S2V5cyhvcHRpb25zLmhlYWRlcnMsIFNFTlNJVElWRV9IRUFERVJTKTtcbiAgICAgICAgbG9nKFwiWyVzXSBSZXF1ZXN0IGhlYWRlcnM6ICVzXCIsIG9wdGlvbnMucmVxdWVzdElkLCBKU09OLnN0cmluZ2lmeShoZWFkZXJzMiwgbnVsbCwgMikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH0sXG4gICAgb25SZXNwb25zZTogKHJlcywgY29udGV4dCkgPT4ge1xuICAgICAgaWYgKHNob3J0Q2lyY3VpdCB8fCAhcmVzKVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgY29uc3QgcmVxSWQgPSBjb250ZXh0Lm9wdGlvbnMucmVxdWVzdElkO1xuICAgICAgcmV0dXJuIGxvZyhcIlslc10gUmVzcG9uc2UgY29kZTogJXMgJXNcIiwgcmVxSWQsIHJlcy5zdGF0dXNDb2RlLCByZXMuc3RhdHVzTWVzc2FnZSksIHZlcmJvc2UgJiYgcmVzLmJvZHkgJiYgbG9nKFwiWyVzXSBSZXNwb25zZSBib2R5OiAlc1wiLCByZXFJZCwgc3RyaW5naWZ5Qm9keShyZXMpKSwgcmVzO1xuICAgIH0sXG4gICAgb25FcnJvcjogKGVyciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgcmVxSWQgPSBjb250ZXh0Lm9wdGlvbnMucmVxdWVzdElkO1xuICAgICAgcmV0dXJuIGVyciA/IChsb2coXCJbJXNdIEVSUk9SOiAlc1wiLCByZXFJZCwgZXJyLm1lc3NhZ2UpLCBlcnIpIDogKGxvZyhcIlslc10gRXJyb3IgZW5jb3VudGVyZWQsIGJ1dCBoYW5kbGVkIGJ5IGFuIGVhcmxpZXIgbWlkZGxld2FyZVwiLCByZXFJZCksIGVycik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5Qm9keShyZXMpIHtcbiAgcmV0dXJuIChyZXMuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpICE9PSAtMSA/IHRyeUZvcm1hdChyZXMuYm9keSkgOiByZXMuYm9keTtcbn1cbmZ1bmN0aW9uIHRyeUZvcm1hdChib2R5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gdHlwZW9mIGJvZHkgPT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UoYm9keSkgOiBib2R5O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZWQsIG51bGwsIDIpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gYm9keTtcbiAgfVxufVxuZnVuY3Rpb24gaGVhZGVycyhfaGVhZGVycywgb3B0cyA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICAgIHJldHVybiBvcHRpb25zLmhlYWRlcnMgPSBvcHRzLm92ZXJyaWRlID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIF9oZWFkZXJzKSA6IE9iamVjdC5hc3NpZ24oe30sIF9oZWFkZXJzLCBleGlzdGluZyksIG9wdGlvbnM7XG4gICAgfVxuICB9O1xufVxuY2xhc3MgSHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXMsIGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgdHJ1bmNhdGVkVXJsID0gcmVzLnVybC5sZW5ndGggPiA0MDAgPyBgJHtyZXMudXJsLnNsaWNlKDAsIDM5OSl9XFx1MjAyNmAgOiByZXMudXJsO1xuICAgIGxldCBtc2cgPSBgJHtyZXMubWV0aG9kfS1yZXF1ZXN0IHRvICR7dHJ1bmNhdGVkVXJsfSByZXN1bHRlZCBpbiBgO1xuICAgIG1zZyArPSBgSFRUUCAke3Jlcy5zdGF0dXNDb2RlfSAke3Jlcy5zdGF0dXNNZXNzYWdlfWAsIHRoaXMubWVzc2FnZSA9IG1zZy50cmltKCksIHRoaXMucmVzcG9uc2UgPSByZXMsIHRoaXMucmVxdWVzdCA9IGN0eC5vcHRpb25zO1xuICB9XG59XG5mdW5jdGlvbiBodHRwRXJyb3JzKCkge1xuICByZXR1cm4ge1xuICAgIG9uUmVzcG9uc2U6IChyZXMsIGN0eCkgPT4ge1xuICAgICAgaWYgKCEocmVzLnN0YXR1c0NvZGUgPj0gNDAwKSlcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IocmVzLCBjdHgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGluamVjdFJlc3BvbnNlKG9wdHMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdHMuaW5qZWN0ICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgaW5qZWN0UmVzcG9uc2VgIG1pZGRsZXdhcmUgcmVxdWlyZXMgYSBgaW5qZWN0YCBmdW5jdGlvblwiKTtcbiAgcmV0dXJuIHsgaW50ZXJjZXB0UmVxdWVzdDogZnVuY3Rpb24ocHJldlZhbHVlLCBldmVudCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gb3B0cy5pbmplY3QoZXZlbnQsIHByZXZWYWx1ZSk7XG4gICAgaWYgKCFyZXNwb25zZSlcbiAgICAgIHJldHVybiBwcmV2VmFsdWU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LmNvbnRleHQub3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgYm9keTogXCJcIixcbiAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICBzdGF0dXNNZXNzYWdlOiBcIk9LXCIsXG4gICAgICAuLi5yZXNwb25zZVxuICAgIH07XG4gIH0gfTtcbn1cbmNvbnN0IGlzQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA+IFwidVwiID8gKCkgPT4gITEgOiAob2JqKSA9PiBCdWZmZXIuaXNCdWZmZXIob2JqKSwgc2VyaWFsaXplVHlwZXMgPSBbXCJib29sZWFuXCIsIFwic3RyaW5nXCIsIFwibnVtYmVyXCJdO1xuZnVuY3Rpb24ganNvblJlcXVlc3QoKSB7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgICAgcmV0dXJuICFib2R5IHx8ICEodHlwZW9mIGJvZHkucGlwZSAhPSBcImZ1bmN0aW9uXCIgJiYgIWlzQnVmZmVyKGJvZHkpICYmIChzZXJpYWxpemVUeXBlcy5pbmRleE9mKHR5cGVvZiBib2R5KSAhPT0gLTEgfHwgQXJyYXkuaXNBcnJheShib2R5KSB8fCBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QoYm9keSkpKSA/IG9wdGlvbnMgOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSksXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBqc29uUmVzcG9uc2Uob3B0cykge1xuICByZXR1cm4ge1xuICAgIG9uUmVzcG9uc2U6IChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiXCIsIHNob3VsZERlY29kZSA9IG9wdHMgJiYgb3B0cy5mb3JjZSB8fCBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTE7XG4gICAgICByZXR1cm4gIXJlc3BvbnNlLmJvZHkgfHwgIWNvbnRlbnRUeXBlIHx8ICFzaG91bGREZWNvZGUgPyByZXNwb25zZSA6IE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbnNlLCB7IGJvZHk6IHRyeVBhcnNlKHJlc3BvbnNlLmJvZHkpIH0pO1xuICAgIH0sXG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCBvcHRpb25zLmhlYWRlcnMpXG4gICAgfSlcbiAgfTtcbiAgZnVuY3Rpb24gdHJ5UGFyc2UoYm9keSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShib2R5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVyci5tZXNzYWdlID0gYEZhaWxlZCB0byBwYXJzZWQgcmVzcG9uc2UgYm9keSBhcyBKU09OOiAke2Vyci5tZXNzYWdlfWAsIGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQnJvd3Nlck9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gdHlwZW9mIG9wdGlvbnMgPT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsICYmICEoXCJwcm90b2NvbFwiIGluIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gbXRscyhjb25maWcgPSB7fSkge1xuICBpZiAoIWNvbmZpZy5jYSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIG10bHMgb3B0aW9uIFwiY2FcIiBpcyBtaXNzaW5nJyk7XG4gIGlmICghY29uZmlnLmNlcnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImNlcnRcIiBpcyBtaXNzaW5nJyk7XG4gIGlmICghY29uZmlnLmtleSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIG10bHMgb3B0aW9uIFwia2V5XCIgaXMgbWlzc2luZycpO1xuICByZXR1cm4ge1xuICAgIGZpbmFsaXplT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChpc0Jyb3dzZXJPcHRpb25zKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIGNvbnN0IG10bHNPcHRzID0ge1xuICAgICAgICBjZXJ0OiBjb25maWcuY2VydCxcbiAgICAgICAga2V5OiBjb25maWcua2V5LFxuICAgICAgICBjYTogY29uZmlnLmNhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIG10bHNPcHRzKTtcbiAgICB9XG4gIH07XG59XG5sZXQgYWN0dWFsR2xvYmFsID0ge307XG50eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gYWN0dWFsR2xvYmFsID0gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IGFjdHVhbEdsb2JhbCA9IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGFjdHVhbEdsb2JhbCA9IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgJiYgKGFjdHVhbEdsb2JhbCA9IHNlbGYpO1xudmFyIGdsb2JhbCQxID0gYWN0dWFsR2xvYmFsO1xuZnVuY3Rpb24gb2JzZXJ2YWJsZShvcHRzID0ge30pIHtcbiAgY29uc3QgT2JzZXJ2YWJsZSA9IChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBAVE9ETyBjb25zaWRlciBkcm9wcGluZyBjaGVja2luZyBmb3IgYSBnbG9iYWwgT2JzZXJ2YWJsZSBzaW5jZSBpdCdzIG5vdCBvbiBhIHN0YW5kYXJkcyB0cmFja1xuICAgIG9wdHMuaW1wbGVtZW50YXRpb24gfHwgZ2xvYmFsJDEuT2JzZXJ2YWJsZVxuICApO1xuICBpZiAoIU9ic2VydmFibGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgT2JzZXJ2YWJsZWAgaXMgbm90IGF2YWlsYWJsZSBpbiBnbG9iYWwgc2NvcGUsIGFuZCBubyBpbXBsZW1lbnRhdGlvbiB3YXMgcGFzc2VkXCJcbiAgICApO1xuICByZXR1cm4ge1xuICAgIG9uUmV0dXJuOiAoY2hhbm5lbHMsIGNvbnRleHQpID0+IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4gKGNoYW5uZWxzLmVycm9yLnN1YnNjcmliZSgoZXJyKSA9PiBvYnNlcnZlci5lcnJvcihlcnIpKSwgY2hhbm5lbHMucHJvZ3Jlc3Muc3Vic2NyaWJlKFxuICAgICAgKGV2ZW50KSA9PiBvYnNlcnZlci5uZXh0KE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcInByb2dyZXNzXCIgfSwgZXZlbnQpKVxuICAgICksIGNoYW5uZWxzLnJlc3BvbnNlLnN1YnNjcmliZSgocmVzcG9uc2UpID0+IHtcbiAgICAgIG9ic2VydmVyLm5leHQoT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwicmVzcG9uc2VcIiB9LCByZXNwb25zZSkpLCBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgIH0pLCBjaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2goY29udGV4dCksICgpID0+IGNoYW5uZWxzLmFib3J0LnB1Ymxpc2goKSkpXG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVyKHN0YWdlKSB7XG4gIHJldHVybiAocHJvZykgPT4gKHtcbiAgICBzdGFnZSxcbiAgICBwZXJjZW50OiBwcm9nLnBlcmNlbnRhZ2UsXG4gICAgdG90YWw6IHByb2cubGVuZ3RoLFxuICAgIGxvYWRlZDogcHJvZy50cmFuc2ZlcnJlZCxcbiAgICBsZW5ndGhDb21wdXRhYmxlOiAhKHByb2cubGVuZ3RoID09PSAwICYmIHByb2cucGVyY2VudGFnZSA9PT0gMClcbiAgfSk7XG59XG5mdW5jdGlvbiBwcm9ncmVzcygpIHtcbiAgcmV0dXJuIHtcbiAgICBvbkhlYWRlcnM6IChyZXNwb25zZSwgZXZ0KSA9PiB7XG4gICAgICBjb25zdCBfcHJvZ3Jlc3MgPSBwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdC5kZWZhdWx0KHsgdGltZTogMTYgfSksIG5vcm1hbGl6ZSA9IG5vcm1hbGl6ZXIoXCJkb3dubG9hZFwiKSwgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSwgbGVuZ3RoID0gY29udGVudExlbmd0aCA/IE51bWJlcihjb250ZW50TGVuZ3RoKSA6IDA7XG4gICAgICByZXR1cm4gIWlzTmFOKGxlbmd0aCkgJiYgbGVuZ3RoID4gMCAmJiBfcHJvZ3Jlc3Muc2V0TGVuZ3RoKGxlbmd0aCksIF9wcm9ncmVzcy5vbihcInByb2dyZXNzXCIsIChwcm9nKSA9PiBldnQuY29udGV4dC5jaGFubmVscy5wcm9ncmVzcy5wdWJsaXNoKG5vcm1hbGl6ZShwcm9nKSkpLCByZXNwb25zZS5waXBlKF9wcm9ncmVzcyk7XG4gICAgfSxcbiAgICBvblJlcXVlc3Q6IChldnQpID0+IHtcbiAgICAgIGlmICghZXZ0LnByb2dyZXNzKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBub3JtYWxpemUgPSBub3JtYWxpemVyKFwidXBsb2FkXCIpO1xuICAgICAgZXZ0LnByb2dyZXNzLm9uKFxuICAgICAgICBcInByb2dyZXNzXCIsXG4gICAgICAgIChwcm9nKSA9PiBldnQuY29udGV4dC5jaGFubmVscy5wcm9ncmVzcy5wdWJsaXNoKG5vcm1hbGl6ZShwcm9nKSlcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgcHJvbWlzZSA9IChvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgUHJvbWlzZUltcGxlbWVudGF0aW9uID0gb3B0aW9ucy5pbXBsZW1lbnRhdGlvbiB8fCBQcm9taXNlO1xuICBpZiAoIVByb21pc2VJbXBsZW1lbnRhdGlvbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgUHJvbWlzZWAgaXMgbm90IGF2YWlsYWJsZSBpbiBnbG9iYWwgc2NvcGUsIGFuZCBubyBpbXBsZW1lbnRhdGlvbiB3YXMgcGFzc2VkXCIpO1xuICByZXR1cm4ge1xuICAgIG9uUmV0dXJuOiAoY2hhbm5lbHMsIGNvbnRleHQpID0+IG5ldyBQcm9taXNlSW1wbGVtZW50YXRpb24oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2FuY2VsID0gY29udGV4dC5vcHRpb25zLmNhbmNlbFRva2VuO1xuICAgICAgY2FuY2VsICYmIGNhbmNlbC5wcm9taXNlLnRoZW4oKHJlYXNvbikgPT4ge1xuICAgICAgICBjaGFubmVscy5hYm9ydC5wdWJsaXNoKHJlYXNvbiksIHJlamVjdChyZWFzb24pO1xuICAgICAgfSksIGNoYW5uZWxzLmVycm9yLnN1YnNjcmliZShyZWplY3QpLCBjaGFubmVscy5yZXNwb25zZS5zdWJzY3JpYmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHJlc29sdmUob3B0aW9ucy5vbmx5Qm9keSA/IHJlc3BvbnNlLmJvZHkgOiByZXNwb25zZSk7XG4gICAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfSlcbiAgfTtcbn07XG5jbGFzcyBDYW5jZWwge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5fX0NBTkNFTF9fID0gITAsIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBDYW5jZWwke3RoaXMubWVzc2FnZSA/IGA6ICR7dGhpcy5tZXNzYWdlfWAgOiBcIlwifWA7XG4gIH1cbn1cbmNvbnN0IF9DYW5jZWxUb2tlbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIGxldCByZXNvbHZlUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KSwgZXhlY3V0b3IoKG1lc3NhZ2UpID0+IHtcbiAgICAgIHRoaXMucmVhc29uIHx8ICh0aGlzLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSksIHJlc29sdmVQcm9taXNlKHRoaXMucmVhc29uKSk7XG4gICAgfSk7XG4gIH1cbn07XG5fQ2FuY2VsVG9rZW4uc291cmNlID0gKCkgPT4ge1xuICBsZXQgY2FuY2VsO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiBuZXcgX0NhbmNlbFRva2VuKChjYW4pID0+IHtcbiAgICAgIGNhbmNlbCA9IGNhbjtcbiAgICB9KSxcbiAgICBjYW5jZWxcbiAgfTtcbn07XG5sZXQgQ2FuY2VsVG9rZW4gPSBfQ2FuY2VsVG9rZW47XG5jb25zdCBpc0NhbmNlbCA9ICh2YWx1ZSkgPT4gISEodmFsdWUgJiYgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbnByb21pc2UuQ2FuY2VsID0gQ2FuY2VsO1xucHJvbWlzZS5DYW5jZWxUb2tlbiA9IENhbmNlbFRva2VuO1xucHJvbWlzZS5pc0NhbmNlbCA9IGlzQ2FuY2VsO1xuZnVuY3Rpb24gcHJveHkoX3Byb3h5KSB7XG4gIGlmIChfcHJveHkgIT09ICExICYmICghX3Byb3h5IHx8ICFfcHJveHkuaG9zdCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJveHkgbWlkZGxld2FyZSB0YWtlcyBhbiBvYmplY3Qgb2YgaG9zdCwgcG9ydCBhbmQgYXV0aCBwcm9wZXJ0aWVzXCIpO1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4gT2JqZWN0LmFzc2lnbih7IHByb3h5OiBfcHJveHkgfSwgb3B0aW9ucylcbiAgfTtcbn1cbnZhciBkZWZhdWx0U2hvdWxkUmV0cnkgPSAoZXJyLCBudW0sIG9wdGlvbnMpID0+IG9wdGlvbnMubWV0aG9kICE9PSBcIkdFVFwiICYmIG9wdGlvbnMubWV0aG9kICE9PSBcIkhFQURcIiB8fCBlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLnN0YXR1c0NvZGUgPyAhMSA6IGFsbG93ZWRfX2RlZmF1bHQuZGVmYXVsdChlcnIpO1xuY29uc3QgaXNTdHJlYW0gPSAoc3RyZWFtKSA9PiBzdHJlYW0gIT09IG51bGwgJiYgdHlwZW9mIHN0cmVhbSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzdHJlYW0ucGlwZSA9PSBcImZ1bmN0aW9uXCI7XG52YXIgc2hhcmVkUmV0cnkgPSAob3B0cykgPT4ge1xuICBjb25zdCBtYXhSZXRyaWVzID0gb3B0cy5tYXhSZXRyaWVzIHx8IDUsIHJldHJ5RGVsYXkgPSBvcHRzLnJldHJ5RGVsYXkgfHwgZ2V0UmV0cnlEZWxheSwgYWxsb3dSZXRyeSA9IG9wdHMuc2hvdWxkUmV0cnk7XG4gIHJldHVybiB7XG4gICAgb25FcnJvcjogKGVyciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucywgbWF4ID0gb3B0aW9ucy5tYXhSZXRyaWVzIHx8IG1heFJldHJpZXMsIHNob3VsZFJldHJ5ID0gb3B0aW9ucy5zaG91bGRSZXRyeSB8fCBhbGxvd1JldHJ5LCBhdHRlbXB0TnVtYmVyID0gb3B0aW9ucy5hdHRlbXB0TnVtYmVyIHx8IDA7XG4gICAgICBpZiAoaXNTdHJlYW0ob3B0aW9ucy5ib2R5KSB8fCAhc2hvdWxkUmV0cnkoZXJyLCBhdHRlbXB0TnVtYmVyLCBvcHRpb25zKSB8fCBhdHRlbXB0TnVtYmVyID49IG1heClcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LCB7XG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgYXR0ZW1wdE51bWJlcjogYXR0ZW1wdE51bWJlciArIDEgfSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gY29udGV4dC5jaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2gobmV3Q29udGV4dCksIHJldHJ5RGVsYXkoYXR0ZW1wdE51bWJlcikpLCBudWxsO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRSZXRyeURlbGF5KGF0dGVtcHROdW0pIHtcbiAgcmV0dXJuIDEwMCAqIE1hdGgucG93KDIsIGF0dGVtcHROdW0pICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbn1cbmNvbnN0IHJldHJ5ID0gKG9wdHMgPSB7fSkgPT4gc2hhcmVkUmV0cnkoeyBzaG91bGRSZXRyeTogZGVmYXVsdFNob3VsZFJldHJ5LCAuLi5vcHRzIH0pO1xucmV0cnkuc2hvdWxkUmV0cnkgPSBkZWZhdWx0U2hvdWxkUmV0cnk7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgbmVzdCA9IChuYW1lLCBfdmFsdWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IF92YWx1ZSBpbnN0YW5jZW9mIFNldCA/IEFycmF5LmZyb20oX3ZhbHVlKSA6IF92YWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICBpZiAodmFsdWUubGVuZ3RoKVxuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIHZhbHVlKVxuICAgICAgICAgIG5lc3QoYCR7bmFtZX1bJHtpbmRleH1dYCwgdmFsdWVbaW5kZXhdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcXVlcnkuYXBwZW5kKGAke25hbWV9W11gLCBcIlwiKTtcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbClcbiAgICAgIGZvciAoY29uc3QgW2tleSwgb2JqXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpXG4gICAgICAgIG5lc3QoYCR7bmFtZX1bJHtrZXl9XWAsIG9iaik7XG4gICAgZWxzZVxuICAgICAgcXVlcnkuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgfTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpXG4gICAgbmVzdChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHF1ZXJ5LnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB1cmxFbmNvZGVkKCkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgIHJldHVybiAhYm9keSB8fCAhKHR5cGVvZiBib2R5LnBpcGUgIT0gXCJmdW5jdGlvblwiICYmICFpc0J1ZmZlcihib2R5KSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QoYm9keSkpID8gb3B0aW9ucyA6IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgYm9keTogZW5jb2RlKG9wdGlvbnMuYm9keSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkS2VlcEFsaXZlKGFnZW50Mikge1xuICByZXR1cm4gZnVuY3Rpb24oY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBtcyA9IGNvbmZpZy5tcyB8fCAxZTMsIG1heEZyZWUgPSBjb25maWcubWF4RnJlZSB8fCAyNTY7XG4gICAgcmV0dXJuIGFnZW50Mih7XG4gICAgICBrZWVwQWxpdmU6ICEwLFxuICAgICAga2VlcEFsaXZlTXNlY3M6IG1zLFxuICAgICAgbWF4RnJlZVNvY2tldHM6IG1heEZyZWVcbiAgICB9KTtcbiAgfTtcbn1cbmNvbnN0IGtlZXBBbGl2ZSA9IGJ1aWxkS2VlcEFsaXZlKGFnZW50KTtcbmV4cG9ydHMucHJvY2Vzc09wdGlvbnMgPSBkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci5wcm9jZXNzT3B0aW9ucztcbmV4cG9ydHMudmFsaWRhdGVPcHRpb25zID0gZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IudmFsaWRhdGVPcHRpb25zO1xuZXhwb3J0cy5DYW5jZWwgPSBDYW5jZWw7XG5leHBvcnRzLkNhbmNlbFRva2VuID0gQ2FuY2VsVG9rZW47XG5leHBvcnRzLmFnZW50ID0gYWdlbnQ7XG5leHBvcnRzLmJhc2UgPSBiYXNlO1xuZXhwb3J0cy5kZWJ1ZyA9IGRlYnVnO1xuZXhwb3J0cy5oZWFkZXJzID0gaGVhZGVycztcbmV4cG9ydHMuaHR0cEVycm9ycyA9IGh0dHBFcnJvcnM7XG5leHBvcnRzLmluamVjdFJlc3BvbnNlID0gaW5qZWN0UmVzcG9uc2U7XG5leHBvcnRzLmpzb25SZXF1ZXN0ID0ganNvblJlcXVlc3Q7XG5leHBvcnRzLmpzb25SZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbmV4cG9ydHMua2VlcEFsaXZlID0ga2VlcEFsaXZlO1xuZXhwb3J0cy5tdGxzID0gbXRscztcbmV4cG9ydHMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG5leHBvcnRzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5leHBvcnRzLnByb21pc2UgPSBwcm9taXNlO1xuZXhwb3J0cy5wcm94eSA9IHByb3h5O1xuZXhwb3J0cy5yZXRyeSA9IHJldHJ5O1xuZXhwb3J0cy51cmxFbmNvZGVkID0gdXJsRW5jb2RlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pZGRsZXdhcmUuY2pzLm1hcFxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaHR0cCIsInJlcXVpcmUiLCJodHRwcyIsImRlYnVnSXQiLCJkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvciIsImlzUGxhaW5PYmplY3QiLCJwcm9ncmVzc1N0cmVhbSIsImFsbG93ZWQiLCJfaW50ZXJvcERlZmF1bHRDb21wYXQiLCJlIiwiZGVmYXVsdCIsImRlYnVnSXRfX2RlZmF1bHQiLCJwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdCIsImFsbG93ZWRfX2RlZmF1bHQiLCJpc0h0dHBzUHJvdG8iLCJhZ2VudCIsIm9wdHMiLCJodHRwQWdlbnQiLCJBZ2VudCIsImh0dHBzQWdlbnQiLCJhZ2VudHMiLCJmaW5hbGl6ZU9wdGlvbnMiLCJvcHRpb25zIiwibWF4UmVkaXJlY3RzIiwiaXNIdHRwcyIsInRlc3QiLCJocmVmIiwicHJvdG9jb2wiLCJsZWFkaW5nU2xhc2giLCJ0cmFpbGluZ1NsYXNoIiwiYmFzZSIsImJhc2VVcmwiLCJiYXNlVXJpIiwicmVwbGFjZSIsInByb2Nlc3NPcHRpb25zIiwidXJsIiwiam9pbiIsImFzc2lnbiIsIlNFTlNJVElWRV9IRUFERVJTIiwiaGFzT3duIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJyZWRhY3RLZXlzIiwic291cmNlIiwicmVkYWN0ZWQiLCJ0YXJnZXQiLCJrZXkiLCJjYWxsIiwiaW5kZXhPZiIsInRvTG93ZXJDYXNlIiwiZGVidWciLCJ2ZXJib3NlIiwibmFtZXNwYWNlIiwiZGVmYXVsdExvZ2dlciIsImxvZyIsInNob3J0Q2lyY3VpdCIsImVuYWJsZWQiLCJyZXF1ZXN0SWQiLCJvblJlcXVlc3QiLCJldmVudCIsIm1ldGhvZCIsImJvZHkiLCJoZWFkZXJzIiwiaGVhZGVyczIiLCJyZWRhY3RTZW5zaXRpdmVIZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9uUmVzcG9uc2UiLCJyZXMiLCJjb250ZXh0IiwicmVxSWQiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsInN0cmluZ2lmeUJvZHkiLCJvbkVycm9yIiwiZXJyIiwibWVzc2FnZSIsInRyeUZvcm1hdCIsInBhcnNlZCIsInBhcnNlIiwiX2hlYWRlcnMiLCJleGlzdGluZyIsIm92ZXJyaWRlIiwiSHR0cEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImN0eCIsInRydW5jYXRlZFVybCIsImxlbmd0aCIsInNsaWNlIiwibXNnIiwidHJpbSIsInJlc3BvbnNlIiwicmVxdWVzdCIsImh0dHBFcnJvcnMiLCJpbmplY3RSZXNwb25zZSIsImluamVjdCIsImludGVyY2VwdFJlcXVlc3QiLCJwcmV2VmFsdWUiLCJpc0J1ZmZlciIsIkJ1ZmZlciIsIm9iaiIsInNlcmlhbGl6ZVR5cGVzIiwianNvblJlcXVlc3QiLCJwaXBlIiwiQXJyYXkiLCJpc0FycmF5IiwianNvblJlc3BvbnNlIiwiY29udGVudFR5cGUiLCJzaG91bGREZWNvZGUiLCJmb3JjZSIsInRyeVBhcnNlIiwiQWNjZXB0IiwiaXNCcm93c2VyT3B0aW9ucyIsIm10bHMiLCJjb25maWciLCJjYSIsImNlcnQiLCJtdGxzT3B0cyIsImFjdHVhbEdsb2JhbCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiZ2xvYmFsJDEiLCJvYnNlcnZhYmxlIiwiT2JzZXJ2YWJsZSIsImltcGxlbWVudGF0aW9uIiwib25SZXR1cm4iLCJjaGFubmVscyIsIm9ic2VydmVyIiwiZXJyb3IiLCJzdWJzY3JpYmUiLCJwcm9ncmVzcyIsIm5leHQiLCJ0eXBlIiwiY29tcGxldGUiLCJwdWJsaXNoIiwiYWJvcnQiLCJub3JtYWxpemVyIiwic3RhZ2UiLCJwcm9nIiwicGVyY2VudCIsInBlcmNlbnRhZ2UiLCJ0b3RhbCIsImxvYWRlZCIsInRyYW5zZmVycmVkIiwibGVuZ3RoQ29tcHV0YWJsZSIsIm9uSGVhZGVycyIsImV2dCIsIl9wcm9ncmVzcyIsInRpbWUiLCJub3JtYWxpemUiLCJjb250ZW50TGVuZ3RoIiwiTnVtYmVyIiwiaXNOYU4iLCJzZXRMZW5ndGgiLCJvbiIsInByb21pc2UiLCJQcm9taXNlSW1wbGVtZW50YXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbmNlbCIsImNhbmNlbFRva2VuIiwidGhlbiIsInJlYXNvbiIsIm9ubHlCb2R5Iiwic2V0VGltZW91dCIsIkNhbmNlbCIsIl9fQ0FOQ0VMX18iLCJ0b1N0cmluZyIsIl9DYW5jZWxUb2tlbiIsImV4ZWN1dG9yIiwiVHlwZUVycm9yIiwicmVzb2x2ZVByb21pc2UiLCJ0b2tlbiIsImNhbiIsIkNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJwcm94eSIsIl9wcm94eSIsImhvc3QiLCJkZWZhdWx0U2hvdWxkUmV0cnkiLCJudW0iLCJpc1N0cmVhbSIsInN0cmVhbSIsInNoYXJlZFJldHJ5IiwibWF4UmV0cmllcyIsInJldHJ5RGVsYXkiLCJnZXRSZXRyeURlbGF5IiwiYWxsb3dSZXRyeSIsInNob3VsZFJldHJ5IiwibWF4IiwiYXR0ZW1wdE51bWJlciIsIm5ld0NvbnRleHQiLCJhdHRlbXB0TnVtIiwiTWF0aCIsInBvdyIsInJhbmRvbSIsInJldHJ5IiwiZW5jb2RlIiwiZGF0YSIsInF1ZXJ5IiwiVVJMU2VhcmNoUGFyYW1zIiwibmVzdCIsIm5hbWUiLCJfdmFsdWUiLCJTZXQiLCJmcm9tIiwiaW5kZXgiLCJhcHBlbmQiLCJlbnRyaWVzIiwidXJsRW5jb2RlZCIsImJ1aWxkS2VlcEFsaXZlIiwiYWdlbnQyIiwibXMiLCJtYXhGcmVlIiwia2VlcEFsaXZlIiwia2VlcEFsaXZlTXNlY3MiLCJtYXhGcmVlU29ja2V0cyIsInZhbGlkYXRlT3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/middleware.cjs\n");

/***/ })

};
;