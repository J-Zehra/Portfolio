"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_sanity_client_dist__chunks_stegaEncodeSourceMap-De3F_oJN_js"],{

/***/ "(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks/stegaEncodeSourceMap-De3F_oJN.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks/stegaEncodeSourceMap-De3F_oJN.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeIntoResult: function() { return /* binding */ encodeIntoResult; },\n/* harmony export */   stegaEncodeSourceMap: function() { return /* binding */ stegaEncodeSourceMap; },\n/* harmony export */   stegaEncodeSourceMap$1: function() { return /* binding */ stegaEncodeSourceMap$1; }\n/* harmony export */ });\n/* harmony import */ var _browserMiddleware_jPnXCUlp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browserMiddleware-jPnXCUlp.js */ \"(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks/browserMiddleware-jPnXCUlp.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n    return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n    if (!Array.isArray(path)) throw new Error(\"Path is not an array\");\n    return path.reduce((target, segment, i)=>{\n        const segmentType = typeof segment;\n        if (segmentType === \"number\") return \"\".concat(target, \"[\").concat(segment, \"]\");\n        if (segmentType === \"string\") return \"\".concat(target).concat(i === 0 ? \"\" : \".\").concat(segment);\n        if (isKeySegment(segment) && segment._key) return \"\".concat(target, '[_key==\"').concat(segment._key, '\"]');\n        if (Array.isArray(segment)) {\n            const [from, to] = segment;\n            return \"\".concat(target, \"[\").concat(from, \":\").concat(to, \"]\");\n        }\n        throw new Error(\"Unsupported path segment `\".concat(JSON.stringify(segment), \"`\"));\n    }, \"\");\n}\nconst ESCAPE = {\n    \"\\f\": \"\\\\f\",\n    \"\\n\": \"\\\\n\",\n    \"\\r\": \"\\\\r\",\n    \"\t\": \"\\\\t\",\n    \"'\": \"\\\\'\",\n    \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n    \"\\\\f\": \"\\f\",\n    \"\\\\n\": \"\\n\",\n    \"\\\\r\": \"\\r\",\n    \"\\\\t\": \"\t\",\n    \"\\\\'\": \"'\",\n    \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n    return \"$\".concat(path.map((segment)=>typeof segment == \"string\" ? \"['\".concat(segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match)=>ESCAPE[match]), \"']\") : typeof segment == \"number\" ? \"[\".concat(segment, \"]\") : segment._key !== \"\" ? \"[?(@._key=='\".concat(segment._key.replace(/['\\\\]/g, (match)=>ESCAPE[match]), \"')]\") : \"[\".concat(segment._index, \"]\")).join(\"\"));\n}\nfunction parseJsonPath(path) {\n    const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n    let match;\n    for(; (match = parseRe.exec(path)) !== null;){\n        if (match[1] !== void 0) {\n            const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m)=>UNESCAPE[m]);\n            parsed.push(key);\n            continue;\n        }\n        if (match[2] !== void 0) {\n            parsed.push(parseInt(match[2], 10));\n            continue;\n        }\n        if (match[3] !== void 0) {\n            const _key = match[3].replace(/\\\\(\\\\')/g, (m)=>UNESCAPE[m]);\n            parsed.push({\n                _key,\n                _index: -1\n            });\n            continue;\n        }\n    }\n    return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n    return path.map((segment)=>{\n        if (typeof segment == \"string\" || typeof segment == \"number\") return segment;\n        if (segment._key !== \"\") return {\n            _key: segment._key\n        };\n        if (segment._index !== -1) return segment._index;\n        throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n    });\n}\nfunction jsonPathToMappingPath(path) {\n    return path.map((segment)=>{\n        if (typeof segment == \"string\" || typeof segment == \"number\") return segment;\n        if (segment._index !== -1) return segment._index;\n        throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n    });\n}\nfunction resolveMapping(resultPath, csm) {\n    if (!(csm != null && csm.mappings)) return;\n    const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n    if (csm.mappings[resultMappingPath] !== void 0) return {\n        mapping: csm.mappings[resultMappingPath],\n        matchedPath: resultMappingPath,\n        pathSuffix: \"\"\n    };\n    const mappings = Object.entries(csm.mappings).filter((param)=>{\n        let [key] = param;\n        return resultMappingPath.startsWith(key);\n    }).sort((param, param1)=>{\n        let [key1] = param, [key2] = param1;\n        return key2.length - key1.length;\n    });\n    if (mappings.length == 0) return;\n    const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n    return {\n        mapping,\n        matchedPath,\n        pathSuffix\n    };\n}\nfunction isArray(value) {\n    return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n    return typeof value == \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn) {\n    let path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    return isArray(value) ? value.map((v, idx)=>{\n        if (isRecord(v)) {\n            const _key = v._key;\n            if (typeof _key == \"string\") return walkMap(v, mappingFn, path.concat({\n                _key,\n                _index: idx\n            }));\n        }\n        return walkMap(v, mappingFn, path.concat(idx));\n    }) : isRecord(value) ? Object.fromEntries(Object.entries(value).map((param)=>{\n        let [k, v] = param;\n        return [\n            k,\n            walkMap(v, mappingFn, path.concat(k))\n        ];\n    })) : mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n    return walkMap(result, (value, path)=>{\n        if (typeof value != \"string\") return value;\n        const resolveMappingResult = resolveMapping(path, csm);\n        if (!resolveMappingResult) return value;\n        const { mapping, matchedPath } = resolveMappingResult;\n        if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\") return value;\n        const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n        return encoder({\n            sourcePath: fullSourceSegments,\n            sourceDocument,\n            resultPath: path,\n            value\n        });\n    });\n}\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n    return id.startsWith(DRAFTS_PREFIX) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n    const { baseUrl, workspace: _workspace = \"default\", tool: _tool = \"default\", id: _id, type, path, projectId, dataset } = options;\n    if (!baseUrl) throw new Error(\"baseUrl is required\");\n    if (!path) throw new Error(\"path is required\");\n    if (!_id) throw new Error(\"id is required\");\n    if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\")) throw new Error(\"baseUrl must not end with a slash\");\n    const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n        baseUrl,\n        id,\n        type,\n        path: stringifiedPath\n    });\n    workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset);\n    const segments = [\n        baseUrl === \"/\" ? \"\" : baseUrl\n    ];\n    workspace && segments.push(workspace);\n    const routerParams = [\n        \"mode=presentation\",\n        \"id=\".concat(id),\n        \"type=\".concat(type),\n        \"path=\".concat(encodeURIComponent(stringifiedPath))\n    ];\n    return tool && routerParams.push(\"tool=\".concat(tool)), segments.push(\"intent\", \"edit\", \"\".concat(routerParams.join(\";\"), \"?\").concat(searchParams)), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n    let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n    return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? {\n        baseUrl\n    } : {\n        ...studioUrl,\n        baseUrl\n    };\n}\nconst filterDefault = (param)=>{\n    let { sourcePath, value } = param;\n    if (isValidDate(value) || isValidURL(value)) return !1;\n    const endPath = sourcePath.at(-1);\n    return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && endPath.startsWith(\"_\") || typeof endPath == \"number\" && sourcePath.at(-2) === \"marks\" || endPath === \"href\" && typeof sourcePath.at(-2) == \"number\" && sourcePath.at(-3) === \"markDefs\" || endPath === \"style\" || endPath === \"listItem\" || sourcePath.some((path)=>path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\") || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n    \"color\",\n    \"colour\",\n    \"currency\",\n    \"email\",\n    \"format\",\n    \"gid\",\n    \"hex\",\n    \"href\",\n    \"hsl\",\n    \"hsla\",\n    \"icon\",\n    \"id\",\n    \"index\",\n    \"key\",\n    \"language\",\n    \"layout\",\n    \"link\",\n    \"linkAction\",\n    \"locale\",\n    \"lqip\",\n    \"page\",\n    \"path\",\n    \"ref\",\n    \"rgb\",\n    \"rgba\",\n    \"route\",\n    \"secret\",\n    \"slug\",\n    \"status\",\n    \"tag\",\n    \"template\",\n    \"theme\",\n    \"type\",\n    \"unit\",\n    \"url\",\n    \"username\",\n    \"variant\",\n    \"website\"\n]);\nfunction isValidDate(dateString) {\n    return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n    try {\n        new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n    } catch (e) {\n        return !1;\n    }\n    return !0;\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const { filter, logger, enabled } = config;\n    if (!enabled) {\n        const msg = \"config.enabled must be true, don't call this function otherwise\";\n        throw (_a = logger == null ? void 0 : logger.error) == null || _a.call(logger, \"[@sanity/client]: \".concat(msg), {\n            result,\n            resultSourceMap,\n            config\n        }), new TypeError(msg);\n    }\n    if (!resultSourceMap) return (_b = logger == null ? void 0 : logger.error) == null || _b.call(logger, \"[@sanity/client]: Missing Content Source Map from response body\", {\n        result,\n        resultSourceMap,\n        config\n    }), result;\n    if (!config.studioUrl) {\n        const msg = \"config.studioUrl must be defined\";\n        throw (_c = logger == null ? void 0 : logger.error) == null || _c.call(logger, \"[@sanity/client]: \".concat(msg), {\n            result,\n            resultSourceMap,\n            config\n        }), new TypeError(msg);\n    }\n    const report = {\n        encoded: [],\n        skipped: []\n    }, resultWithStega = encodeIntoResult(result, resultSourceMap, (param)=>{\n        let { sourcePath, sourceDocument, resultPath, value } = param;\n        if ((typeof filter == \"function\" ? filter({\n            sourcePath,\n            resultPath,\n            filterDefault,\n            sourceDocument,\n            value\n        }) : filterDefault({\n            sourcePath,\n            resultPath,\n            filterDefault,\n            sourceDocument,\n            value\n        })) === !1) return logger && report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n            length: value.length\n        }), value;\n        logger && report.encoded.push({\n            path: prettyPathForLogging(sourcePath),\n            value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n            length: value.length\n        });\n        const { baseUrl, workspace, tool } = resolveStudioBaseRoute(typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl);\n        if (!baseUrl) return value;\n        const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n        return (0,_browserMiddleware_jPnXCUlp_js__WEBPACK_IMPORTED_MODULE_0__.b)(value, {\n            origin: \"sanity.io\",\n            href: createEditUrl({\n                baseUrl,\n                workspace,\n                tool,\n                id,\n                type,\n                path: sourcePath,\n                ...!config.omitCrossDatasetReferenceData && {\n                    dataset,\n                    projectId\n                }\n            })\n        }, // We use custom logic to determine if we should skip encoding\n        !1);\n    });\n    if (logger) {\n        const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n        if ((isSkipping || isEncoding) && ((_d = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null || _d(\"[@sanity/client]: Encoding source map into result\"), (_e = logger.log) == null || _e.call(logger, \"[@sanity/client]: Paths encoded: \".concat(report.encoded.length, \", skipped: \").concat(report.skipped.length))), report.encoded.length > 0 && ((_f = logger == null ? void 0 : logger.log) == null || _f.call(logger, \"[@sanity/client]: Table of encoded paths\"), (_g = (logger == null ? void 0 : logger.table) || logger.log) == null || _g(report.encoded)), report.skipped.length > 0) {\n            const skipped = /* @__PURE__ */ new Set();\n            for (const { path } of report.skipped)skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n            (_h = logger == null ? void 0 : logger.log) == null || _h.call(logger, \"[@sanity/client]: List of skipped paths\", [\n                ...skipped.values()\n            ]);\n        }\n        (isSkipping || isEncoding) && ((_i = logger == null ? void 0 : logger.groupEnd) == null || _i.call(logger));\n    }\n    return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n    return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n    __proto__: null,\n    stegaEncodeSourceMap\n});\n //# sourceMappingURL=stegaEncodeSourceMap-De3F_oJN.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3Mvc3RlZ2FFbmNvZGVTb3VyY2VNYXAtRGUzRl9vSk4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDtBQUNwRCxNQUFNQyxlQUFlO0FBQ3JCLFNBQVNDLGFBQWFDLE9BQU87SUFDM0IsT0FBTyxPQUFPQSxXQUFXLFdBQVdGLGFBQWFHLElBQUksQ0FBQ0QsUUFBUUUsSUFBSSxNQUFNLE9BQU9GLFdBQVcsWUFBWSxVQUFVQTtBQUNsSDtBQUNBLFNBQVNHLFNBQVNDLElBQUk7SUFDcEIsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNGLE9BQ2pCLE1BQU0sSUFBSUcsTUFBTTtJQUNsQixPQUFPSCxLQUFLSSxNQUFNLENBQUMsQ0FBQ0MsUUFBUVQsU0FBU1U7UUFDbkMsTUFBTUMsY0FBYyxPQUFPWDtRQUMzQixJQUFJVyxnQkFBZ0IsVUFDbEIsT0FBTyxHQUFhWCxPQUFWUyxRQUFPLEtBQVcsT0FBUlQsU0FBUTtRQUM5QixJQUFJVyxnQkFBZ0IsVUFDbEIsT0FBTyxHQUFZRCxPQUFURCxRQUE4QlQsT0FBckJVLE1BQU0sSUFBSSxLQUFLLEtBQWMsT0FBUlY7UUFDMUMsSUFBSUQsYUFBYUMsWUFBWUEsUUFBUVksSUFBSSxFQUN2QyxPQUFPLEdBQW9CWixPQUFqQlMsUUFBTyxZQUF1QixPQUFiVCxRQUFRWSxJQUFJLEVBQUM7UUFDMUMsSUFBSVAsTUFBTUMsT0FBTyxDQUFDTixVQUFVO1lBQzFCLE1BQU0sQ0FBQ2EsTUFBTUMsR0FBRyxHQUFHZDtZQUNuQixPQUFPLEdBQWFhLE9BQVZKLFFBQU8sS0FBV0ssT0FBUkQsTUFBSyxLQUFNLE9BQUhDLElBQUc7UUFDakM7UUFDQSxNQUFNLElBQUlQLE1BQU0sNkJBQXNELE9BQXhCUSxLQUFLQyxTQUFTLENBQUNoQixVQUFTO0lBQ3hFLEdBQUc7QUFDTDtBQUNBLE1BQU1pQixTQUFTO0lBQ2IsTUFBTTtJQUNOLE1B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LEtBQU0sRUFBQ3VFLEtBQUtJLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU9vQixHQUFHLEtBQUssUUFBUXhCLEdBQUdRLElBQUksQ0FBQ0osUUFBUSw2Q0FBNkMsQ0FBQ0gsS0FBSyxDQUFDRyxVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPcUIsS0FBSyxLQUFLckIsT0FBT29CLEdBQUcsS0FBSyxRQUFRdkIsR0FBR1MsT0FBT0MsT0FBTyxJQUFJRCxPQUFPRSxPQUFPLENBQUNuRixNQUFNLEdBQUcsR0FBRztZQUM3USxNQUFNbUYsVUFBVSxhQUFhLEdBQUcsSUFBSTNCO1lBQ3BDLEtBQUssTUFBTSxFQUFFdEcsSUFBSSxFQUFFLElBQUkrSCxPQUFPRSxPQUFPLENBQ25DQSxRQUFRYyxHQUFHLENBQUMvSSxLQUFLaUIsT0FBTyxDQUFDdkIsY0FBYyxLQUFLdUIsT0FBTyxDQUFDLFlBQVk7WUFDakVzRyxDQUFBQSxLQUFLRSxVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPb0IsR0FBRyxLQUFLLFFBQVF0QixHQUFHTSxJQUFJLENBQUNKLFFBQVEsMkNBQTJDO21CQUFJUSxRQUFRZSxNQUFNO2FBQUc7UUFDekk7UUFDQ04sQ0FBQUEsY0FBY0MsVUFBUyxLQUFPLEVBQUNuQixLQUFLQyxVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPd0IsUUFBUSxLQUFLLFFBQVF6QixHQUFHSyxJQUFJLENBQUNKLE9BQU07SUFDM0c7SUFDQSxPQUFPUztBQUNUO0FBQ0EsU0FBU0MscUJBQXFCbkksSUFBSTtJQUNoQyxPQUFPRCxTQUFTOEIscUJBQXFCN0I7QUFDdkM7QUFDQSxJQUFJa0oseUJBQXlCLGFBQWEsR0FBRzNHLE9BQU80RyxNQUFNLENBQUM7SUFDekRDLFdBQVc7SUFDWHZDO0FBQ0Y7QUFLRSxDQUNGLHlEQUF5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzL3N0ZWdhRW5jb2RlU291cmNlTWFwLURlM0Zfb0pOLmpzP2Q1YmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYiB9IGZyb20gXCIuL2Jyb3dzZXJNaWRkbGV3YXJlLWpQblhDVWxwLmpzXCI7XG5jb25zdCByZUtleVNlZ21lbnQgPSAvX2tleVxccyo9PVxccypbJ1wiXSguKilbJ1wiXS87XG5mdW5jdGlvbiBpc0tleVNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiA/IHJlS2V5U2VnbWVudC50ZXN0KHNlZ21lbnQudHJpbSgpKSA6IHR5cGVvZiBzZWdtZW50ID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gc2VnbWVudDtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHBhdGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggaXMgbm90IGFuIGFycmF5XCIpO1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoKHRhcmdldCwgc2VnbWVudCwgaSkgPT4ge1xuICAgIGNvbnN0IHNlZ21lbnRUeXBlID0gdHlwZW9mIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnRUeXBlID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bJHtzZWdtZW50fV1gO1xuICAgIGlmIChzZWdtZW50VHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9JHtpID09PSAwID8gXCJcIiA6IFwiLlwifSR7c2VnbWVudH1gO1xuICAgIGlmIChpc0tleVNlZ21lbnQoc2VnbWVudCkgJiYgc2VnbWVudC5fa2V5KVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bX2tleT09XCIke3NlZ21lbnQuX2tleX1cIl1gO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNlZ21lbnQpKSB7XG4gICAgICBjb25zdCBbZnJvbSwgdG9dID0gc2VnbWVudDtcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9WyR7ZnJvbX06JHt0b31dYDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXRoIHNlZ21lbnQgXFxgJHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1cXGBgKTtcbiAgfSwgXCJcIik7XG59XG5jb25zdCBFU0NBUEUgPSB7XG4gIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgXCJcXG5cIjogXCJcXFxcblwiLFxuICBcIlxcclwiOiBcIlxcXFxyXCIsXG4gIFwiXHRcIjogXCJcXFxcdFwiLFxuICBcIidcIjogXCJcXFxcJ1wiLFxuICBcIlxcXFxcIjogXCJcXFxcXFxcXFwiXG59LCBVTkVTQ0FQRSA9IHtcbiAgXCJcXFxcZlwiOiBcIlxcZlwiLFxuICBcIlxcXFxuXCI6IGBcbmAsXG4gIFwiXFxcXHJcIjogXCJcXHJcIixcbiAgXCJcXFxcdFwiOiBcIlx0XCIsXG4gIFwiXFxcXCdcIjogXCInXCIsXG4gIFwiXFxcXFxcXFxcIjogXCJcXFxcXCJcbn07XG5mdW5jdGlvbiBqc29uUGF0aChwYXRoKSB7XG4gIHJldHVybiBgJCR7cGF0aC5tYXAoKHNlZ21lbnQpID0+IHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgPyBgWycke3NlZ21lbnQucmVwbGFjZSgvW1xcZlxcblxcclxcdCdcXFxcXS9nLCAobWF0Y2gpID0+IEVTQ0FQRVttYXRjaF0pfSddYCA6IHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIgPyBgWyR7c2VnbWVudH1dYCA6IHNlZ21lbnQuX2tleSAhPT0gXCJcIiA/IGBbPyhALl9rZXk9PScke3NlZ21lbnQuX2tleS5yZXBsYWNlKC9bJ1xcXFxdL2csIChtYXRjaCkgPT4gRVNDQVBFW21hdGNoXSl9JyldYCA6IGBbJHtzZWdtZW50Ll9pbmRleH1dYCkuam9pbihcIlwiKX1gO1xufVxuZnVuY3Rpb24gcGFyc2VKc29uUGF0aChwYXRoKSB7XG4gIGNvbnN0IHBhcnNlZCA9IFtdLCBwYXJzZVJlID0gL1xcWycoLio/KSdcXF18XFxbKFxcZCspXFxdfFxcW1xcP1xcKEBcXC5fa2V5PT0nKC4qPyknXFwpXFxdL2c7XG4gIGxldCBtYXRjaDtcbiAgZm9yICg7IChtYXRjaCA9IHBhcnNlUmUuZXhlYyhwYXRoKSkgIT09IG51bGw7ICkge1xuICAgIGlmIChtYXRjaFsxXSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBrZXkgPSBtYXRjaFsxXS5yZXBsYWNlKC9cXFxcKFxcXFx8ZnxufHJ8dHwnKS9nLCAobSkgPT4gVU5FU0NBUEVbbV0pO1xuICAgICAgcGFyc2VkLnB1c2goa2V5KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMl0gIT09IHZvaWQgMCkge1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0sIDEwKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzNdICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IF9rZXkgPSBtYXRjaFszXS5yZXBsYWNlKC9cXFxcKFxcXFwnKS9nLCAobSkgPT4gVU5FU0NBUEVbbV0pO1xuICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICBfa2V5LFxuICAgICAgICBfaW5kZXg6IC0xXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuZnVuY3Rpb24ganNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnQuX2tleSAhPT0gXCJcIilcbiAgICAgIHJldHVybiB7IF9rZXk6IHNlZ21lbnQuX2tleSB9O1xuICAgIGlmIChzZWdtZW50Ll9pbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm4gc2VnbWVudC5faW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZ21lbnQ6JHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBqc29uUGF0aFRvTWFwcGluZ1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgaWYgKHNlZ21lbnQuX2luZGV4ICE9PSAtMSlcbiAgICAgIHJldHVybiBzZWdtZW50Ll9pbmRleDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2VnbWVudDoke0pTT04uc3RyaW5naWZ5KHNlZ21lbnQpfWApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVNYXBwaW5nKHJlc3VsdFBhdGgsIGNzbSkge1xuICBpZiAoIShjc20gIT0gbnVsbCAmJiBjc20ubWFwcGluZ3MpKVxuICAgIHJldHVybjtcbiAgY29uc3QgcmVzdWx0TWFwcGluZ1BhdGggPSBqc29uUGF0aChqc29uUGF0aFRvTWFwcGluZ1BhdGgocmVzdWx0UGF0aCkpO1xuICBpZiAoY3NtLm1hcHBpbmdzW3Jlc3VsdE1hcHBpbmdQYXRoXSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB7XG4gICAgICBtYXBwaW5nOiBjc20ubWFwcGluZ3NbcmVzdWx0TWFwcGluZ1BhdGhdLFxuICAgICAgbWF0Y2hlZFBhdGg6IHJlc3VsdE1hcHBpbmdQYXRoLFxuICAgICAgcGF0aFN1ZmZpeDogXCJcIlxuICAgIH07XG4gIGNvbnN0IG1hcHBpbmdzID0gT2JqZWN0LmVudHJpZXMoY3NtLm1hcHBpbmdzKS5maWx0ZXIoKFtrZXldKSA9PiByZXN1bHRNYXBwaW5nUGF0aC5zdGFydHNXaXRoKGtleSkpLnNvcnQoKFtrZXkxXSwgW2tleTJdKSA9PiBrZXkyLmxlbmd0aCAtIGtleTEubGVuZ3RoKTtcbiAgaWYgKG1hcHBpbmdzLmxlbmd0aCA9PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgW21hdGNoZWRQYXRoLCBtYXBwaW5nXSA9IG1hcHBpbmdzWzBdLCBwYXRoU3VmZml4ID0gcmVzdWx0TWFwcGluZ1BhdGguc3Vic3RyaW5nKG1hdGNoZWRQYXRoLmxlbmd0aCk7XG4gIHJldHVybiB7IG1hcHBpbmcsIG1hdGNoZWRQYXRoLCBwYXRoU3VmZml4IH07XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHdhbGtNYXAodmFsdWUsIG1hcHBpbmdGbiwgcGF0aCA9IFtdKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgodiwgaWR4KSA9PiB7XG4gICAgaWYgKGlzUmVjb3JkKHYpKSB7XG4gICAgICBjb25zdCBfa2V5ID0gdi5fa2V5O1xuICAgICAgaWYgKHR5cGVvZiBfa2V5ID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoeyBfa2V5LCBfaW5kZXg6IGlkeCB9KSk7XG4gICAgfVxuICAgIHJldHVybiB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoaWR4KSk7XG4gIH0pIDogaXNSZWNvcmQodmFsdWUpID8gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoKFtrLCB2XSkgPT4gW2ssIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChrKSldKVxuICApIDogbWFwcGluZ0ZuKHZhbHVlLCBwYXRoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUludG9SZXN1bHQocmVzdWx0LCBjc20sIGVuY29kZXIpIHtcbiAgcmV0dXJuIHdhbGtNYXAocmVzdWx0LCAodmFsdWUsIHBhdGgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgcmVzb2x2ZU1hcHBpbmdSZXN1bHQgPSByZXNvbHZlTWFwcGluZyhwYXRoLCBjc20pO1xuICAgIGlmICghcmVzb2x2ZU1hcHBpbmdSZXN1bHQpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgeyBtYXBwaW5nLCBtYXRjaGVkUGF0aCB9ID0gcmVzb2x2ZU1hcHBpbmdSZXN1bHQ7XG4gICAgaWYgKG1hcHBpbmcudHlwZSAhPT0gXCJ2YWx1ZVwiIHx8IG1hcHBpbmcuc291cmNlLnR5cGUgIT09IFwiZG9jdW1lbnRWYWx1ZVwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHNvdXJjZURvY3VtZW50ID0gY3NtLmRvY3VtZW50c1ttYXBwaW5nLnNvdXJjZS5kb2N1bWVudF0sIHNvdXJjZVBhdGggPSBjc20ucGF0aHNbbWFwcGluZy5zb3VyY2UucGF0aF0sIG1hdGNoUGF0aFNlZ21lbnRzID0gcGFyc2VKc29uUGF0aChtYXRjaGVkUGF0aCksIGZ1bGxTb3VyY2VTZWdtZW50cyA9IHBhcnNlSnNvblBhdGgoc291cmNlUGF0aCkuY29uY2F0KHBhdGguc2xpY2UobWF0Y2hQYXRoU2VnbWVudHMubGVuZ3RoKSk7XG4gICAgcmV0dXJuIGVuY29kZXIoe1xuICAgICAgc291cmNlUGF0aDogZnVsbFNvdXJjZVNlZ21lbnRzLFxuICAgICAgc291cmNlRG9jdW1lbnQsXG4gICAgICByZXN1bHRQYXRoOiBwYXRoLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBEUkFGVFNfUFJFRklYID0gXCJkcmFmdHMuXCI7XG5mdW5jdGlvbiBnZXRQdWJsaXNoZWRJZChpZCkge1xuICByZXR1cm4gaWQuc3RhcnRzV2l0aChEUkFGVFNfUFJFRklYKSA/IGlkLnNsaWNlKERSQUZUU19QUkVGSVgubGVuZ3RoKSA6IGlkO1xufVxuZnVuY3Rpb24gY3JlYXRlRWRpdFVybChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBiYXNlVXJsLFxuICAgIHdvcmtzcGFjZTogX3dvcmtzcGFjZSA9IFwiZGVmYXVsdFwiLFxuICAgIHRvb2w6IF90b29sID0gXCJkZWZhdWx0XCIsXG4gICAgaWQ6IF9pZCxcbiAgICB0eXBlLFxuICAgIHBhdGgsXG4gICAgcHJvamVjdElkLFxuICAgIGRhdGFzZXRcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghYmFzZVVybClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYXNlVXJsIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoIXBhdGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGF0aCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFfaWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaWQgaXMgcmVxdWlyZWRcIik7XG4gIGlmIChiYXNlVXJsICE9PSBcIi9cIiAmJiBiYXNlVXJsLmVuZHNXaXRoKFwiL1wiKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYXNlVXJsIG11c3Qgbm90IGVuZCB3aXRoIGEgc2xhc2hcIik7XG4gIGNvbnN0IHdvcmtzcGFjZSA9IF93b3Jrc3BhY2UgPT09IFwiZGVmYXVsdFwiID8gdm9pZCAwIDogX3dvcmtzcGFjZSwgdG9vbCA9IF90b29sID09PSBcImRlZmF1bHRcIiA/IHZvaWQgMCA6IF90b29sLCBpZCA9IGdldFB1Ymxpc2hlZElkKF9pZCksIHN0cmluZ2lmaWVkUGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyB0b1N0cmluZyhqc29uUGF0aFRvU3R1ZGlvUGF0aChwYXRoKSkgOiBwYXRoLCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICBiYXNlVXJsLFxuICAgIGlkLFxuICAgIHR5cGUsXG4gICAgcGF0aDogc3RyaW5naWZpZWRQYXRoXG4gIH0pO1xuICB3b3Jrc3BhY2UgJiYgc2VhcmNoUGFyYW1zLnNldChcIndvcmtzcGFjZVwiLCB3b3Jrc3BhY2UpLCB0b29sICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJ0b29sXCIsIHRvb2wpLCBwcm9qZWN0SWQgJiYgc2VhcmNoUGFyYW1zLnNldChcInByb2plY3RJZFwiLCBwcm9qZWN0SWQpLCBkYXRhc2V0ICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJkYXRhc2V0XCIsIGRhdGFzZXQpO1xuICBjb25zdCBzZWdtZW50cyA9IFtiYXNlVXJsID09PSBcIi9cIiA/IFwiXCIgOiBiYXNlVXJsXTtcbiAgd29ya3NwYWNlICYmIHNlZ21lbnRzLnB1c2god29ya3NwYWNlKTtcbiAgY29uc3Qgcm91dGVyUGFyYW1zID0gW1xuICAgIFwibW9kZT1wcmVzZW50YXRpb25cIixcbiAgICBgaWQ9JHtpZH1gLFxuICAgIGB0eXBlPSR7dHlwZX1gLFxuICAgIGBwYXRoPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmaWVkUGF0aCl9YFxuICBdO1xuICByZXR1cm4gdG9vbCAmJiByb3V0ZXJQYXJhbXMucHVzaChgdG9vbD0ke3Rvb2x9YCksIHNlZ21lbnRzLnB1c2goXCJpbnRlbnRcIiwgXCJlZGl0XCIsIGAke3JvdXRlclBhcmFtcy5qb2luKFwiO1wiKX0/JHtzZWFyY2hQYXJhbXN9YCksIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVN0dWRpb0Jhc2VSb3V0ZShzdHVkaW9VcmwpIHtcbiAgbGV0IGJhc2VVcmwgPSB0eXBlb2Ygc3R1ZGlvVXJsID09IFwic3RyaW5nXCIgPyBzdHVkaW9VcmwgOiBzdHVkaW9VcmwuYmFzZVVybDtcbiAgcmV0dXJuIGJhc2VVcmwgIT09IFwiL1wiICYmIChiYXNlVXJsID0gYmFzZVVybC5yZXBsYWNlKC9cXC8kLywgXCJcIikpLCB0eXBlb2Ygc3R1ZGlvVXJsID09IFwic3RyaW5nXCIgPyB7IGJhc2VVcmwgfSA6IHsgLi4uc3R1ZGlvVXJsLCBiYXNlVXJsIH07XG59XG5jb25zdCBmaWx0ZXJEZWZhdWx0ID0gKHsgc291cmNlUGF0aCwgdmFsdWUgfSkgPT4ge1xuICBpZiAoaXNWYWxpZERhdGUodmFsdWUpIHx8IGlzVmFsaWRVUkwodmFsdWUpKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgZW5kUGF0aCA9IHNvdXJjZVBhdGguYXQoLTEpO1xuICByZXR1cm4gIShzb3VyY2VQYXRoLmF0KC0yKSA9PT0gXCJzbHVnXCIgJiYgZW5kUGF0aCA9PT0gXCJjdXJyZW50XCIgfHwgdHlwZW9mIGVuZFBhdGggPT0gXCJzdHJpbmdcIiAmJiBlbmRQYXRoLnN0YXJ0c1dpdGgoXCJfXCIpIHx8IHR5cGVvZiBlbmRQYXRoID09IFwibnVtYmVyXCIgJiYgc291cmNlUGF0aC5hdCgtMikgPT09IFwibWFya3NcIiB8fCBlbmRQYXRoID09PSBcImhyZWZcIiAmJiB0eXBlb2Ygc291cmNlUGF0aC5hdCgtMikgPT0gXCJudW1iZXJcIiAmJiBzb3VyY2VQYXRoLmF0KC0zKSA9PT0gXCJtYXJrRGVmc1wiIHx8IGVuZFBhdGggPT09IFwic3R5bGVcIiB8fCBlbmRQYXRoID09PSBcImxpc3RJdGVtXCIgfHwgc291cmNlUGF0aC5zb21lKFxuICAgIChwYXRoKSA9PiBwYXRoID09PSBcIm1ldGFcIiB8fCBwYXRoID09PSBcIm1ldGFkYXRhXCIgfHwgcGF0aCA9PT0gXCJvcGVuR3JhcGhcIiB8fCBwYXRoID09PSBcInNlb1wiXG4gICkgfHwgdHlwZW9mIGVuZFBhdGggPT0gXCJzdHJpbmdcIiAmJiBkZW55bGlzdC5oYXMoZW5kUGF0aCkpO1xufSwgZGVueWxpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY29sb3JcIixcbiAgXCJjb2xvdXJcIixcbiAgXCJjdXJyZW5jeVwiLFxuICBcImVtYWlsXCIsXG4gIFwiZm9ybWF0XCIsXG4gIFwiZ2lkXCIsXG4gIFwiaGV4XCIsXG4gIFwiaHJlZlwiLFxuICBcImhzbFwiLFxuICBcImhzbGFcIixcbiAgXCJpY29uXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImtleVwiLFxuICBcImxhbmd1YWdlXCIsXG4gIFwibGF5b3V0XCIsXG4gIFwibGlua1wiLFxuICBcImxpbmtBY3Rpb25cIixcbiAgXCJsb2NhbGVcIixcbiAgXCJscWlwXCIsXG4gIFwicGFnZVwiLFxuICBcInBhdGhcIixcbiAgXCJyZWZcIixcbiAgXCJyZ2JcIixcbiAgXCJyZ2JhXCIsXG4gIFwicm91dGVcIixcbiAgXCJzZWNyZXRcIixcbiAgXCJzbHVnXCIsXG4gIFwic3RhdHVzXCIsXG4gIFwidGFnXCIsXG4gIFwidGVtcGxhdGVcIixcbiAgXCJ0aGVtZVwiLFxuICBcInR5cGVcIixcbiAgXCJ1bml0XCIsXG4gIFwidXJsXCIsXG4gIFwidXNlcm5hbWVcIixcbiAgXCJ2YXJpYW50XCIsXG4gIFwid2Vic2l0ZVwiXG5dKTtcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKGRhdGVTdHJpbmcpIHtcbiAgcmV0dXJuIC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3QoZGF0ZVN0cmluZykgPyAhIURhdGUucGFyc2UoZGF0ZVN0cmluZykgOiAhMTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRVUkwodXJsKSB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh1cmwsIHVybC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiaHR0cHM6Ly9hY21lLmNvbVwiIDogdm9pZCAwKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmNvbnN0IFRSVU5DQVRFX0xFTkdUSCA9IDIwO1xuZnVuY3Rpb24gc3RlZ2FFbmNvZGVTb3VyY2VNYXAocmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZykge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaTtcbiAgY29uc3QgeyBmaWx0ZXIsIGxvZ2dlciwgZW5hYmxlZCB9ID0gY29uZmlnO1xuICBpZiAoIWVuYWJsZWQpIHtcbiAgICBjb25zdCBtc2cgPSBcImNvbmZpZy5lbmFibGVkIG11c3QgYmUgdHJ1ZSwgZG9uJ3QgY2FsbCB0aGlzIGZ1bmN0aW9uIG90aGVyd2lzZVwiO1xuICAgIHRocm93IChfYSA9IGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmVycm9yKSA9PSBudWxsIHx8IF9hLmNhbGwobG9nZ2VyLCBgW0BzYW5pdHkvY2xpZW50XTogJHttc2d9YCwgeyByZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgY29uZmlnIH0pLCBuZXcgVHlwZUVycm9yKG1zZyk7XG4gIH1cbiAgaWYgKCFyZXN1bHRTb3VyY2VNYXApXG4gICAgcmV0dXJuIChfYiA9IGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmVycm9yKSA9PSBudWxsIHx8IF9iLmNhbGwobG9nZ2VyLCBcIltAc2FuaXR5L2NsaWVudF06IE1pc3NpbmcgQ29udGVudCBTb3VyY2UgTWFwIGZyb20gcmVzcG9uc2UgYm9keVwiLCB7XG4gICAgICByZXN1bHQsXG4gICAgICByZXN1bHRTb3VyY2VNYXAsXG4gICAgICBjb25maWdcbiAgICB9KSwgcmVzdWx0O1xuICBpZiAoIWNvbmZpZy5zdHVkaW9VcmwpIHtcbiAgICBjb25zdCBtc2cgPSBcImNvbmZpZy5zdHVkaW9VcmwgbXVzdCBiZSBkZWZpbmVkXCI7XG4gICAgdGhyb3cgKF9jID0gbG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIuZXJyb3IpID09IG51bGwgfHwgX2MuY2FsbChsb2dnZXIsIGBbQHNhbml0eS9jbGllbnRdOiAke21zZ31gLCB7IHJlc3VsdCwgcmVzdWx0U291cmNlTWFwLCBjb25maWcgfSksIG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgfVxuICBjb25zdCByZXBvcnQgPSB7XG4gICAgZW5jb2RlZDogW10sXG4gICAgc2tpcHBlZDogW11cbiAgfSwgcmVzdWx0V2l0aFN0ZWdhID0gZW5jb2RlSW50b1Jlc3VsdChcbiAgICByZXN1bHQsXG4gICAgcmVzdWx0U291cmNlTWFwLFxuICAgICh7IHNvdXJjZVBhdGgsIHNvdXJjZURvY3VtZW50LCByZXN1bHRQYXRoLCB2YWx1ZSB9KSA9PiB7XG4gICAgICBpZiAoKHR5cGVvZiBmaWx0ZXIgPT0gXCJmdW5jdGlvblwiID8gZmlsdGVyKHsgc291cmNlUGF0aCwgcmVzdWx0UGF0aCwgZmlsdGVyRGVmYXVsdCwgc291cmNlRG9jdW1lbnQsIHZhbHVlIH0pIDogZmlsdGVyRGVmYXVsdCh7IHNvdXJjZVBhdGgsIHJlc3VsdFBhdGgsIGZpbHRlckRlZmF1bHQsIHNvdXJjZURvY3VtZW50LCB2YWx1ZSB9KSkgPT09ICExKVxuICAgICAgICByZXR1cm4gbG9nZ2VyICYmIHJlcG9ydC5za2lwcGVkLnB1c2goe1xuICAgICAgICAgIHBhdGg6IHByZXR0eVBhdGhGb3JMb2dnaW5nKHNvdXJjZVBhdGgpLFxuICAgICAgICAgIHZhbHVlOiBgJHt2YWx1ZS5zbGljZSgwLCBUUlVOQ0FURV9MRU5HVEgpfSR7dmFsdWUubGVuZ3RoID4gVFJVTkNBVEVfTEVOR1RIID8gXCIuLi5cIiA6IFwiXCJ9YCxcbiAgICAgICAgICBsZW5ndGg6IHZhbHVlLmxlbmd0aFxuICAgICAgICB9KSwgdmFsdWU7XG4gICAgICBsb2dnZXIgJiYgcmVwb3J0LmVuY29kZWQucHVzaCh7XG4gICAgICAgIHBhdGg6IHByZXR0eVBhdGhGb3JMb2dnaW5nKHNvdXJjZVBhdGgpLFxuICAgICAgICB2YWx1ZTogYCR7dmFsdWUuc2xpY2UoMCwgVFJVTkNBVEVfTEVOR1RIKX0ke3ZhbHVlLmxlbmd0aCA+IFRSVU5DQVRFX0xFTkdUSCA/IFwiLi4uXCIgOiBcIlwifWAsXG4gICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHsgYmFzZVVybCwgd29ya3NwYWNlLCB0b29sIH0gPSByZXNvbHZlU3R1ZGlvQmFzZVJvdXRlKFxuICAgICAgICB0eXBlb2YgY29uZmlnLnN0dWRpb1VybCA9PSBcImZ1bmN0aW9uXCIgPyBjb25maWcuc3R1ZGlvVXJsKHNvdXJjZURvY3VtZW50KSA6IGNvbmZpZy5zdHVkaW9VcmxcbiAgICAgICk7XG4gICAgICBpZiAoIWJhc2VVcmwpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIGNvbnN0IHsgX2lkOiBpZCwgX3R5cGU6IHR5cGUsIF9wcm9qZWN0SWQ6IHByb2plY3RJZCwgX2RhdGFzZXQ6IGRhdGFzZXQgfSA9IHNvdXJjZURvY3VtZW50O1xuICAgICAgcmV0dXJuIGIoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB7XG4gICAgICAgICAgb3JpZ2luOiBcInNhbml0eS5pb1wiLFxuICAgICAgICAgIGhyZWY6IGNyZWF0ZUVkaXRVcmwoe1xuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIHdvcmtzcGFjZSxcbiAgICAgICAgICAgIHRvb2wsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwYXRoOiBzb3VyY2VQYXRoLFxuICAgICAgICAgICAgLi4uIWNvbmZpZy5vbWl0Q3Jvc3NEYXRhc2V0UmVmZXJlbmNlRGF0YSAmJiB7IGRhdGFzZXQsIHByb2plY3RJZCB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLy8gV2UgdXNlIGN1c3RvbSBsb2dpYyB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHNraXAgZW5jb2RpbmdcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgfVxuICApO1xuICBpZiAobG9nZ2VyKSB7XG4gICAgY29uc3QgaXNTa2lwcGluZyA9IHJlcG9ydC5za2lwcGVkLmxlbmd0aCwgaXNFbmNvZGluZyA9IHJlcG9ydC5lbmNvZGVkLmxlbmd0aDtcbiAgICBpZiAoKGlzU2tpcHBpbmcgfHwgaXNFbmNvZGluZykgJiYgKChfZCA9IChsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5ncm91cENvbGxhcHNlZCkgfHwgbG9nZ2VyLmxvZykgPT0gbnVsbCB8fCBfZChcIltAc2FuaXR5L2NsaWVudF06IEVuY29kaW5nIHNvdXJjZSBtYXAgaW50byByZXN1bHRcIiksIChfZSA9IGxvZ2dlci5sb2cpID09IG51bGwgfHwgX2UuY2FsbChcbiAgICAgIGxvZ2dlcixcbiAgICAgIGBbQHNhbml0eS9jbGllbnRdOiBQYXRocyBlbmNvZGVkOiAke3JlcG9ydC5lbmNvZGVkLmxlbmd0aH0sIHNraXBwZWQ6ICR7cmVwb3J0LnNraXBwZWQubGVuZ3RofWBcbiAgICApKSwgcmVwb3J0LmVuY29kZWQubGVuZ3RoID4gMCAmJiAoKF9mID0gbG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIubG9nKSA9PSBudWxsIHx8IF9mLmNhbGwobG9nZ2VyLCBcIltAc2FuaXR5L2NsaWVudF06IFRhYmxlIG9mIGVuY29kZWQgcGF0aHNcIiksIChfZyA9IChsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci50YWJsZSkgfHwgbG9nZ2VyLmxvZykgPT0gbnVsbCB8fCBfZyhyZXBvcnQuZW5jb2RlZCkpLCByZXBvcnQuc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBza2lwcGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgeyBwYXRoIH0gb2YgcmVwb3J0LnNraXBwZWQpXG4gICAgICAgIHNraXBwZWQuYWRkKHBhdGgucmVwbGFjZShyZUtleVNlZ21lbnQsIFwiMFwiKS5yZXBsYWNlKC9cXFtcXGQrXFxdL2csIFwiW11cIikpO1xuICAgICAgKF9oID0gbG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIubG9nKSA9PSBudWxsIHx8IF9oLmNhbGwobG9nZ2VyLCBcIltAc2FuaXR5L2NsaWVudF06IExpc3Qgb2Ygc2tpcHBlZCBwYXRoc1wiLCBbLi4uc2tpcHBlZC52YWx1ZXMoKV0pO1xuICAgIH1cbiAgICAoaXNTa2lwcGluZyB8fCBpc0VuY29kaW5nKSAmJiAoKF9pID0gbG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIuZ3JvdXBFbmQpID09IG51bGwgfHwgX2kuY2FsbChsb2dnZXIpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0V2l0aFN0ZWdhO1xufVxuZnVuY3Rpb24gcHJldHR5UGF0aEZvckxvZ2dpbmcocGF0aCkge1xuICByZXR1cm4gdG9TdHJpbmcoanNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkpO1xufVxudmFyIHN0ZWdhRW5jb2RlU291cmNlTWFwJDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc3RlZ2FFbmNvZGVTb3VyY2VNYXBcbn0pO1xuZXhwb3J0IHtcbiAgZW5jb2RlSW50b1Jlc3VsdCxcbiAgc3RlZ2FFbmNvZGVTb3VyY2VNYXAsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwJDFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGVnYUVuY29kZVNvdXJjZU1hcC1EZTNGX29KTi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJiIiwicmVLZXlTZWdtZW50IiwiaXNLZXlTZWdtZW50Iiwic2VnbWVudCIsInRlc3QiLCJ0cmltIiwidG9TdHJpbmciLCJwYXRoIiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJyZWR1Y2UiLCJ0YXJnZXQiLCJpIiwic2VnbWVudFR5cGUiLCJfa2V5IiwiZnJvbSIsInRvIiwiSlNPTiIsInN0cmluZ2lmeSIsIkVTQ0FQRSIsIlVORVNDQVBFIiwianNvblBhdGgiLCJtYXAiLCJyZXBsYWNlIiwibWF0Y2giLCJfaW5kZXgiLCJqb2luIiwicGFyc2VKc29uUGF0aCIsInBhcnNlZCIsInBhcnNlUmUiLCJleGVjIiwia2V5IiwibSIsInB1c2giLCJwYXJzZUludCIsImpzb25QYXRoVG9TdHVkaW9QYXRoIiwianNvblBhdGhUb01hcHBpbmdQYXRoIiwicmVzb2x2ZU1hcHBpbmciLCJyZXN1bHRQYXRoIiwiY3NtIiwibWFwcGluZ3MiLCJyZXN1bHRNYXBwaW5nUGF0aCIsIm1hcHBpbmciLCJtYXRjaGVkUGF0aCIsInBhdGhTdWZmaXgiLCJPYmplY3QiLCJlbnRyaWVzIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsInNvcnQiLCJrZXkxIiwia2V5MiIsImxlbmd0aCIsInN1YnN0cmluZyIsInZhbHVlIiwiaXNSZWNvcmQiLCJ3YWxrTWFwIiwibWFwcGluZ0ZuIiwidiIsImlkeCIsImNvbmNhdCIsImZyb21FbnRyaWVzIiwiayIsImVuY29kZUludG9SZXN1bHQiLCJyZXN1bHQiLCJlbmNvZGVyIiwicmVzb2x2ZU1hcHBpbmdSZXN1bHQiLCJ0eXBlIiwic291cmNlIiwic291cmNlRG9jdW1lbnQiLCJkb2N1bWVudHMiLCJkb2N1bWVudCIsInNvdXJjZVBhdGgiLCJwYXRocyIsIm1hdGNoUGF0aFNlZ21lbnRzIiwiZnVsbFNvdXJjZVNlZ21lbnRzIiwic2xpY2UiLCJEUkFGVFNfUFJFRklYIiwiZ2V0UHVibGlzaGVkSWQiLCJpZCIsImNyZWF0ZUVkaXRVcmwiLCJvcHRpb25zIiwiYmFzZVVybCIsIndvcmtzcGFjZSIsIl93b3Jrc3BhY2UiLCJ0b29sIiwiX3Rvb2wiLCJfaWQiLCJwcm9qZWN0SWQiLCJkYXRhc2V0IiwiZW5kc1dpdGgiLCJzdHJpbmdpZmllZFBhdGgiLCJzZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZXQiLCJzZWdtZW50cyIsInJvdXRlclBhcmFtcyIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlc29sdmVTdHVkaW9CYXNlUm91dGUiLCJzdHVkaW9VcmwiLCJmaWx0ZXJEZWZhdWx0IiwiaXNWYWxpZERhdGUiLCJpc1ZhbGlkVVJMIiwiZW5kUGF0aCIsImF0Iiwic29tZSIsImRlbnlsaXN0IiwiaGFzIiwiU2V0IiwiZGF0ZVN0cmluZyIsIkRhdGUiLCJwYXJzZSIsInVybCIsIlVSTCIsIlRSVU5DQVRFX0xFTkdUSCIsInN0ZWdhRW5jb2RlU291cmNlTWFwIiwicmVzdWx0U291cmNlTWFwIiwiY29uZmlnIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9pIiwibG9nZ2VyIiwiZW5hYmxlZCIsIm1zZyIsImVycm9yIiwiY2FsbCIsIlR5cGVFcnJvciIsInJlcG9ydCIsImVuY29kZWQiLCJza2lwcGVkIiwicmVzdWx0V2l0aFN0ZWdhIiwicHJldHR5UGF0aEZvckxvZ2dpbmciLCJfdHlwZSIsIl9wcm9qZWN0SWQiLCJfZGF0YXNldCIsIm9yaWdpbiIsImhyZWYiLCJvbWl0Q3Jvc3NEYXRhc2V0UmVmZXJlbmNlRGF0YSIsImlzU2tpcHBpbmciLCJpc0VuY29kaW5nIiwiZ3JvdXBDb2xsYXBzZWQiLCJsb2ciLCJ0YWJsZSIsImFkZCIsInZhbHVlcyIsImdyb3VwRW5kIiwic3RlZ2FFbmNvZGVTb3VyY2VNYXAkMSIsImZyZWV6ZSIsIl9fcHJvdG9fXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks/stegaEncodeSourceMap-De3F_oJN.js\n"));

/***/ })

}]);