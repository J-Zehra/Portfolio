"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_sanity_eventsource_browser_js"],{

/***/ "(app-pages-browser)/./node_modules/event-source-polyfill/src/eventsource.js":
/*!***************************************************************!*\
  !*** ./node_modules/event-source-polyfill/src/eventsource.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/** @license\r\n * eventsource.js\r\n * Available under MIT License (MIT)\r\n * https://github.com/Yaffle/EventSource/\r\n */ /*jslint indent: 2, vars: true, plusplus: true */ /*global setTimeout, clearTimeout */ (function(global) {\n    \"use strict\";\n    var setTimeout = global.setTimeout;\n    var clearTimeout = global.clearTimeout;\n    var XMLHttpRequest = global.XMLHttpRequest;\n    var XDomainRequest = global.XDomainRequest;\n    var ActiveXObject = global.ActiveXObject;\n    var NativeEventSource = global.EventSource;\n    var document = global.document;\n    var Promise = global.Promise;\n    var fetch = global.fetch;\n    var Response = global.Response;\n    var TextDecoder = global.TextDecoder;\n    var TextEncoder = global.TextEncoder;\n    var AbortController = global.AbortController;\n    if ( true && typeof document !== \"undefined\" && !(\"readyState\" in document) && document.body == null) {\n        document.readyState = \"loading\";\n        window.addEventListener(\"load\", function(event) {\n            document.readyState = \"complete\";\n        }, false);\n    }\n    if (XMLHttpRequest == null && ActiveXObject != null) {\n        XMLHttpRequest = function() {\n            return new ActiveXObject(\"Microsoft.XMLHTTP\");\n        };\n    }\n    if (Object.create == undefined) {\n        Object.create = function(C) {\n            function F() {}\n            F.prototype = C;\n            return new F();\n        };\n    }\n    if (!Date.now) {\n        Date.now = function now() {\n            return new Date().getTime();\n        };\n    }\n    // see #118 (Promise#finally with polyfilled Promise)\n    // see #123 (data URLs crash Edge)\n    // see #125 (CSP violations)\n    // see pull/#138\n    // => No way to polyfill Promise#finally\n    if (AbortController == undefined) {\n        var originalFetch2 = fetch;\n        fetch = function(url, options) {\n            var signal = options.signal;\n            return originalFetch2(url, {\n                headers: options.headers,\n                credentials: options.credentials,\n                cache: options.cache\n            }).then(function(response) {\n                var reader = response.body.getReader();\n                signal._reader = reader;\n                if (signal._aborted) {\n                    signal._reader.cancel();\n                }\n                return {\n                    status: response.status,\n                    statusText: response.statusText,\n                    headers: response.headers,\n                    body: {\n                        getReader: function() {\n                            return reader;\n                        }\n                    }\n                };\n            });\n        };\n        AbortController = function() {\n            this.signal = {\n                _reader: null,\n                _aborted: false\n            };\n            this.abort = function() {\n                if (this.signal._reader != null) {\n                    this.signal._reader.cancel();\n                }\n                this.signal._aborted = true;\n            };\n        };\n    }\n    function TextDecoderPolyfill() {\n        this.bitsNeeded = 0;\n        this.codePoint = 0;\n    }\n    TextDecoderPolyfill.prototype.decode = function(octets) {\n        function valid(codePoint, shift, octetsCount) {\n            if (octetsCount === 1) {\n                return codePoint >= 0x0080 >> shift && codePoint << shift <= 0x07FF;\n            }\n            if (octetsCount === 2) {\n                return codePoint >= 0x0800 >> shift && codePoint << shift <= 0xD7FF || codePoint >= 0xE000 >> shift && codePoint << shift <= 0xFFFF;\n            }\n            if (octetsCount === 3) {\n                return codePoint >= 0x010000 >> shift && codePoint << shift <= 0x10FFFF;\n            }\n            throw new Error();\n        }\n        function octetsCount(bitsNeeded, codePoint) {\n            if (bitsNeeded === 6 * 1) {\n                return codePoint >> 6 > 15 ? 3 : codePoint > 31 ? 2 : 1;\n            }\n            if (bitsNeeded === 6 * 2) {\n                return codePoint > 15 ? 3 : 2;\n            }\n            if (bitsNeeded === 6 * 3) {\n                return 3;\n            }\n            throw new Error();\n        }\n        var REPLACER = 0xFFFD;\n        var string = \"\";\n        var bitsNeeded = this.bitsNeeded;\n        var codePoint = this.codePoint;\n        for(var i = 0; i < octets.length; i += 1){\n            var octet = octets[i];\n            if (bitsNeeded !== 0) {\n                if (octet < 128 || octet > 191 || !valid(codePoint << 6 | octet & 63, bitsNeeded - 6, octetsCount(bitsNeeded, codePoint))) {\n                    bitsNeeded = 0;\n                    codePoint = REPLACER;\n                    string += String.fromCharCode(codePoint);\n                }\n            }\n            if (bitsNeeded === 0) {\n                if (octet >= 0 && octet <= 127) {\n                    bitsNeeded = 0;\n                    codePoint = octet;\n                } else if (octet >= 192 && octet <= 223) {\n                    bitsNeeded = 6 * 1;\n                    codePoint = octet & 31;\n                } else if (octet >= 224 && octet <= 239) {\n                    bitsNeeded = 6 * 2;\n                    codePoint = octet & 15;\n                } else if (octet >= 240 && octet <= 247) {\n                    bitsNeeded = 6 * 3;\n                    codePoint = octet & 7;\n                } else {\n                    bitsNeeded = 0;\n                    codePoint = REPLACER;\n                }\n                if (bitsNeeded !== 0 && !valid(codePoint, bitsNeeded, octetsCount(bitsNeeded, codePoint))) {\n                    bitsNeeded = 0;\n                    codePoint = REPLACER;\n                }\n            } else {\n                bitsNeeded -= 6;\n                codePoint = codePoint << 6 | octet & 63;\n            }\n            if (bitsNeeded === 0) {\n                if (codePoint <= 0xFFFF) {\n                    string += String.fromCharCode(codePoint);\n                } else {\n                    string += String.fromCharCode(0xD800 + (codePoint - 0xFFFF - 1 >> 10));\n                    string += String.fromCharCode(0xDC00 + (codePoint - 0xFFFF - 1 & 0x3FF));\n                }\n            }\n        }\n        this.bitsNeeded = bitsNeeded;\n        this.codePoint = codePoint;\n        return string;\n    };\n    // Firefox < 38 throws an error with stream option\n    var supportsStreamOption = function() {\n        try {\n            return new TextDecoder().decode(new TextEncoder().encode(\"test\"), {\n                stream: true\n            }) === \"test\";\n        } catch (error) {\n            console.debug(\"TextDecoder does not support streaming option. Using polyfill instead: \" + error);\n        }\n        return false;\n    };\n    // IE, Edge\n    if (TextDecoder == undefined || TextEncoder == undefined || !supportsStreamOption()) {\n        TextDecoder = TextDecoderPolyfill;\n    }\n    var k = function() {};\n    function XHRWrapper(xhr) {\n        this.withCredentials = false;\n        this.readyState = 0;\n        this.status = 0;\n        this.statusText = \"\";\n        this.responseText = \"\";\n        this.onprogress = k;\n        this.onload = k;\n        this.onerror = k;\n        this.onreadystatechange = k;\n        this._contentType = \"\";\n        this._xhr = xhr;\n        this._sendTimeout = 0;\n        this._abort = k;\n    }\n    XHRWrapper.prototype.open = function(method, url) {\n        this._abort(true);\n        var that = this;\n        var xhr = this._xhr;\n        var state = 1;\n        var timeout = 0;\n        this._abort = function(silent) {\n            if (that._sendTimeout !== 0) {\n                clearTimeout(that._sendTimeout);\n                that._sendTimeout = 0;\n            }\n            if (state === 1 || state === 2 || state === 3) {\n                state = 4;\n                xhr.onload = k;\n                xhr.onerror = k;\n                xhr.onabort = k;\n                xhr.onprogress = k;\n                xhr.onreadystatechange = k;\n                // IE 8 - 9: XDomainRequest#abort() does not fire any event\n                // Opera < 10: XMLHttpRequest#abort() does not fire any event\n                xhr.abort();\n                if (timeout !== 0) {\n                    clearTimeout(timeout);\n                    timeout = 0;\n                }\n                if (!silent) {\n                    that.readyState = 4;\n                    that.onabort(null);\n                    that.onreadystatechange();\n                }\n            }\n            state = 0;\n        };\n        var onStart = function() {\n            if (state === 1) {\n                //state = 2;\n                var status = 0;\n                var statusText = \"\";\n                var contentType = undefined;\n                if (!(\"contentType\" in xhr)) {\n                    try {\n                        status = xhr.status;\n                        statusText = xhr.statusText;\n                        contentType = xhr.getResponseHeader(\"Content-Type\");\n                    } catch (error) {\n                        // IE < 10 throws exception for `xhr.status` when xhr.readyState === 2 || xhr.readyState === 3\n                        // Opera < 11 throws exception for `xhr.status` when xhr.readyState === 2\n                        // https://bugs.webkit.org/show_bug.cgi?id=29121\n                        status = 0;\n                        statusText = \"\";\n                        contentType = undefined;\n                    // Firefox < 14, Chrome ?, Safari ?\n                    // https://bugs.webkit.org/show_bug.cgi?id=29658\n                    // https://bugs.webkit.org/show_bug.cgi?id=77854\n                    }\n                } else {\n                    status = 200;\n                    statusText = \"OK\";\n                    contentType = xhr.contentType;\n                }\n                if (status !== 0) {\n                    state = 2;\n                    that.readyState = 2;\n                    that.status = status;\n                    that.statusText = statusText;\n                    that._contentType = contentType;\n                    that.onreadystatechange();\n                }\n            }\n        };\n        var onProgress = function() {\n            onStart();\n            if (state === 2 || state === 3) {\n                state = 3;\n                var responseText = \"\";\n                try {\n                    responseText = xhr.responseText;\n                } catch (error) {\n                // IE 8 - 9 with XMLHttpRequest\n                }\n                that.readyState = 3;\n                that.responseText = responseText;\n                that.onprogress();\n            }\n        };\n        var onFinish = function(type, event) {\n            if (event == null || event.preventDefault == null) {\n                event = {\n                    preventDefault: k\n                };\n            }\n            // Firefox 52 fires \"readystatechange\" (xhr.readyState === 4) without final \"readystatechange\" (xhr.readyState === 3)\n            // IE 8 fires \"onload\" without \"onprogress\"\n            onProgress();\n            if (state === 1 || state === 2 || state === 3) {\n                state = 4;\n                if (timeout !== 0) {\n                    clearTimeout(timeout);\n                    timeout = 0;\n                }\n                that.readyState = 4;\n                if (type === \"load\") {\n                    that.onload(event);\n                } else if (type === \"error\") {\n                    that.onerror(event);\n                } else if (type === \"abort\") {\n                    that.onabort(event);\n                } else {\n                    throw new TypeError();\n                }\n                that.onreadystatechange();\n            }\n        };\n        var onReadyStateChange = function(event) {\n            if (xhr != undefined) {\n                if (xhr.readyState === 4) {\n                    if (!(\"onload\" in xhr) || !(\"onerror\" in xhr) || !(\"onabort\" in xhr)) {\n                        onFinish(xhr.responseText === \"\" ? \"error\" : \"load\", event);\n                    }\n                } else if (xhr.readyState === 3) {\n                    if (!(\"onprogress\" in xhr)) {\n                        // and in Firefox 3.6\n                        onProgress();\n                    }\n                } else if (xhr.readyState === 2) {\n                    onStart();\n                }\n            }\n        };\n        var onTimeout = function() {\n            timeout = setTimeout(function() {\n                onTimeout();\n            }, 500);\n            if (xhr.readyState === 3) {\n                onProgress();\n            }\n        };\n        // XDomainRequest#abort removes onprogress, onerror, onload\n        if (\"onload\" in xhr) {\n            xhr.onload = function(event) {\n                onFinish(\"load\", event);\n            };\n        }\n        if (\"onerror\" in xhr) {\n            xhr.onerror = function(event) {\n                onFinish(\"error\", event);\n            };\n        }\n        // improper fix to match Firefox behaviour, but it is better than just ignore abort\n        // see https://bugzilla.mozilla.org/show_bug.cgi?id=768596\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=880200\n        // https://code.google.com/p/chromium/issues/detail?id=153570\n        // IE 8 fires \"onload\" without \"onprogress\n        if (\"onabort\" in xhr) {\n            xhr.onabort = function(event) {\n                onFinish(\"abort\", event);\n            };\n        }\n        if (\"onprogress\" in xhr) {\n            xhr.onprogress = onProgress;\n        }\n        // IE 8 - 9 (XMLHTTPRequest)\n        // Opera < 12\n        // Firefox < 3.5\n        // Firefox 3.5 - 3.6 - ? < 9.0\n        // onprogress is not fired sometimes or delayed\n        // see also #64 (significant lag in IE 11)\n        if (\"onreadystatechange\" in xhr) {\n            xhr.onreadystatechange = function(event) {\n                onReadyStateChange(event);\n            };\n        }\n        if (\"contentType\" in xhr || !(\"ontimeout\" in XMLHttpRequest.prototype)) {\n            url += (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + \"padding=true\";\n        }\n        xhr.open(method, url, true);\n        if (\"readyState\" in xhr) {\n            // workaround for Opera 12 issue with \"progress\" events\n            // #91 (XMLHttpRequest onprogress not fired for streaming response in Edge 14-15-?)\n            timeout = setTimeout(function() {\n                onTimeout();\n            }, 0);\n        }\n    };\n    XHRWrapper.prototype.abort = function() {\n        this._abort(false);\n    };\n    XHRWrapper.prototype.getResponseHeader = function(name) {\n        return this._contentType;\n    };\n    XHRWrapper.prototype.setRequestHeader = function(name, value) {\n        var xhr = this._xhr;\n        if (\"setRequestHeader\" in xhr) {\n            xhr.setRequestHeader(name, value);\n        }\n    };\n    XHRWrapper.prototype.getAllResponseHeaders = function() {\n        // XMLHttpRequest#getAllResponseHeaders returns null for CORS requests in Firefox 3.6.28\n        return this._xhr.getAllResponseHeaders != undefined ? this._xhr.getAllResponseHeaders() || \"\" : \"\";\n    };\n    XHRWrapper.prototype.send = function() {\n        // loading indicator in Safari < ? (6), Chrome < 14, Firefox\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=736723\n        if ((!(\"ontimeout\" in XMLHttpRequest.prototype) || !(\"sendAsBinary\" in XMLHttpRequest.prototype) && !(\"mozAnon\" in XMLHttpRequest.prototype)) && document != undefined && document.readyState != undefined && document.readyState !== \"complete\") {\n            var that = this;\n            that._sendTimeout = setTimeout(function() {\n                that._sendTimeout = 0;\n                that.send();\n            }, 4);\n            return;\n        }\n        var xhr = this._xhr;\n        // withCredentials should be set after \"open\" for Safari and Chrome (< 19 ?)\n        if (\"withCredentials\" in xhr) {\n            xhr.withCredentials = this.withCredentials;\n        }\n        try {\n            // xhr.send(); throws \"Not enough arguments\" in Firefox 3.0\n            xhr.send(undefined);\n        } catch (error1) {\n            // Safari 5.1.7, Opera 12\n            throw error1;\n        }\n    };\n    function toLowerCase(name) {\n        return name.replace(/[A-Z]/g, function(c) {\n            return String.fromCharCode(c.charCodeAt(0) + 0x20);\n        });\n    }\n    function HeadersPolyfill(all) {\n        // Get headers: implemented according to mozilla's example code: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders#Example\n        var map = Object.create(null);\n        var array = all.split(\"\\r\\n\");\n        for(var i = 0; i < array.length; i += 1){\n            var line = array[i];\n            var parts = line.split(\": \");\n            var name = parts.shift();\n            var value = parts.join(\": \");\n            map[toLowerCase(name)] = value;\n        }\n        this._map = map;\n    }\n    HeadersPolyfill.prototype.get = function(name) {\n        return this._map[toLowerCase(name)];\n    };\n    if (XMLHttpRequest != null && XMLHttpRequest.HEADERS_RECEIVED == null) {\n        XMLHttpRequest.HEADERS_RECEIVED = 2;\n    }\n    function XHRTransport() {}\n    XHRTransport.prototype.open = function(xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {\n        xhr.open(\"GET\", url);\n        var offset = 0;\n        xhr.onprogress = function() {\n            var responseText = xhr.responseText;\n            var chunk = responseText.slice(offset);\n            offset += chunk.length;\n            onProgressCallback(chunk);\n        };\n        xhr.onerror = function(event) {\n            event.preventDefault();\n            onFinishCallback(new Error(\"NetworkError\"));\n        };\n        xhr.onload = function() {\n            onFinishCallback(null);\n        };\n        xhr.onabort = function() {\n            onFinishCallback(null);\n        };\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n                var status = xhr.status;\n                var statusText = xhr.statusText;\n                var contentType = xhr.getResponseHeader(\"Content-Type\");\n                var headers = xhr.getAllResponseHeaders();\n                onStartCallback(status, statusText, contentType, new HeadersPolyfill(headers));\n            }\n        };\n        xhr.withCredentials = withCredentials;\n        for(var name in headers){\n            if (Object.prototype.hasOwnProperty.call(headers, name)) {\n                xhr.setRequestHeader(name, headers[name]);\n            }\n        }\n        xhr.send();\n        return xhr;\n    };\n    function HeadersWrapper(headers) {\n        this._headers = headers;\n    }\n    HeadersWrapper.prototype.get = function(name) {\n        return this._headers.get(name);\n    };\n    function FetchTransport() {}\n    FetchTransport.prototype.open = function(xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {\n        var reader = null;\n        var controller = new AbortController();\n        var signal = controller.signal;\n        var textDecoder = new TextDecoder();\n        fetch(url, {\n            headers: headers,\n            credentials: withCredentials ? \"include\" : \"same-origin\",\n            signal: signal,\n            cache: \"no-store\"\n        }).then(function(response) {\n            reader = response.body.getReader();\n            onStartCallback(response.status, response.statusText, response.headers.get(\"Content-Type\"), new HeadersWrapper(response.headers));\n            // see https://github.com/promises-aplus/promises-spec/issues/179\n            return new Promise(function(resolve, reject) {\n                var readNextChunk = function() {\n                    reader.read().then(function(result) {\n                        if (result.done) {\n                            //Note: bytes in textDecoder are ignored\n                            resolve(undefined);\n                        } else {\n                            var chunk = textDecoder.decode(result.value, {\n                                stream: true\n                            });\n                            onProgressCallback(chunk);\n                            readNextChunk();\n                        }\n                    })[\"catch\"](function(error) {\n                        reject(error);\n                    });\n                };\n                readNextChunk();\n            });\n        })[\"catch\"](function(error) {\n            if (error.name === \"AbortError\") {\n                return undefined;\n            } else {\n                return error;\n            }\n        }).then(function(error) {\n            onFinishCallback(error);\n        });\n        return {\n            abort: function() {\n                if (reader != null) {\n                    reader.cancel(); // https://bugzilla.mozilla.org/show_bug.cgi?id=1583815\n                }\n                controller.abort();\n            }\n        };\n    };\n    function EventTarget() {\n        this._listeners = Object.create(null);\n    }\n    function throwError(e) {\n        setTimeout(function() {\n            throw e;\n        }, 0);\n    }\n    EventTarget.prototype.dispatchEvent = function(event) {\n        event.target = this;\n        var typeListeners = this._listeners[event.type];\n        if (typeListeners != undefined) {\n            var length = typeListeners.length;\n            for(var i = 0; i < length; i += 1){\n                var listener = typeListeners[i];\n                try {\n                    if (typeof listener.handleEvent === \"function\") {\n                        listener.handleEvent(event);\n                    } else {\n                        listener.call(this, event);\n                    }\n                } catch (e) {\n                    throwError(e);\n                }\n            }\n        }\n    };\n    EventTarget.prototype.addEventListener = function(type, listener) {\n        type = String(type);\n        var listeners = this._listeners;\n        var typeListeners = listeners[type];\n        if (typeListeners == undefined) {\n            typeListeners = [];\n            listeners[type] = typeListeners;\n        }\n        var found = false;\n        for(var i = 0; i < typeListeners.length; i += 1){\n            if (typeListeners[i] === listener) {\n                found = true;\n            }\n        }\n        if (!found) {\n            typeListeners.push(listener);\n        }\n    };\n    EventTarget.prototype.removeEventListener = function(type, listener) {\n        type = String(type);\n        var listeners = this._listeners;\n        var typeListeners = listeners[type];\n        if (typeListeners != undefined) {\n            var filtered = [];\n            for(var i = 0; i < typeListeners.length; i += 1){\n                if (typeListeners[i] !== listener) {\n                    filtered.push(typeListeners[i]);\n                }\n            }\n            if (filtered.length === 0) {\n                delete listeners[type];\n            } else {\n                listeners[type] = filtered;\n            }\n        }\n    };\n    function Event(type) {\n        this.type = type;\n        this.target = undefined;\n    }\n    function MessageEvent(type, options) {\n        Event.call(this, type);\n        this.data = options.data;\n        this.lastEventId = options.lastEventId;\n    }\n    MessageEvent.prototype = Object.create(Event.prototype);\n    function ConnectionEvent(type, options) {\n        Event.call(this, type);\n        this.status = options.status;\n        this.statusText = options.statusText;\n        this.headers = options.headers;\n    }\n    ConnectionEvent.prototype = Object.create(Event.prototype);\n    function ErrorEvent(type, options) {\n        Event.call(this, type);\n        this.error = options.error;\n    }\n    ErrorEvent.prototype = Object.create(Event.prototype);\n    var WAITING = -1;\n    var CONNECTING = 0;\n    var OPEN = 1;\n    var CLOSED = 2;\n    var AFTER_CR = -1;\n    var FIELD_START = 0;\n    var FIELD = 1;\n    var VALUE_START = 2;\n    var VALUE = 3;\n    var contentTypeRegExp = /^text\\/event\\-stream(;.*)?$/i;\n    var MINIMUM_DURATION = 1000;\n    var MAXIMUM_DURATION = 18000000;\n    var parseDuration = function(value, def) {\n        var n = value == null ? def : parseInt(value, 10);\n        if (n !== n) {\n            n = def;\n        }\n        return clampDuration(n);\n    };\n    var clampDuration = function(n) {\n        return Math.min(Math.max(n, MINIMUM_DURATION), MAXIMUM_DURATION);\n    };\n    var fire = function(that, f, event) {\n        try {\n            if (typeof f === \"function\") {\n                f.call(that, event);\n            }\n        } catch (e) {\n            throwError(e);\n        }\n    };\n    function EventSourcePolyfill(url, options) {\n        EventTarget.call(this);\n        options = options || {};\n        this.onopen = undefined;\n        this.onmessage = undefined;\n        this.onerror = undefined;\n        this.url = undefined;\n        this.readyState = undefined;\n        this.withCredentials = undefined;\n        this.headers = undefined;\n        this._close = undefined;\n        start(this, url, options);\n    }\n    function getBestXHRTransport() {\n        return XMLHttpRequest != undefined && \"withCredentials\" in XMLHttpRequest.prototype || XDomainRequest == undefined ? new XMLHttpRequest() : new XDomainRequest();\n    }\n    var isFetchSupported = fetch != undefined && Response != undefined && \"body\" in Response.prototype;\n    function start(es, url, options) {\n        url = String(url);\n        var withCredentials = Boolean(options.withCredentials);\n        var lastEventIdQueryParameterName = options.lastEventIdQueryParameterName || \"lastEventId\";\n        var initialRetry = clampDuration(1000);\n        var heartbeatTimeout = parseDuration(options.heartbeatTimeout, 45000);\n        var lastEventId = \"\";\n        var retry = initialRetry;\n        var wasActivity = false;\n        var textLength = 0;\n        var headers = options.headers || {};\n        var TransportOption = options.Transport;\n        var xhr = isFetchSupported && TransportOption == undefined ? undefined : new XHRWrapper(TransportOption != undefined ? new TransportOption() : getBestXHRTransport());\n        var transport = TransportOption != null && typeof TransportOption !== \"string\" ? new TransportOption() : xhr == undefined ? new FetchTransport() : new XHRTransport();\n        var abortController = undefined;\n        var timeout = 0;\n        var currentState = WAITING;\n        var dataBuffer = \"\";\n        var lastEventIdBuffer = \"\";\n        var eventTypeBuffer = \"\";\n        var textBuffer = \"\";\n        var state = FIELD_START;\n        var fieldStart = 0;\n        var valueStart = 0;\n        var onStart = function(status, statusText, contentType, headers) {\n            if (currentState === CONNECTING) {\n                if (status === 200 && contentType != undefined && contentTypeRegExp.test(contentType)) {\n                    currentState = OPEN;\n                    wasActivity = Date.now();\n                    retry = initialRetry;\n                    es.readyState = OPEN;\n                    var event = new ConnectionEvent(\"open\", {\n                        status: status,\n                        statusText: statusText,\n                        headers: headers\n                    });\n                    es.dispatchEvent(event);\n                    fire(es, es.onopen, event);\n                } else {\n                    var message = \"\";\n                    if (status !== 200) {\n                        if (statusText) {\n                            statusText = statusText.replace(/\\s+/g, \" \");\n                        }\n                        message = \"EventSource's response has a status \" + status + \" \" + statusText + \" that is not 200. Aborting the connection.\";\n                    } else {\n                        message = \"EventSource's response has a Content-Type specifying an unsupported type: \" + (contentType == undefined ? \"-\" : contentType.replace(/\\s+/g, \" \")) + \". Aborting the connection.\";\n                    }\n                    close();\n                    var event = new ConnectionEvent(\"error\", {\n                        status: status,\n                        statusText: statusText,\n                        headers: headers\n                    });\n                    es.dispatchEvent(event);\n                    fire(es, es.onerror, event);\n                    console.error(message);\n                }\n            }\n        };\n        var onProgress = function(textChunk) {\n            if (currentState === OPEN) {\n                var n = -1;\n                for(var i = 0; i < textChunk.length; i += 1){\n                    var c = textChunk.charCodeAt(i);\n                    if (c === \"\\n\".charCodeAt(0) || c === \"\\r\".charCodeAt(0)) {\n                        n = i;\n                    }\n                }\n                var chunk = (n !== -1 ? textBuffer : \"\") + textChunk.slice(0, n + 1);\n                textBuffer = (n === -1 ? textBuffer : \"\") + textChunk.slice(n + 1);\n                if (textChunk !== \"\") {\n                    wasActivity = Date.now();\n                    textLength += textChunk.length;\n                }\n                for(var position = 0; position < chunk.length; position += 1){\n                    var c = chunk.charCodeAt(position);\n                    if (state === AFTER_CR && c === \"\\n\".charCodeAt(0)) {\n                        state = FIELD_START;\n                    } else {\n                        if (state === AFTER_CR) {\n                            state = FIELD_START;\n                        }\n                        if (c === \"\\r\".charCodeAt(0) || c === \"\\n\".charCodeAt(0)) {\n                            if (state !== FIELD_START) {\n                                if (state === FIELD) {\n                                    valueStart = position + 1;\n                                }\n                                var field = chunk.slice(fieldStart, valueStart - 1);\n                                var value = chunk.slice(valueStart + (valueStart < position && chunk.charCodeAt(valueStart) === \" \".charCodeAt(0) ? 1 : 0), position);\n                                if (field === \"data\") {\n                                    dataBuffer += \"\\n\";\n                                    dataBuffer += value;\n                                } else if (field === \"id\") {\n                                    lastEventIdBuffer = value;\n                                } else if (field === \"event\") {\n                                    eventTypeBuffer = value;\n                                } else if (field === \"retry\") {\n                                    initialRetry = parseDuration(value, initialRetry);\n                                    retry = initialRetry;\n                                } else if (field === \"heartbeatTimeout\") {\n                                    heartbeatTimeout = parseDuration(value, heartbeatTimeout);\n                                    if (timeout !== 0) {\n                                        clearTimeout(timeout);\n                                        timeout = setTimeout(function() {\n                                            onTimeout();\n                                        }, heartbeatTimeout);\n                                    }\n                                }\n                            }\n                            if (state === FIELD_START) {\n                                if (dataBuffer !== \"\") {\n                                    lastEventId = lastEventIdBuffer;\n                                    if (eventTypeBuffer === \"\") {\n                                        eventTypeBuffer = \"message\";\n                                    }\n                                    var event = new MessageEvent(eventTypeBuffer, {\n                                        data: dataBuffer.slice(1),\n                                        lastEventId: lastEventIdBuffer\n                                    });\n                                    es.dispatchEvent(event);\n                                    if (eventTypeBuffer === \"open\") {\n                                        fire(es, es.onopen, event);\n                                    } else if (eventTypeBuffer === \"message\") {\n                                        fire(es, es.onmessage, event);\n                                    } else if (eventTypeBuffer === \"error\") {\n                                        fire(es, es.onerror, event);\n                                    }\n                                    if (currentState === CLOSED) {\n                                        return;\n                                    }\n                                }\n                                dataBuffer = \"\";\n                                eventTypeBuffer = \"\";\n                            }\n                            state = c === \"\\r\".charCodeAt(0) ? AFTER_CR : FIELD_START;\n                        } else {\n                            if (state === FIELD_START) {\n                                fieldStart = position;\n                                state = FIELD;\n                            }\n                            if (state === FIELD) {\n                                if (c === \":\".charCodeAt(0)) {\n                                    valueStart = position + 1;\n                                    state = VALUE_START;\n                                }\n                            } else if (state === VALUE_START) {\n                                state = VALUE;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        var onFinish = function(error) {\n            if (currentState === OPEN || currentState === CONNECTING) {\n                currentState = WAITING;\n                if (timeout !== 0) {\n                    clearTimeout(timeout);\n                    timeout = 0;\n                }\n                timeout = setTimeout(function() {\n                    onTimeout();\n                }, retry);\n                retry = clampDuration(Math.min(initialRetry * 16, retry * 2));\n                es.readyState = CONNECTING;\n                var event = new ErrorEvent(\"error\", {\n                    error: error\n                });\n                es.dispatchEvent(event);\n                fire(es, es.onerror, event);\n                if (error != undefined) {\n                    console.error(error);\n                }\n            }\n        };\n        var close = function() {\n            currentState = CLOSED;\n            if (abortController != undefined) {\n                abortController.abort();\n                abortController = undefined;\n            }\n            if (timeout !== 0) {\n                clearTimeout(timeout);\n                timeout = 0;\n            }\n            es.readyState = CLOSED;\n        };\n        var onTimeout = function() {\n            timeout = 0;\n            if (currentState !== WAITING) {\n                if (!wasActivity && abortController != undefined) {\n                    onFinish(new Error(\"No activity within \" + heartbeatTimeout + \" milliseconds.\" + \" \" + (currentState === CONNECTING ? \"No response received.\" : textLength + \" chars received.\") + \" \" + \"Reconnecting.\"));\n                    if (abortController != undefined) {\n                        abortController.abort();\n                        abortController = undefined;\n                    }\n                } else {\n                    var nextHeartbeat = Math.max((wasActivity || Date.now()) + heartbeatTimeout - Date.now(), 1);\n                    wasActivity = false;\n                    timeout = setTimeout(function() {\n                        onTimeout();\n                    }, nextHeartbeat);\n                }\n                return;\n            }\n            wasActivity = false;\n            textLength = 0;\n            timeout = setTimeout(function() {\n                onTimeout();\n            }, heartbeatTimeout);\n            currentState = CONNECTING;\n            dataBuffer = \"\";\n            eventTypeBuffer = \"\";\n            lastEventIdBuffer = lastEventId;\n            textBuffer = \"\";\n            fieldStart = 0;\n            valueStart = 0;\n            state = FIELD_START;\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=428916\n            // Request header field Last-Event-ID is not allowed by Access-Control-Allow-Headers.\n            var requestURL = url;\n            if (url.slice(0, 5) !== \"data:\" && url.slice(0, 5) !== \"blob:\") {\n                if (lastEventId !== \"\") {\n                    // Remove the lastEventId parameter if it's already part of the request URL.\n                    var i = url.indexOf(\"?\");\n                    requestURL = i === -1 ? url : url.slice(0, i + 1) + url.slice(i + 1).replace(/(?:^|&)([^=&]*)(?:=[^&]*)?/g, function(p, paramName) {\n                        return paramName === lastEventIdQueryParameterName ? \"\" : p;\n                    });\n                    // Append the current lastEventId to the request URL.\n                    requestURL += (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + lastEventIdQueryParameterName + \"=\" + encodeURIComponent(lastEventId);\n                }\n            }\n            var withCredentials = es.withCredentials;\n            var requestHeaders = {};\n            requestHeaders[\"Accept\"] = \"text/event-stream\";\n            var headers = es.headers;\n            if (headers != undefined) {\n                for(var name in headers){\n                    if (Object.prototype.hasOwnProperty.call(headers, name)) {\n                        requestHeaders[name] = headers[name];\n                    }\n                }\n            }\n            try {\n                abortController = transport.open(xhr, onStart, onProgress, onFinish, requestURL, withCredentials, requestHeaders);\n            } catch (error) {\n                close();\n                throw error;\n            }\n        };\n        es.url = url;\n        es.readyState = CONNECTING;\n        es.withCredentials = withCredentials;\n        es.headers = headers;\n        es._close = close;\n        onTimeout();\n    }\n    EventSourcePolyfill.prototype = Object.create(EventTarget.prototype);\n    EventSourcePolyfill.prototype.CONNECTING = CONNECTING;\n    EventSourcePolyfill.prototype.OPEN = OPEN;\n    EventSourcePolyfill.prototype.CLOSED = CLOSED;\n    EventSourcePolyfill.prototype.close = function() {\n        this._close();\n    };\n    EventSourcePolyfill.CONNECTING = CONNECTING;\n    EventSourcePolyfill.OPEN = OPEN;\n    EventSourcePolyfill.CLOSED = CLOSED;\n    EventSourcePolyfill.prototype.withCredentials = undefined;\n    var R = NativeEventSource;\n    if (XMLHttpRequest != undefined && (NativeEventSource == undefined || !(\"withCredentials\" in NativeEventSource.prototype))) {\n        // Why replace a native EventSource ?\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=444328\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=831392\n        // https://code.google.com/p/chromium/issues/detail?id=260144\n        // https://code.google.com/p/chromium/issues/detail?id=225654\n        // ...\n        R = EventSourcePolyfill;\n    }\n    (function(factory) {\n        if ( true && typeof module.exports === \"object\") {\n            var v = factory(exports);\n            if (v !== undefined) module.exports = v;\n        } else if (true) {\n            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n                exports\n            ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        } else {}\n    })(function(exports1) {\n        exports1.EventSourcePolyfill = EventSourcePolyfill;\n        exports1.NativeEventSource = NativeEventSource;\n        exports1.EventSource = R;\n    });\n})(typeof globalThis === \"undefined\" ?  true ? window : 0 : globalThis);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudC1zb3VyY2UtcG9seWZpbGwvc3JjL2V2ZW50c291cmNlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7OztDQUlDLEdBRUQsK0NBQStDLEdBQy9DLGtDQUFrQyxHQUVqQyxVQUFVQSxNQUFNO0lBQ2Y7SUFFQSxJQUFJQyxhQUFhRCxPQUFPQyxVQUFVO0lBQ2xDLElBQUlDLGVBQWVGLE9BQU9FLFlBQVk7SUFDdEMsSUFBSUMsaUJBQWlCSCxPQUFPRyxjQUFjO0lBQzFDLElBQUlDLGlCQUFpQkosT0FBT0ksY0FBYztJQUMxQyxJQUFJQyxnQkFBZ0JMLE9BQU9LLGFBQWE7SUFDeEMsSUFBSUMsb0JBQW9CTixPQUFPTyxXQUFXO0lBRTFDLElBQUlDLFdBQVdSLE9BQU9RLFFBQVE7SUFDOUIsSUFBSUMsVUFBVVQsT0FBT1MsT0FBTztJQUM1QixJQUFJQyxRQUFRVixPQUFPVSxLQUFLO0lBQ3hCLElBQUlDLFdBQVdYLE9BQU9XLFFBQVE7SUFDOUIsSUFBSUMsY0FBY1osT0FBT1ksV0FBVztJQUNwQyxJQUFJQyxjQUFjYixPQUFPYSxXQUFXO0lBQ3BDLElBQUlDLGtCQUFrQmQsT0FBT2MsZUFBZTtJQUU1QyxJQUFJLEtBQTZCLElBQUksT0FBT04sYUFBYSxlQUFlLENBQUUsaUJBQWdCQSxRQUFPLEtBQU1BLFNBQVNPLElBQUksSUFBSSxNQUFNO1FBQzVIUCxTQUFTUSxVQUFVLEdBQUc7UUFDdEJDLE9BQU9DLGdCQUFnQixDQUFDLFFBQVEsU0FBVUMsS0FBSztZQUM3Q1gsU0FBU1EsVUFBVSxHQUFHO1FBQ3hCLEdBQUc7SUFDTDtJQUVBLElBQUliLGtCQUFrQixRQUFRRSxpQkFBaUIsTUFBTTtRQUNuREYsaUJBQWlCO1lBQ2YsT0FBTyxJQUFJRSxjQUFjO1FBQzNCO0lBQ0Y7SUFFQSxJQUFJZSxPQUFPQyxNQUFNLElBQUlDLFdBQVc7UUFDOUJGLE9BQU9DLE1BQU0sR0FBRyxTQUFVRSxDQUFDO1lBQ3pCLFNB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R0FBY2xOLFNBQVMsQ0FBcUMsR0FBUWtOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldmVudC1zb3VyY2UtcG9seWZpbGwvc3JjL2V2ZW50c291cmNlLmpzP2Q2ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlXHJcbiAqIGV2ZW50c291cmNlLmpzXHJcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vWWFmZmxlL0V2ZW50U291cmNlL1xyXG4gKi9cclxuXHJcbi8qanNsaW50IGluZGVudDogMiwgdmFyczogdHJ1ZSwgcGx1c3BsdXM6IHRydWUgKi9cclxuLypnbG9iYWwgc2V0VGltZW91dCwgY2xlYXJUaW1lb3V0ICovXHJcblxyXG4oZnVuY3Rpb24gKGdsb2JhbCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICB2YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xyXG4gIHZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xyXG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IGdsb2JhbC5YTUxIdHRwUmVxdWVzdDtcclxuICB2YXIgWERvbWFpblJlcXVlc3QgPSBnbG9iYWwuWERvbWFpblJlcXVlc3Q7XHJcbiAgdmFyIEFjdGl2ZVhPYmplY3QgPSBnbG9iYWwuQWN0aXZlWE9iamVjdDtcclxuICB2YXIgTmF0aXZlRXZlbnRTb3VyY2UgPSBnbG9iYWwuRXZlbnRTb3VyY2U7XHJcblxyXG4gIHZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcclxuICB2YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xyXG4gIHZhciBmZXRjaCA9IGdsb2JhbC5mZXRjaDtcclxuICB2YXIgUmVzcG9uc2UgPSBnbG9iYWwuUmVzcG9uc2U7XHJcbiAgdmFyIFRleHREZWNvZGVyID0gZ2xvYmFsLlRleHREZWNvZGVyO1xyXG4gIHZhciBUZXh0RW5jb2RlciA9IGdsb2JhbC5UZXh0RW5jb2RlcjtcclxuICB2YXIgQWJvcnRDb250cm9sbGVyID0gZ2xvYmFsLkFib3J0Q29udHJvbGxlcjtcclxuXHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmICEoXCJyZWFkeVN0YXRlXCIgaW4gZG9jdW1lbnQpICYmIGRvY3VtZW50LmJvZHkgPT0gbnVsbCkgeyAvLyBGaXJlZm94IDJcclxuICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPSBcImxvYWRpbmdcIjtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9IFwiY29tcGxldGVcIjtcclxuICAgIH0sIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGlmIChYTUxIdHRwUmVxdWVzdCA9PSBudWxsICYmIEFjdGl2ZVhPYmplY3QgIT0gbnVsbCkgeyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvVXNpbmdfWE1MSHR0cFJlcXVlc3RfaW5fSUU2XHJcbiAgICBYTUxIdHRwUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgaWYgKE9iamVjdC5jcmVhdGUgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKEMpIHtcclxuICAgICAgZnVuY3Rpb24gRigpe31cclxuICAgICAgRi5wcm90b3R5cGUgPSBDO1xyXG4gICAgICByZXR1cm4gbmV3IEYoKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpZiAoIURhdGUubm93KSB7XHJcbiAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIHNlZSAjMTE4IChQcm9taXNlI2ZpbmFsbHkgd2l0aCBwb2x5ZmlsbGVkIFByb21pc2UpXHJcbiAgLy8gc2VlICMxMjMgKGRhdGEgVVJMcyBjcmFzaCBFZGdlKVxyXG4gIC8vIHNlZSAjMTI1IChDU1AgdmlvbGF0aW9ucylcclxuICAvLyBzZWUgcHVsbC8jMTM4XHJcbiAgLy8gPT4gTm8gd2F5IHRvIHBvbHlmaWxsIFByb21pc2UjZmluYWxseVxyXG5cclxuICBpZiAoQWJvcnRDb250cm9sbGVyID09IHVuZGVmaW5lZCkge1xyXG4gICAgdmFyIG9yaWdpbmFsRmV0Y2gyID0gZmV0Y2g7XHJcbiAgICBmZXRjaCA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuICAgICAgdmFyIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xyXG4gICAgICByZXR1cm4gb3JpZ2luYWxGZXRjaDIodXJsLCB7aGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLCBjcmVkZW50aWFsczogb3B0aW9ucy5jcmVkZW50aWFscywgY2FjaGU6IG9wdGlvbnMuY2FjaGV9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgIHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xyXG4gICAgICAgIHNpZ25hbC5fcmVhZGVyID0gcmVhZGVyO1xyXG4gICAgICAgIGlmIChzaWduYWwuX2Fib3J0ZWQpIHtcclxuICAgICAgICAgIHNpZ25hbC5fcmVhZGVyLmNhbmNlbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxyXG4gICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcclxuICAgICAgICAgIGJvZHk6IHtcclxuICAgICAgICAgICAgZ2V0UmVhZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFib3J0Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5zaWduYWwgPSB7XHJcbiAgICAgICAgX3JlYWRlcjogbnVsbCxcclxuICAgICAgICBfYWJvcnRlZDogZmFsc2VcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zaWduYWwuX3JlYWRlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICB0aGlzLnNpZ25hbC5fcmVhZGVyLmNhbmNlbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNpZ25hbC5fYWJvcnRlZCA9IHRydWU7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gVGV4dERlY29kZXJQb2x5ZmlsbCgpIHtcclxuICAgIHRoaXMuYml0c05lZWRlZCA9IDA7XHJcbiAgICB0aGlzLmNvZGVQb2ludCA9IDA7XHJcbiAgfVxyXG5cclxuICBUZXh0RGVjb2RlclBvbHlmaWxsLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAob2N0ZXRzKSB7XHJcbiAgICBmdW5jdGlvbiB2YWxpZChjb2RlUG9pbnQsIHNoaWZ0LCBvY3RldHNDb3VudCkge1xyXG4gICAgICBpZiAob2N0ZXRzQ291bnQgPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gY29kZVBvaW50ID49IDB4MDA4MCA+PiBzaGlmdCAmJiBjb2RlUG9pbnQgPDwgc2hpZnQgPD0gMHgwN0ZGO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvY3RldHNDb3VudCA9PT0gMikge1xyXG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgPj0gMHgwODAwID4+IHNoaWZ0ICYmIGNvZGVQb2ludCA8PCBzaGlmdCA8PSAweEQ3RkYgfHwgY29kZVBvaW50ID49IDB4RTAwMCA+PiBzaGlmdCAmJiBjb2RlUG9pbnQgPDwgc2hpZnQgPD0gMHhGRkZGO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvY3RldHNDb3VudCA9PT0gMykge1xyXG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgPj0gMHgwMTAwMDAgPj4gc2hpZnQgJiYgY29kZVBvaW50IDw8IHNoaWZ0IDw9IDB4MTBGRkZGO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb2N0ZXRzQ291bnQoYml0c05lZWRlZCwgY29kZVBvaW50KSB7XHJcbiAgICAgIGlmIChiaXRzTmVlZGVkID09PSA2ICogMSkge1xyXG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgPj4gNiA+IDE1ID8gMyA6IGNvZGVQb2ludCA+IDMxID8gMiA6IDE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGJpdHNOZWVkZWQgPT09IDYgKiAyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCA+IDE1ID8gMyA6IDI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGJpdHNOZWVkZWQgPT09IDYgKiAzKSB7XHJcbiAgICAgICAgcmV0dXJuIDM7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgUkVQTEFDRVIgPSAweEZGRkQ7XHJcbiAgICB2YXIgc3RyaW5nID0gXCJcIjtcclxuICAgIHZhciBiaXRzTmVlZGVkID0gdGhpcy5iaXRzTmVlZGVkO1xyXG4gICAgdmFyIGNvZGVQb2ludCA9IHRoaXMuY29kZVBvaW50O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvY3RldHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgdmFyIG9jdGV0ID0gb2N0ZXRzW2ldO1xyXG4gICAgICBpZiAoYml0c05lZWRlZCAhPT0gMCkge1xyXG4gICAgICAgIGlmIChvY3RldCA8IDEyOCB8fCBvY3RldCA+IDE5MSB8fCAhdmFsaWQoY29kZVBvaW50IDw8IDYgfCBvY3RldCAmIDYzLCBiaXRzTmVlZGVkIC0gNiwgb2N0ZXRzQ291bnQoYml0c05lZWRlZCwgY29kZVBvaW50KSkpIHtcclxuICAgICAgICAgIGJpdHNOZWVkZWQgPSAwO1xyXG4gICAgICAgICAgY29kZVBvaW50ID0gUkVQTEFDRVI7XHJcbiAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoYml0c05lZWRlZCA9PT0gMCkge1xyXG4gICAgICAgIGlmIChvY3RldCA+PSAwICYmIG9jdGV0IDw9IDEyNykge1xyXG4gICAgICAgICAgYml0c05lZWRlZCA9IDA7XHJcbiAgICAgICAgICBjb2RlUG9pbnQgPSBvY3RldDtcclxuICAgICAgICB9IGVsc2UgaWYgKG9jdGV0ID49IDE5MiAmJiBvY3RldCA8PSAyMjMpIHtcclxuICAgICAgICAgIGJpdHNOZWVkZWQgPSA2ICogMTtcclxuICAgICAgICAgIGNvZGVQb2ludCA9IG9jdGV0ICYgMzE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvY3RldCA+PSAyMjQgJiYgb2N0ZXQgPD0gMjM5KSB7XHJcbiAgICAgICAgICBiaXRzTmVlZGVkID0gNiAqIDI7XHJcbiAgICAgICAgICBjb2RlUG9pbnQgPSBvY3RldCAmIDE1O1xyXG4gICAgICAgIH0gZWxzZSBpZiAob2N0ZXQgPj0gMjQwICYmIG9jdGV0IDw9IDI0Nykge1xyXG4gICAgICAgICAgYml0c05lZWRlZCA9IDYgKiAzO1xyXG4gICAgICAgICAgY29kZVBvaW50ID0gb2N0ZXQgJiA3O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBiaXRzTmVlZGVkID0gMDtcclxuICAgICAgICAgIGNvZGVQb2ludCA9IFJFUExBQ0VSO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYml0c05lZWRlZCAhPT0gMCAmJiAhdmFsaWQoY29kZVBvaW50LCBiaXRzTmVlZGVkLCBvY3RldHNDb3VudChiaXRzTmVlZGVkLCBjb2RlUG9pbnQpKSkge1xyXG4gICAgICAgICAgYml0c05lZWRlZCA9IDA7XHJcbiAgICAgICAgICBjb2RlUG9pbnQgPSBSRVBMQUNFUjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYml0c05lZWRlZCAtPSA2O1xyXG4gICAgICAgIGNvZGVQb2ludCA9IGNvZGVQb2ludCA8PCA2IHwgb2N0ZXQgJiA2MztcclxuICAgICAgfVxyXG4gICAgICBpZiAoYml0c05lZWRlZCA9PT0gMCkge1xyXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7XHJcbiAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgKyAoY29kZVBvaW50IC0gMHhGRkZGIC0gMSA+PiAxMCkpO1xyXG4gICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEQzAwICsgKGNvZGVQb2ludCAtIDB4RkZGRiAtIDEgJiAweDNGRikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5iaXRzTmVlZGVkID0gYml0c05lZWRlZDtcclxuICAgIHRoaXMuY29kZVBvaW50ID0gY29kZVBvaW50O1xyXG4gICAgcmV0dXJuIHN0cmluZztcclxuICB9O1xyXG5cclxuICAvLyBGaXJlZm94IDwgMzggdGhyb3dzIGFuIGVycm9yIHdpdGggc3RyZWFtIG9wdGlvblxyXG4gIHZhciBzdXBwb3J0c1N0cmVhbU9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFwidGVzdFwiKSwge3N0cmVhbTogdHJ1ZX0pID09PSBcInRlc3RcIjtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZGVidWcoXCJUZXh0RGVjb2RlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmVhbWluZyBvcHRpb24uIFVzaW5nIHBvbHlmaWxsIGluc3RlYWQ6IFwiICsgZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIC8vIElFLCBFZGdlXHJcbiAgaWYgKFRleHREZWNvZGVyID09IHVuZGVmaW5lZCB8fCBUZXh0RW5jb2RlciA9PSB1bmRlZmluZWQgfHwgIXN1cHBvcnRzU3RyZWFtT3B0aW9uKCkpIHtcclxuICAgIFRleHREZWNvZGVyID0gVGV4dERlY29kZXJQb2x5ZmlsbDtcclxuICB9XHJcblxyXG4gIHZhciBrID0gZnVuY3Rpb24gKCkge1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIFhIUldyYXBwZXIoeGhyKSB7XHJcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xyXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gMDtcclxuICAgIHRoaXMuc3RhdHVzID0gMDtcclxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IFwiXCI7XHJcbiAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XHJcbiAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBrO1xyXG4gICAgdGhpcy5vbmxvYWQgPSBrO1xyXG4gICAgdGhpcy5vbmVycm9yID0gaztcclxuICAgIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gaztcclxuICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gXCJcIjtcclxuICAgIHRoaXMuX3hociA9IHhocjtcclxuICAgIHRoaXMuX3NlbmRUaW1lb3V0ID0gMDtcclxuICAgIHRoaXMuX2Fib3J0ID0gaztcclxuICB9XHJcblxyXG4gIFhIUldyYXBwZXIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwpIHtcclxuICAgIHRoaXMuX2Fib3J0KHRydWUpO1xyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHZhciB4aHIgPSB0aGlzLl94aHI7XHJcbiAgICB2YXIgc3RhdGUgPSAxO1xyXG4gICAgdmFyIHRpbWVvdXQgPSAwO1xyXG5cclxuICAgIHRoaXMuX2Fib3J0ID0gZnVuY3Rpb24gKHNpbGVudCkge1xyXG4gICAgICBpZiAodGhhdC5fc2VuZFRpbWVvdXQgIT09IDApIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhhdC5fc2VuZFRpbWVvdXQpO1xyXG4gICAgICAgIHRoYXQuX3NlbmRUaW1lb3V0ID0gMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RhdGUgPT09IDEgfHwgc3RhdGUgPT09IDIgfHwgc3RhdGUgPT09IDMpIHtcclxuICAgICAgICBzdGF0ZSA9IDQ7XHJcbiAgICAgICAgeGhyLm9ubG9hZCA9IGs7XHJcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBrO1xyXG4gICAgICAgIHhoci5vbmFib3J0ID0gaztcclxuICAgICAgICB4aHIub25wcm9ncmVzcyA9IGs7XHJcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGs7XHJcbiAgICAgICAgLy8gSUUgOCAtIDk6IFhEb21haW5SZXF1ZXN0I2Fib3J0KCkgZG9lcyBub3QgZmlyZSBhbnkgZXZlbnRcclxuICAgICAgICAvLyBPcGVyYSA8IDEwOiBYTUxIdHRwUmVxdWVzdCNhYm9ydCgpIGRvZXMgbm90IGZpcmUgYW55IGV2ZW50XHJcbiAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgaWYgKHRpbWVvdXQgIT09IDApIHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICAgIHRpbWVvdXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNpbGVudCkge1xyXG4gICAgICAgICAgdGhhdC5yZWFkeVN0YXRlID0gNDtcclxuICAgICAgICAgIHRoYXQub25hYm9ydChudWxsKTtcclxuICAgICAgICAgIHRoYXQub25yZWFkeXN0YXRlY2hhbmdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHN0YXRlID0gMDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIG9uU3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gMSkge1xyXG4gICAgICAgIC8vc3RhdGUgPSAyO1xyXG4gICAgICAgIHZhciBzdGF0dXMgPSAwO1xyXG4gICAgICAgIHZhciBzdGF0dXNUZXh0ID0gXCJcIjtcclxuICAgICAgICB2YXIgY29udGVudFR5cGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKCEoXCJjb250ZW50VHlwZVwiIGluIHhocikpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHN0YXR1cyA9IHhoci5zdGF0dXM7XHJcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSB4aHIuc3RhdHVzVGV4dDtcclxuICAgICAgICAgICAgY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBJRSA8IDEwIHRocm93cyBleGNlcHRpb24gZm9yIGB4aHIuc3RhdHVzYCB3aGVuIHhoci5yZWFkeVN0YXRlID09PSAyIHx8IHhoci5yZWFkeVN0YXRlID09PSAzXHJcbiAgICAgICAgICAgIC8vIE9wZXJhIDwgMTEgdGhyb3dzIGV4Y2VwdGlvbiBmb3IgYHhoci5zdGF0dXNgIHdoZW4geGhyLnJlYWR5U3RhdGUgPT09IDJcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MTIxXHJcbiAgICAgICAgICAgIHN0YXR1cyA9IDA7XHJcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcIlwiO1xyXG4gICAgICAgICAgICBjb250ZW50VHlwZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgLy8gRmlyZWZveCA8IDE0LCBDaHJvbWUgPywgU2FmYXJpID9cclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5NjU4XHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD03Nzg1NFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdGF0dXMgPSAyMDA7XHJcbiAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJPS1wiO1xyXG4gICAgICAgICAgY29udGVudFR5cGUgPSB4aHIuY29udGVudFR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0dXMgIT09IDApIHtcclxuICAgICAgICAgIHN0YXRlID0gMjtcclxuICAgICAgICAgIHRoYXQucmVhZHlTdGF0ZSA9IDI7XHJcbiAgICAgICAgICB0aGF0LnN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICAgIHRoYXQuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XHJcbiAgICAgICAgICB0aGF0Ll9jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xyXG4gICAgICAgICAgdGhhdC5vbnJlYWR5c3RhdGVjaGFuZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgb25Qcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgb25TdGFydCgpO1xyXG4gICAgICBpZiAoc3RhdGUgPT09IDIgfHwgc3RhdGUgPT09IDMpIHtcclxuICAgICAgICBzdGF0ZSA9IDM7XHJcbiAgICAgICAgdmFyIHJlc3BvbnNlVGV4dCA9IFwiXCI7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJlc3BvbnNlVGV4dCA9IHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIC8vIElFIDggLSA5IHdpdGggWE1MSHR0cFJlcXVlc3RcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhhdC5yZWFkeVN0YXRlID0gMztcclxuICAgICAgICB0aGF0LnJlc3BvbnNlVGV4dCA9IHJlc3BvbnNlVGV4dDtcclxuICAgICAgICB0aGF0Lm9ucHJvZ3Jlc3MoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBvbkZpbmlzaCA9IGZ1bmN0aW9uICh0eXBlLCBldmVudCkge1xyXG4gICAgICBpZiAoZXZlbnQgPT0gbnVsbCB8fCBldmVudC5wcmV2ZW50RGVmYXVsdCA9PSBudWxsKSB7XHJcbiAgICAgICAgZXZlbnQgPSB7XHJcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdDoga1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgLy8gRmlyZWZveCA1MiBmaXJlcyBcInJlYWR5c3RhdGVjaGFuZ2VcIiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHdpdGhvdXQgZmluYWwgXCJyZWFkeXN0YXRlY2hhbmdlXCIgKHhoci5yZWFkeVN0YXRlID09PSAzKVxyXG4gICAgICAvLyBJRSA4IGZpcmVzIFwib25sb2FkXCIgd2l0aG91dCBcIm9ucHJvZ3Jlc3NcIlxyXG4gICAgICBvblByb2dyZXNzKCk7XHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gMSB8fCBzdGF0ZSA9PT0gMiB8fCBzdGF0ZSA9PT0gMykge1xyXG4gICAgICAgIHN0YXRlID0gNDtcclxuICAgICAgICBpZiAodGltZW91dCAhPT0gMCkge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgICAgdGltZW91dCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoYXQucmVhZHlTdGF0ZSA9IDQ7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFwibG9hZFwiKSB7XHJcbiAgICAgICAgICB0aGF0Lm9ubG9hZChldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImVycm9yXCIpIHtcclxuICAgICAgICAgIHRoYXQub25lcnJvcihldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImFib3J0XCIpIHtcclxuICAgICAgICAgIHRoYXQub25hYm9ydChldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhhdC5vbnJlYWR5c3RhdGVjaGFuZ2UoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBvblJlYWR5U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgaWYgKHhociAhPSB1bmRlZmluZWQpIHsgLy8gT3BlcmEgMTJcclxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICAgIGlmICghKFwib25sb2FkXCIgaW4geGhyKSB8fCAhKFwib25lcnJvclwiIGluIHhocikgfHwgIShcIm9uYWJvcnRcIiBpbiB4aHIpKSB7XHJcbiAgICAgICAgICAgIG9uRmluaXNoKHhoci5yZXNwb25zZVRleHQgPT09IFwiXCIgPyBcImVycm9yXCIgOiBcImxvYWRcIiwgZXZlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDMpIHtcclxuICAgICAgICAgIGlmICghKFwib25wcm9ncmVzc1wiIGluIHhocikpIHsgLy8gdGVzdGluZyBYTUxIdHRwUmVxdWVzdCNyZXNwb25zZVRleHQgdG9vIG1hbnkgdGltZXMgaXMgdG9vIHNsb3cgaW4gSUUgMTFcclxuICAgICAgICAgICAgLy8gYW5kIGluIEZpcmVmb3ggMy42XHJcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHhoci5yZWFkeVN0YXRlID09PSAyKSB7XHJcbiAgICAgICAgICBvblN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIG9uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG9uVGltZW91dCgpO1xyXG4gICAgICB9LCA1MDApO1xyXG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDMpIHtcclxuICAgICAgICBvblByb2dyZXNzKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gWERvbWFpblJlcXVlc3QjYWJvcnQgcmVtb3ZlcyBvbnByb2dyZXNzLCBvbmVycm9yLCBvbmxvYWRcclxuICAgIGlmIChcIm9ubG9hZFwiIGluIHhocikge1xyXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgb25GaW5pc2goXCJsb2FkXCIsIGV2ZW50KTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChcIm9uZXJyb3JcIiBpbiB4aHIpIHtcclxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBvbkZpbmlzaChcImVycm9yXCIsIGV2ZW50KTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIGltcHJvcGVyIGZpeCB0byBtYXRjaCBGaXJlZm94IGJlaGF2aW91ciwgYnV0IGl0IGlzIGJldHRlciB0aGFuIGp1c3QgaWdub3JlIGFib3J0XHJcbiAgICAvLyBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzY4NTk2XHJcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODAyMDBcclxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNTM1NzBcclxuICAgIC8vIElFIDggZmlyZXMgXCJvbmxvYWRcIiB3aXRob3V0IFwib25wcm9ncmVzc1xyXG4gICAgaWYgKFwib25hYm9ydFwiIGluIHhocikge1xyXG4gICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIG9uRmluaXNoKFwiYWJvcnRcIiwgZXZlbnQpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcIm9ucHJvZ3Jlc3NcIiBpbiB4aHIpIHtcclxuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElFIDggLSA5IChYTUxIVFRQUmVxdWVzdClcclxuICAgIC8vIE9wZXJhIDwgMTJcclxuICAgIC8vIEZpcmVmb3ggPCAzLjVcclxuICAgIC8vIEZpcmVmb3ggMy41IC0gMy42IC0gPyA8IDkuMFxyXG4gICAgLy8gb25wcm9ncmVzcyBpcyBub3QgZmlyZWQgc29tZXRpbWVzIG9yIGRlbGF5ZWRcclxuICAgIC8vIHNlZSBhbHNvICM2NCAoc2lnbmlmaWNhbnQgbGFnIGluIElFIDExKVxyXG4gICAgaWYgKFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4geGhyKSB7XHJcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBvblJlYWR5U3RhdGVDaGFuZ2UoZXZlbnQpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcImNvbnRlbnRUeXBlXCIgaW4geGhyIHx8ICEoXCJvbnRpbWVvdXRcIiBpbiBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUpKSB7XHJcbiAgICAgIHVybCArPSAodXJsLmluZGV4T2YoXCI/XCIpID09PSAtMSA/IFwiP1wiIDogXCImXCIpICsgXCJwYWRkaW5nPXRydWVcIjtcclxuICAgIH1cclxuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcclxuXHJcbiAgICBpZiAoXCJyZWFkeVN0YXRlXCIgaW4geGhyKSB7XHJcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIE9wZXJhIDEyIGlzc3VlIHdpdGggXCJwcm9ncmVzc1wiIGV2ZW50c1xyXG4gICAgICAvLyAjOTEgKFhNTEh0dHBSZXF1ZXN0IG9ucHJvZ3Jlc3Mgbm90IGZpcmVkIGZvciBzdHJlYW1pbmcgcmVzcG9uc2UgaW4gRWRnZSAxNC0xNS0/KVxyXG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb25UaW1lb3V0KCk7XHJcbiAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgWEhSV3JhcHBlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLl9hYm9ydChmYWxzZSk7XHJcbiAgfTtcclxuICBYSFJXcmFwcGVyLnByb3RvdHlwZS5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29udGVudFR5cGU7XHJcbiAgfTtcclxuICBYSFJXcmFwcGVyLnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XHJcbiAgICB2YXIgeGhyID0gdGhpcy5feGhyO1xyXG4gICAgaWYgKFwic2V0UmVxdWVzdEhlYWRlclwiIGluIHhocikge1xyXG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBYSFJXcmFwcGVyLnByb3RvdHlwZS5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBYTUxIdHRwUmVxdWVzdCNnZXRBbGxSZXNwb25zZUhlYWRlcnMgcmV0dXJucyBudWxsIGZvciBDT1JTIHJlcXVlc3RzIGluIEZpcmVmb3ggMy42LjI4XHJcbiAgICByZXR1cm4gdGhpcy5feGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyAhPSB1bmRlZmluZWQgPyB0aGlzLl94aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgXCJcIiA6IFwiXCI7XHJcbiAgfTtcclxuICBYSFJXcmFwcGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gbG9hZGluZyBpbmRpY2F0b3IgaW4gU2FmYXJpIDwgPyAoNiksIENocm9tZSA8IDE0LCBGaXJlZm94XHJcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03MzY3MjNcclxuICAgIGlmICgoIShcIm9udGltZW91dFwiIGluIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZSkgfHwgKCEoXCJzZW5kQXNCaW5hcnlcIiBpbiBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUpICYmICEoXCJtb3pBbm9uXCIgaW4gWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlKSkpICYmXHJcbiAgICAgICAgZG9jdW1lbnQgIT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgZG9jdW1lbnQucmVhZHlTdGF0ZSAhPSB1bmRlZmluZWQgJiZcclxuICAgICAgICBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImNvbXBsZXRlXCIpIHtcclxuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICB0aGF0Ll9zZW5kVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoYXQuX3NlbmRUaW1lb3V0ID0gMDtcclxuICAgICAgICB0aGF0LnNlbmQoKTtcclxuICAgICAgfSwgNCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeGhyID0gdGhpcy5feGhyO1xyXG4gICAgLy8gd2l0aENyZWRlbnRpYWxzIHNob3VsZCBiZSBzZXQgYWZ0ZXIgXCJvcGVuXCIgZm9yIFNhZmFyaSBhbmQgQ2hyb21lICg8IDE5ID8pXHJcbiAgICBpZiAoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHIpIHtcclxuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8geGhyLnNlbmQoKTsgdGhyb3dzIFwiTm90IGVub3VnaCBhcmd1bWVudHNcIiBpbiBGaXJlZm94IDMuMFxyXG4gICAgICB4aHIuc2VuZCh1bmRlZmluZWQpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IxKSB7XHJcbiAgICAgIC8vIFNhZmFyaSA1LjEuNywgT3BlcmEgMTJcclxuICAgICAgdGhyb3cgZXJyb3IxO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHRvTG93ZXJDYXNlKG5hbWUpIHtcclxuICAgIHJldHVybiBuYW1lLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMuY2hhckNvZGVBdCgwKSArIDB4MjApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBIZWFkZXJzUG9seWZpbGwoYWxsKSB7XHJcbiAgICAvLyBHZXQgaGVhZGVyczogaW1wbGVtZW50ZWQgYWNjb3JkaW5nIHRvIG1vemlsbGEncyBleGFtcGxlIGNvZGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9nZXRBbGxSZXNwb25zZUhlYWRlcnMjRXhhbXBsZVxyXG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB2YXIgYXJyYXkgPSBhbGwuc3BsaXQoXCJcXHJcXG5cIik7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgIHZhciBsaW5lID0gYXJyYXlbaV07XHJcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoXCI6IFwiKTtcclxuICAgICAgdmFyIG5hbWUgPSBwYXJ0cy5zaGlmdCgpO1xyXG4gICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKFwiOiBcIik7XHJcbiAgICAgIG1hcFt0b0xvd2VyQ2FzZShuYW1lKV0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHRoaXMuX21hcCA9IG1hcDtcclxuICB9XHJcbiAgSGVhZGVyc1BvbHlmaWxsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21hcFt0b0xvd2VyQ2FzZShuYW1lKV07XHJcbiAgfTtcclxuXHJcbiAgaWYgKFhNTEh0dHBSZXF1ZXN0ICE9IG51bGwgJiYgWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCA9PSBudWxsKSB7IC8vIElFIDwgOSwgRmlyZWZveCAzLjZcclxuICAgIFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQgPSAyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gWEhSVHJhbnNwb3J0KCkge1xyXG4gIH1cclxuXHJcbiAgWEhSVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKHhociwgb25TdGFydENhbGxiYWNrLCBvblByb2dyZXNzQ2FsbGJhY2ssIG9uRmluaXNoQ2FsbGJhY2ssIHVybCwgd2l0aENyZWRlbnRpYWxzLCBoZWFkZXJzKSB7XHJcbiAgICB4aHIub3BlbihcIkdFVFwiLCB1cmwpO1xyXG4gICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHJlc3BvbnNlVGV4dCA9IHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICAgIHZhciBjaHVuayA9IHJlc3BvbnNlVGV4dC5zbGljZShvZmZzZXQpO1xyXG4gICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICBvblByb2dyZXNzQ2FsbGJhY2soY2h1bmspO1xyXG4gICAgfTtcclxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIG9uRmluaXNoQ2FsbGJhY2sobmV3IEVycm9yKFwiTmV0d29ya0Vycm9yXCIpKTtcclxuICAgIH07XHJcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBvbkZpbmlzaENhbGxiYWNrKG51bGwpO1xyXG4gICAgfTtcclxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBvbkZpbmlzaENhbGxiYWNrKG51bGwpO1xyXG4gICAgfTtcclxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCkge1xyXG4gICAgICAgIHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzO1xyXG4gICAgICAgIHZhciBzdGF0dXNUZXh0ID0geGhyLnN0YXR1c1RleHQ7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xyXG4gICAgICAgIHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xyXG4gICAgICAgIG9uU3RhcnRDYWxsYmFjayhzdGF0dXMsIHN0YXR1c1RleHQsIGNvbnRlbnRUeXBlLCBuZXcgSGVhZGVyc1BvbHlmaWxsKGhlYWRlcnMpKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHM7XHJcbiAgICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcclxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCBuYW1lKSkge1xyXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB4aHIuc2VuZCgpO1xyXG4gICAgcmV0dXJuIHhocjtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBIZWFkZXJzV3JhcHBlcihoZWFkZXJzKSB7XHJcbiAgICB0aGlzLl9oZWFkZXJzID0gaGVhZGVycztcclxuICB9XHJcbiAgSGVhZGVyc1dyYXBwZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGVhZGVycy5nZXQobmFtZSk7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gRmV0Y2hUcmFuc3BvcnQoKSB7XHJcbiAgfVxyXG5cclxuICBGZXRjaFRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICh4aHIsIG9uU3RhcnRDYWxsYmFjaywgb25Qcm9ncmVzc0NhbGxiYWNrLCBvbkZpbmlzaENhbGxiYWNrLCB1cmwsIHdpdGhDcmVkZW50aWFscywgaGVhZGVycykge1xyXG4gICAgdmFyIHJlYWRlciA9IG51bGw7XHJcbiAgICB2YXIgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgIHZhciBzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbDtcclxuICAgIHZhciB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xyXG4gICAgZmV0Y2godXJsLCB7XHJcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXHJcbiAgICAgIGNyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcclxuICAgICAgc2lnbmFsOiBzaWduYWwsXHJcbiAgICAgIGNhY2hlOiBcIm5vLXN0b3JlXCJcclxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XHJcbiAgICAgIG9uU3RhcnRDYWxsYmFjayhyZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQsIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpLCBuZXcgSGVhZGVyc1dyYXBwZXIocmVzcG9uc2UuaGVhZGVycykpO1xyXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMvaXNzdWVzLzE3OVxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHZhciByZWFkTmV4dENodW5rID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XHJcbiAgICAgICAgICAgICAgLy9Ob3RlOiBieXRlcyBpbiB0ZXh0RGVjb2RlciBhcmUgaWdub3JlZFxyXG4gICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB2YXIgY2h1bmsgPSB0ZXh0RGVjb2Rlci5kZWNvZGUocmVzdWx0LnZhbHVlLCB7c3RyZWFtOiB0cnVlfSk7XHJcbiAgICAgICAgICAgICAgb25Qcm9ncmVzc0NhbGxiYWNrKGNodW5rKTtcclxuICAgICAgICAgICAgICByZWFkTmV4dENodW5rKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlYWROZXh0Q2h1bmsoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgfVxyXG4gICAgfSkudGhlbihmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgb25GaW5pc2hDYWxsYmFjayhlcnJvcik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHJlYWRlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7IC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE1ODM4MTVcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRocm93RXJyb3IoZSkge1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRocm93IGU7XHJcbiAgICB9LCAwKTtcclxuICB9XHJcblxyXG4gIEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICBldmVudC50YXJnZXQgPSB0aGlzO1xyXG4gICAgdmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnQudHlwZV07XHJcbiAgICBpZiAodHlwZUxpc3RlbmVycyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IHR5cGVMaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdHlwZUxpc3RlbmVyc1tpXTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lci5oYW5kbGVFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHRocm93RXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICBFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgdHlwZSA9IFN0cmluZyh0eXBlKTtcclxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICB2YXIgdHlwZUxpc3RlbmVycyA9IGxpc3RlbmVyc1t0eXBlXTtcclxuICAgIGlmICh0eXBlTGlzdGVuZXJzID09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0eXBlTGlzdGVuZXJzID0gW107XHJcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IHR5cGVMaXN0ZW5lcnM7XHJcbiAgICB9XHJcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZUxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICBpZiAodHlwZUxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIpIHtcclxuICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZm91bmQpIHtcclxuICAgICAgdHlwZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICB9O1xyXG4gIEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICB0eXBlID0gU3RyaW5nKHR5cGUpO1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuICAgIHZhciB0eXBlTGlzdGVuZXJzID0gbGlzdGVuZXJzW3R5cGVdO1xyXG4gICAgaWYgKHR5cGVMaXN0ZW5lcnMgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciBmaWx0ZXJlZCA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVMaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICBpZiAodHlwZUxpc3RlbmVyc1tpXSAhPT0gbGlzdGVuZXIpIHtcclxuICAgICAgICAgIGZpbHRlcmVkLnB1c2godHlwZUxpc3RlbmVyc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGZpbHRlcmVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gRXZlbnQodHlwZSkge1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgIHRoaXMudGFyZ2V0ID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gTWVzc2FnZUV2ZW50KHR5cGUsIG9wdGlvbnMpIHtcclxuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XHJcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XHJcbiAgICB0aGlzLmxhc3RFdmVudElkID0gb3B0aW9ucy5sYXN0RXZlbnRJZDtcclxuICB9XHJcblxyXG4gIE1lc3NhZ2VFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XHJcblxyXG4gIGZ1bmN0aW9uIENvbm5lY3Rpb25FdmVudCh0eXBlLCBvcHRpb25zKSB7XHJcbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xyXG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cztcclxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dDtcclxuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcclxuICB9XHJcblxyXG4gIENvbm5lY3Rpb25FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XHJcblxyXG4gIGZ1bmN0aW9uIEVycm9yRXZlbnQodHlwZSwgb3B0aW9ucykge1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcclxuICAgIHRoaXMuZXJyb3IgPSBvcHRpb25zLmVycm9yO1xyXG4gIH1cclxuXHJcbiAgRXJyb3JFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XHJcblxyXG4gIHZhciBXQUlUSU5HID0gLTE7XHJcbiAgdmFyIENPTk5FQ1RJTkcgPSAwO1xyXG4gIHZhciBPUEVOID0gMTtcclxuICB2YXIgQ0xPU0VEID0gMjtcclxuXHJcbiAgdmFyIEFGVEVSX0NSID0gLTE7XHJcbiAgdmFyIEZJRUxEX1NUQVJUID0gMDtcclxuICB2YXIgRklFTEQgPSAxO1xyXG4gIHZhciBWQUxVRV9TVEFSVCA9IDI7XHJcbiAgdmFyIFZBTFVFID0gMztcclxuXHJcbiAgdmFyIGNvbnRlbnRUeXBlUmVnRXhwID0gL150ZXh0XFwvZXZlbnRcXC1zdHJlYW0oOy4qKT8kL2k7XHJcblxyXG4gIHZhciBNSU5JTVVNX0RVUkFUSU9OID0gMTAwMDtcclxuICB2YXIgTUFYSU1VTV9EVVJBVElPTiA9IDE4MDAwMDAwO1xyXG5cclxuICB2YXIgcGFyc2VEdXJhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmKSB7XHJcbiAgICB2YXIgbiA9IHZhbHVlID09IG51bGwgPyBkZWYgOiBwYXJzZUludCh2YWx1ZSwgMTApO1xyXG4gICAgaWYgKG4gIT09IG4pIHtcclxuICAgICAgbiA9IGRlZjtcclxuICAgIH1cclxuICAgIHJldHVybiBjbGFtcER1cmF0aW9uKG4pO1xyXG4gIH07XHJcbiAgdmFyIGNsYW1wRHVyYXRpb24gPSBmdW5jdGlvbiAobikge1xyXG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIE1JTklNVU1fRFVSQVRJT04pLCBNQVhJTVVNX0RVUkFUSU9OKTtcclxuICB9O1xyXG5cclxuICB2YXIgZmlyZSA9IGZ1bmN0aW9uICh0aGF0LCBmLCBldmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBmLmNhbGwodGhhdCwgZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHRocm93RXJyb3IoZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gRXZlbnRTb3VyY2VQb2x5ZmlsbCh1cmwsIG9wdGlvbnMpIHtcclxuICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICB0aGlzLm9ub3BlbiA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMub25tZXNzYWdlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5vbmVycm9yID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMudXJsID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhlYWRlcnMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgdGhpcy5fY2xvc2UgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgc3RhcnQodGhpcywgdXJsLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEJlc3RYSFJUcmFuc3BvcnQoKSB7XHJcbiAgICByZXR1cm4gKFhNTEh0dHBSZXF1ZXN0ICE9IHVuZGVmaW5lZCAmJiAoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUpKSB8fCBYRG9tYWluUmVxdWVzdCA9PSB1bmRlZmluZWRcclxuICAgICAgICA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpXHJcbiAgICAgICAgOiBuZXcgWERvbWFpblJlcXVlc3QoKTtcclxuICB9XHJcblxyXG4gIHZhciBpc0ZldGNoU3VwcG9ydGVkID0gZmV0Y2ggIT0gdW5kZWZpbmVkICYmIFJlc3BvbnNlICE9IHVuZGVmaW5lZCAmJiBcImJvZHlcIiBpbiBSZXNwb25zZS5wcm90b3R5cGU7XHJcblxyXG4gIGZ1bmN0aW9uIHN0YXJ0KGVzLCB1cmwsIG9wdGlvbnMpIHtcclxuICAgIHVybCA9IFN0cmluZyh1cmwpO1xyXG4gICAgdmFyIHdpdGhDcmVkZW50aWFscyA9IEJvb2xlYW4ob3B0aW9ucy53aXRoQ3JlZGVudGlhbHMpO1xyXG4gICAgdmFyIGxhc3RFdmVudElkUXVlcnlQYXJhbWV0ZXJOYW1lID0gb3B0aW9ucy5sYXN0RXZlbnRJZFF1ZXJ5UGFyYW1ldGVyTmFtZSB8fCBcImxhc3RFdmVudElkXCI7XHJcblxyXG4gICAgdmFyIGluaXRpYWxSZXRyeSA9IGNsYW1wRHVyYXRpb24oMTAwMCk7XHJcbiAgICB2YXIgaGVhcnRiZWF0VGltZW91dCA9IHBhcnNlRHVyYXRpb24ob3B0aW9ucy5oZWFydGJlYXRUaW1lb3V0LCA0NTAwMCk7XHJcblxyXG4gICAgdmFyIGxhc3RFdmVudElkID0gXCJcIjtcclxuICAgIHZhciByZXRyeSA9IGluaXRpYWxSZXRyeTtcclxuICAgIHZhciB3YXNBY3Rpdml0eSA9IGZhbHNlO1xyXG4gICAgdmFyIHRleHRMZW5ndGggPSAwO1xyXG4gICAgdmFyIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XHJcbiAgICB2YXIgVHJhbnNwb3J0T3B0aW9uID0gb3B0aW9ucy5UcmFuc3BvcnQ7XHJcbiAgICB2YXIgeGhyID0gaXNGZXRjaFN1cHBvcnRlZCAmJiBUcmFuc3BvcnRPcHRpb24gPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbmV3IFhIUldyYXBwZXIoVHJhbnNwb3J0T3B0aW9uICE9IHVuZGVmaW5lZCA/IG5ldyBUcmFuc3BvcnRPcHRpb24oKSA6IGdldEJlc3RYSFJUcmFuc3BvcnQoKSk7XHJcbiAgICB2YXIgdHJhbnNwb3J0ID0gVHJhbnNwb3J0T3B0aW9uICE9IG51bGwgJiYgdHlwZW9mIFRyYW5zcG9ydE9wdGlvbiAhPT0gXCJzdHJpbmdcIiA/IG5ldyBUcmFuc3BvcnRPcHRpb24oKSA6ICh4aHIgPT0gdW5kZWZpbmVkID8gbmV3IEZldGNoVHJhbnNwb3J0KCkgOiBuZXcgWEhSVHJhbnNwb3J0KCkpO1xyXG4gICAgdmFyIGFib3J0Q29udHJvbGxlciA9IHVuZGVmaW5lZDtcclxuICAgIHZhciB0aW1lb3V0ID0gMDtcclxuICAgIHZhciBjdXJyZW50U3RhdGUgPSBXQUlUSU5HO1xyXG4gICAgdmFyIGRhdGFCdWZmZXIgPSBcIlwiO1xyXG4gICAgdmFyIGxhc3RFdmVudElkQnVmZmVyID0gXCJcIjtcclxuICAgIHZhciBldmVudFR5cGVCdWZmZXIgPSBcIlwiO1xyXG5cclxuICAgIHZhciB0ZXh0QnVmZmVyID0gXCJcIjtcclxuICAgIHZhciBzdGF0ZSA9IEZJRUxEX1NUQVJUO1xyXG4gICAgdmFyIGZpZWxkU3RhcnQgPSAwO1xyXG4gICAgdmFyIHZhbHVlU3RhcnQgPSAwO1xyXG5cclxuICAgIHZhciBvblN0YXJ0ID0gZnVuY3Rpb24gKHN0YXR1cywgc3RhdHVzVGV4dCwgY29udGVudFR5cGUsIGhlYWRlcnMpIHtcclxuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gQ09OTkVDVElORykge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiBjb250ZW50VHlwZSAhPSB1bmRlZmluZWQgJiYgY29udGVudFR5cGVSZWdFeHAudGVzdChjb250ZW50VHlwZSkpIHtcclxuICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IE9QRU47XHJcbiAgICAgICAgICB3YXNBY3Rpdml0eSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICByZXRyeSA9IGluaXRpYWxSZXRyeTtcclxuICAgICAgICAgIGVzLnJlYWR5U3RhdGUgPSBPUEVOO1xyXG4gICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IENvbm5lY3Rpb25FdmVudChcIm9wZW5cIiwge1xyXG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcclxuICAgICAgICAgICAgc3RhdHVzVGV4dDogc3RhdHVzVGV4dCxcclxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBlcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgIGZpcmUoZXMsIGVzLm9ub3BlbiwgZXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiXCI7XHJcbiAgICAgICAgICBpZiAoc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgICAgICAgaWYgKHN0YXR1c1RleHQpIHtcclxuICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gc3RhdHVzVGV4dC5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtZXNzYWdlID0gXCJFdmVudFNvdXJjZSdzIHJlc3BvbnNlIGhhcyBhIHN0YXR1cyBcIiArIHN0YXR1cyArIFwiIFwiICsgc3RhdHVzVGV4dCArIFwiIHRoYXQgaXMgbm90IDIwMC4gQWJvcnRpbmcgdGhlIGNvbm5lY3Rpb24uXCI7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gXCJFdmVudFNvdXJjZSdzIHJlc3BvbnNlIGhhcyBhIENvbnRlbnQtVHlwZSBzcGVjaWZ5aW5nIGFuIHVuc3VwcG9ydGVkIHR5cGU6IFwiICsgKGNvbnRlbnRUeXBlID09IHVuZGVmaW5lZCA/IFwiLVwiIDogY29udGVudFR5cGUucmVwbGFjZSgvXFxzKy9nLCBcIiBcIikpICsgXCIuIEFib3J0aW5nIHRoZSBjb25uZWN0aW9uLlwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2xvc2UoKTtcclxuICAgICAgICAgIHZhciBldmVudCA9IG5ldyBDb25uZWN0aW9uRXZlbnQoXCJlcnJvclwiLCB7XHJcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxyXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBzdGF0dXNUZXh0LFxyXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGVzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgZmlyZShlcywgZXMub25lcnJvciwgZXZlbnQpO1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIG9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAodGV4dENodW5rKSB7XHJcbiAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IE9QRU4pIHtcclxuICAgICAgICB2YXIgbiA9IC0xO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dENodW5rLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICB2YXIgYyA9IHRleHRDaHVuay5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgaWYgKGMgPT09IFwiXFxuXCIuY2hhckNvZGVBdCgwKSB8fCBjID09PSBcIlxcclwiLmNoYXJDb2RlQXQoMCkpIHtcclxuICAgICAgICAgICAgbiA9IGk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaHVuayA9IChuICE9PSAtMSA/IHRleHRCdWZmZXIgOiBcIlwiKSArIHRleHRDaHVuay5zbGljZSgwLCBuICsgMSk7XHJcbiAgICAgICAgdGV4dEJ1ZmZlciA9IChuID09PSAtMSA/IHRleHRCdWZmZXIgOiBcIlwiKSArIHRleHRDaHVuay5zbGljZShuICsgMSk7XHJcbiAgICAgICAgaWYgKHRleHRDaHVuayAhPT0gXCJcIikge1xyXG4gICAgICAgICAgd2FzQWN0aXZpdHkgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgdGV4dExlbmd0aCArPSB0ZXh0Q2h1bmsubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBwb3NpdGlvbiA9IDA7IHBvc2l0aW9uIDwgY2h1bmsubGVuZ3RoOyBwb3NpdGlvbiArPSAxKSB7XHJcbiAgICAgICAgICB2YXIgYyA9IGNodW5rLmNoYXJDb2RlQXQocG9zaXRpb24pO1xyXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBBRlRFUl9DUiAmJiBjID09PSBcIlxcblwiLmNoYXJDb2RlQXQoMCkpIHtcclxuICAgICAgICAgICAgc3RhdGUgPSBGSUVMRF9TVEFSVDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gQUZURVJfQ1IpIHtcclxuICAgICAgICAgICAgICBzdGF0ZSA9IEZJRUxEX1NUQVJUO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjID09PSBcIlxcclwiLmNoYXJDb2RlQXQoMCkgfHwgYyA9PT0gXCJcXG5cIi5jaGFyQ29kZUF0KDApKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBGSUVMRF9TVEFSVCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSBGSUVMRCkge1xyXG4gICAgICAgICAgICAgICAgICB2YWx1ZVN0YXJ0ID0gcG9zaXRpb24gKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gY2h1bmsuc2xpY2UoZmllbGRTdGFydCwgdmFsdWVTdGFydCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2h1bmsuc2xpY2UodmFsdWVTdGFydCArICh2YWx1ZVN0YXJ0IDwgcG9zaXRpb24gJiYgY2h1bmsuY2hhckNvZGVBdCh2YWx1ZVN0YXJ0KSA9PT0gXCIgXCIuY2hhckNvZGVBdCgwKSA/IDEgOiAwKSwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkID09PSBcImRhdGFcIikge1xyXG4gICAgICAgICAgICAgICAgICBkYXRhQnVmZmVyICs9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgICAgIGRhdGFCdWZmZXIgKz0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkID09PSBcImlkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgbGFzdEV2ZW50SWRCdWZmZXIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09IFwiZXZlbnRcIikge1xyXG4gICAgICAgICAgICAgICAgICBldmVudFR5cGVCdWZmZXIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09IFwicmV0cnlcIikge1xyXG4gICAgICAgICAgICAgICAgICBpbml0aWFsUmV0cnkgPSBwYXJzZUR1cmF0aW9uKHZhbHVlLCBpbml0aWFsUmV0cnkpO1xyXG4gICAgICAgICAgICAgICAgICByZXRyeSA9IGluaXRpYWxSZXRyeTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09IFwiaGVhcnRiZWF0VGltZW91dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIGhlYXJ0YmVhdFRpbWVvdXQgPSBwYXJzZUR1cmF0aW9uKHZhbHVlLCBoZWFydGJlYXRUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgb25UaW1lb3V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgaGVhcnRiZWF0VGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSBGSUVMRF9TVEFSVCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFCdWZmZXIgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgbGFzdEV2ZW50SWQgPSBsYXN0RXZlbnRJZEJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZUJ1ZmZlciA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZUJ1ZmZlciA9IFwibWVzc2FnZVwiO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoZXZlbnRUeXBlQnVmZmVyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YUJ1ZmZlci5zbGljZSgxKSxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RXZlbnRJZDogbGFzdEV2ZW50SWRCdWZmZXJcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIGVzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlQnVmZmVyID09PSBcIm9wZW5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcmUoZXMsIGVzLm9ub3BlbiwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZUJ1ZmZlciA9PT0gXCJtZXNzYWdlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJlKGVzLCBlcy5vbm1lc3NhZ2UsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGVCdWZmZXIgPT09IFwiZXJyb3JcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcmUoZXMsIGVzLm9uZXJyb3IsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSBDTE9TRUQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRhdGFCdWZmZXIgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRUeXBlQnVmZmVyID0gXCJcIjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgc3RhdGUgPSBjID09PSBcIlxcclwiLmNoYXJDb2RlQXQoMCkgPyBBRlRFUl9DUiA6IEZJRUxEX1NUQVJUO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gRklFTERfU1RBUlQpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkU3RhcnQgPSBwb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gRklFTEQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gRklFTEQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjID09PSBcIjpcIi5jaGFyQ29kZUF0KDApKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlU3RhcnQgPSBwb3NpdGlvbiArIDE7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXRlID0gVkFMVUVfU1RBUlQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gVkFMVUVfU1RBUlQpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gVkFMVUU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBvbkZpbmlzaCA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICBpZiAoY3VycmVudFN0YXRlID09PSBPUEVOIHx8IGN1cnJlbnRTdGF0ZSA9PT0gQ09OTkVDVElORykge1xyXG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IFdBSVRJTkc7XHJcbiAgICAgICAgaWYgKHRpbWVvdXQgIT09IDApIHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICAgIHRpbWVvdXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBvblRpbWVvdXQoKTtcclxuICAgICAgICB9LCByZXRyeSk7XHJcbiAgICAgICAgcmV0cnkgPSBjbGFtcER1cmF0aW9uKE1hdGgubWluKGluaXRpYWxSZXRyeSAqIDE2LCByZXRyeSAqIDIpKTtcclxuXHJcbiAgICAgICAgZXMucmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkc7XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoXCJlcnJvclwiLCB7ZXJyb3I6IGVycm9yfSk7XHJcbiAgICAgICAgZXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgZmlyZShlcywgZXMub25lcnJvciwgZXZlbnQpO1xyXG4gICAgICAgIGlmIChlcnJvciAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY2xvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IENMT1NFRDtcclxuICAgICAgaWYgKGFib3J0Q29udHJvbGxlciAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcclxuICAgICAgICBhYm9ydENvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRpbWVvdXQgIT09IDApIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgdGltZW91dCA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgZXMucmVhZHlTdGF0ZSA9IENMT1NFRDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIG9uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGltZW91dCA9IDA7XHJcblxyXG4gICAgICBpZiAoY3VycmVudFN0YXRlICE9PSBXQUlUSU5HKSB7XHJcbiAgICAgICAgaWYgKCF3YXNBY3Rpdml0eSAmJiBhYm9ydENvbnRyb2xsZXIgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBvbkZpbmlzaChuZXcgRXJyb3IoXCJObyBhY3Rpdml0eSB3aXRoaW4gXCIgKyBoZWFydGJlYXRUaW1lb3V0ICsgXCIgbWlsbGlzZWNvbmRzLlwiICsgXCIgXCIgKyAoY3VycmVudFN0YXRlID09PSBDT05ORUNUSU5HID8gXCJObyByZXNwb25zZSByZWNlaXZlZC5cIiA6IHRleHRMZW5ndGggKyBcIiBjaGFycyByZWNlaXZlZC5cIikgKyBcIiBcIiArIFwiUmVjb25uZWN0aW5nLlwiKSk7XHJcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcclxuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgbmV4dEhlYXJ0YmVhdCA9IE1hdGgubWF4KCh3YXNBY3Rpdml0eSB8fCBEYXRlLm5vdygpKSArIGhlYXJ0YmVhdFRpbWVvdXQgLSBEYXRlLm5vdygpLCAxKTtcclxuICAgICAgICAgIHdhc0FjdGl2aXR5ID0gZmFsc2U7XHJcbiAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG9uVGltZW91dCgpO1xyXG4gICAgICAgICAgfSwgbmV4dEhlYXJ0YmVhdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgd2FzQWN0aXZpdHkgPSBmYWxzZTtcclxuICAgICAgdGV4dExlbmd0aCA9IDA7XHJcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvblRpbWVvdXQoKTtcclxuICAgICAgfSwgaGVhcnRiZWF0VGltZW91dCk7XHJcblxyXG4gICAgICBjdXJyZW50U3RhdGUgPSBDT05ORUNUSU5HO1xyXG4gICAgICBkYXRhQnVmZmVyID0gXCJcIjtcclxuICAgICAgZXZlbnRUeXBlQnVmZmVyID0gXCJcIjtcclxuICAgICAgbGFzdEV2ZW50SWRCdWZmZXIgPSBsYXN0RXZlbnRJZDtcclxuICAgICAgdGV4dEJ1ZmZlciA9IFwiXCI7XHJcbiAgICAgIGZpZWxkU3RhcnQgPSAwO1xyXG4gICAgICB2YWx1ZVN0YXJ0ID0gMDtcclxuICAgICAgc3RhdGUgPSBGSUVMRF9TVEFSVDtcclxuXHJcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQyODkxNlxyXG4gICAgICAvLyBSZXF1ZXN0IGhlYWRlciBmaWVsZCBMYXN0LUV2ZW50LUlEIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMuXHJcbiAgICAgIHZhciByZXF1ZXN0VVJMID0gdXJsO1xyXG4gICAgICBpZiAodXJsLnNsaWNlKDAsIDUpICE9PSBcImRhdGE6XCIgJiYgdXJsLnNsaWNlKDAsIDUpICE9PSBcImJsb2I6XCIpIHtcclxuICAgICAgICBpZiAobGFzdEV2ZW50SWQgIT09IFwiXCIpIHtcclxuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGFzdEV2ZW50SWQgcGFyYW1ldGVyIGlmIGl0J3MgYWxyZWFkeSBwYXJ0IG9mIHRoZSByZXF1ZXN0IFVSTC5cclxuICAgICAgICAgIHZhciBpID0gdXJsLmluZGV4T2YoXCI/XCIpO1xyXG4gICAgICAgICAgcmVxdWVzdFVSTCA9IGkgPT09IC0xID8gdXJsIDogdXJsLnNsaWNlKDAsIGkgKyAxKSArIHVybC5zbGljZShpICsgMSkucmVwbGFjZSgvKD86XnwmKShbXj0mXSopKD86PVteJl0qKT8vZywgZnVuY3Rpb24gKHAsIHBhcmFtTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1OYW1lID09PSBsYXN0RXZlbnRJZFF1ZXJ5UGFyYW1ldGVyTmFtZSA/ICcnIDogcDtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgLy8gQXBwZW5kIHRoZSBjdXJyZW50IGxhc3RFdmVudElkIHRvIHRoZSByZXF1ZXN0IFVSTC5cclxuICAgICAgICAgIHJlcXVlc3RVUkwgKz0gKHVybC5pbmRleE9mKFwiP1wiKSA9PT0gLTEgPyBcIj9cIiA6IFwiJlwiKSArIGxhc3RFdmVudElkUXVlcnlQYXJhbWV0ZXJOYW1lICtcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChsYXN0RXZlbnRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciB3aXRoQ3JlZGVudGlhbHMgPSBlcy53aXRoQ3JlZGVudGlhbHM7XHJcbiAgICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IHt9O1xyXG4gICAgICByZXF1ZXN0SGVhZGVyc1tcIkFjY2VwdFwiXSA9IFwidGV4dC9ldmVudC1zdHJlYW1cIjtcclxuICAgICAgdmFyIGhlYWRlcnMgPSBlcy5oZWFkZXJzO1xyXG4gICAgICBpZiAoaGVhZGVycyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcclxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgbmFtZSkpIHtcclxuICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNbbmFtZV0gPSBoZWFkZXJzW25hbWVdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGFib3J0Q29udHJvbGxlciA9IHRyYW5zcG9ydC5vcGVuKHhociwgb25TdGFydCwgb25Qcm9ncmVzcywgb25GaW5pc2gsIHJlcXVlc3RVUkwsIHdpdGhDcmVkZW50aWFscywgcmVxdWVzdEhlYWRlcnMpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNsb3NlKCk7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZXMudXJsID0gdXJsO1xyXG4gICAgZXMucmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkc7XHJcbiAgICBlcy53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHM7XHJcbiAgICBlcy5oZWFkZXJzID0gaGVhZGVycztcclxuICAgIGVzLl9jbG9zZSA9IGNsb3NlO1xyXG5cclxuICAgIG9uVGltZW91dCgpO1xyXG4gIH1cclxuXHJcbiAgRXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSk7XHJcbiAgRXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUuQ09OTkVDVElORyA9IENPTk5FQ1RJTkc7XHJcbiAgRXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUuT1BFTiA9IE9QRU47XHJcbiAgRXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUuQ0xPU0VEID0gQ0xPU0VEO1xyXG4gIEV2ZW50U291cmNlUG9seWZpbGwucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5fY2xvc2UoKTtcclxuICB9O1xyXG5cclxuICBFdmVudFNvdXJjZVBvbHlmaWxsLkNPTk5FQ1RJTkcgPSBDT05ORUNUSU5HO1xyXG4gIEV2ZW50U291cmNlUG9seWZpbGwuT1BFTiA9IE9QRU47XHJcbiAgRXZlbnRTb3VyY2VQb2x5ZmlsbC5DTE9TRUQgPSBDTE9TRUQ7XHJcbiAgRXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gdW5kZWZpbmVkO1xyXG5cclxuICB2YXIgUiA9IE5hdGl2ZUV2ZW50U291cmNlXHJcbiAgaWYgKFhNTEh0dHBSZXF1ZXN0ICE9IHVuZGVmaW5lZCAmJiAoTmF0aXZlRXZlbnRTb3VyY2UgPT0gdW5kZWZpbmVkIHx8ICEoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiBOYXRpdmVFdmVudFNvdXJjZS5wcm90b3R5cGUpKSkge1xyXG4gICAgLy8gV2h5IHJlcGxhY2UgYSBuYXRpdmUgRXZlbnRTb3VyY2UgP1xyXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDQ0MzI4XHJcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04MzEzOTJcclxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNjAxNDRcclxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjU2NTRcclxuICAgIC8vIC4uLlxyXG4gICAgUiA9IEV2ZW50U291cmNlUG9seWZpbGw7XHJcbiAgfVxyXG5cclxuICAoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICB2YXIgdiA9IGZhY3RvcnkoZXhwb3J0cyk7XHJcbiAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgIGRlZmluZShbXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBmYWN0b3J5KGdsb2JhbCk7XHJcbiAgICB9XHJcbiAgfSkoZnVuY3Rpb24gKGV4cG9ydHMpIHtcclxuICAgIGV4cG9ydHMuRXZlbnRTb3VyY2VQb2x5ZmlsbCA9IEV2ZW50U291cmNlUG9seWZpbGw7XHJcbiAgICBleHBvcnRzLk5hdGl2ZUV2ZW50U291cmNlID0gTmF0aXZlRXZlbnRTb3VyY2U7XHJcbiAgICBleHBvcnRzLkV2ZW50U291cmNlID0gUjtcclxuICB9KTtcclxufSh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcykgOiBnbG9iYWxUaGlzKSk7XHJcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiWE1MSHR0cFJlcXVlc3QiLCJYRG9tYWluUmVxdWVzdCIsIkFjdGl2ZVhPYmplY3QiLCJOYXRpdmVFdmVudFNvdXJjZSIsIkV2ZW50U291cmNlIiwiZG9jdW1lbnQiLCJQcm9taXNlIiwiZmV0Y2giLCJSZXNwb25zZSIsIlRleHREZWNvZGVyIiwiVGV4dEVuY29kZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJib2R5IiwicmVhZHlTdGF0ZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIk9iamVjdCIsImNyZWF0ZSIsInVuZGVmaW5lZCIsIkMiLCJGIiwicHJvdG90eXBlIiwiRGF0ZSIsIm5vdyIsImdldFRpbWUiLCJvcmlnaW5hbEZldGNoMiIsInVybCIsIm9wdGlvbnMiLCJzaWduYWwiLCJoZWFkZXJzIiwiY3JlZGVudGlhbHMiLCJjYWNoZSIsInRoZW4iLCJyZXNwb25zZSIsInJlYWRlciIsImdldFJlYWRlciIsIl9yZWFkZXIiLCJfYWJvcnRlZCIsImNhbmNlbCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJhYm9ydCIsIlRleHREZWNvZGVyUG9seWZpbGwiLCJiaXRzTmVlZGVkIiwiY29kZVBvaW50IiwiZGVjb2RlIiwib2N0ZXRzIiwidmFsaWQiLCJzaGlmdCIsIm9jdGV0c0NvdW50IiwiRXJyb3IiLCJSRVBMQUNFUiIsInN0cmluZyIsImkiLCJsZW5ndGgiLCJvY3RldCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInN1cHBvcnRzU3RyZWFtT3B0aW9uIiwiZW5jb2RlIiwic3RyZWFtIiwiZXJyb3IiLCJjb25zb2xlIiwiZGVidWciLCJrIiwiWEhSV3JhcHBlciIsInhociIsIndpdGhDcmVkZW50aWFscyIsInJlc3BvbnNlVGV4dCIsIm9ucHJvZ3Jlc3MiLCJvbmxvYWQiLCJvbmVycm9yIiwib25yZWFkeXN0YXRlY2hhbmdlIiwiX2NvbnRlbnRUeXBlIiwiX3hociIsIl9zZW5kVGltZW91dCIsIl9hYm9ydCIsIm9wZW4iLCJtZXRob2QiLCJ0aGF0Iiwic3RhdGUiLCJ0aW1lb3V0Iiwic2lsZW50Iiwib25hYm9ydCIsIm9uU3RhcnQiLCJjb250ZW50VHlwZSIsImdldFJlc3BvbnNlSGVhZGVyIiwib25Qcm9ncmVzcyIsIm9uRmluaXNoIiwidHlwZSIsInByZXZlbnREZWZhdWx0IiwiVHlwZUVycm9yIiwib25SZWFkeVN0YXRlQ2hhbmdlIiwib25UaW1lb3V0IiwiaW5kZXhPZiIsIm5hbWUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwidmFsdWUiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzZW5kIiwiZXJyb3IxIiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwiYyIsImNoYXJDb2RlQXQiLCJIZWFkZXJzUG9seWZpbGwiLCJhbGwiLCJtYXAiLCJhcnJheSIsInNwbGl0IiwibGluZSIsInBhcnRzIiwiam9pbiIsIl9tYXAiLCJnZXQiLCJIRUFERVJTX1JFQ0VJVkVEIiwiWEhSVHJhbnNwb3J0Iiwib25TdGFydENhbGxiYWNrIiwib25Qcm9ncmVzc0NhbGxiYWNrIiwib25GaW5pc2hDYWxsYmFjayIsIm9mZnNldCIsImNodW5rIiwic2xpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJIZWFkZXJzV3JhcHBlciIsIl9oZWFkZXJzIiwiRmV0Y2hUcmFuc3BvcnQiLCJjb250cm9sbGVyIiwidGV4dERlY29kZXIiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhZE5leHRDaHVuayIsInJlYWQiLCJyZXN1bHQiLCJkb25lIiwiRXZlbnRUYXJnZXQiLCJfbGlzdGVuZXJzIiwidGhyb3dFcnJvciIsImUiLCJkaXNwYXRjaEV2ZW50IiwidGFyZ2V0IiwidHlwZUxpc3RlbmVycyIsImxpc3RlbmVyIiwiaGFuZGxlRXZlbnQiLCJsaXN0ZW5lcnMiLCJmb3VuZCIsInB1c2giLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZmlsdGVyZWQiLCJFdmVudCIsIk1lc3NhZ2VFdmVudCIsImRhdGEiLCJsYXN0RXZlbnRJZCIsIkNvbm5lY3Rpb25FdmVudCIsIkVycm9yRXZlbnQiLCJXQUlUSU5HIiwiQ09OTkVDVElORyIsIk9QRU4iLCJDTE9TRUQiLCJBRlRFUl9DUiIsIkZJRUxEX1NUQVJUIiwiRklFTEQiLCJWQUxVRV9TVEFSVCIsIlZBTFVFIiwiY29udGVudFR5cGVSZWdFeHAiLCJNSU5JTVVNX0RVUkFUSU9OIiwiTUFYSU1VTV9EVVJBVElPTiIsInBhcnNlRHVyYXRpb24iLCJkZWYiLCJuIiwicGFyc2VJbnQiLCJjbGFtcER1cmF0aW9uIiwiTWF0aCIsIm1pbiIsIm1heCIsImZpcmUiLCJmIiwiRXZlbnRTb3VyY2VQb2x5ZmlsbCIsIm9ub3BlbiIsIm9ubWVzc2FnZSIsIl9jbG9zZSIsInN0YXJ0IiwiZ2V0QmVzdFhIUlRyYW5zcG9ydCIsImlzRmV0Y2hTdXBwb3J0ZWQiLCJlcyIsIkJvb2xlYW4iLCJsYXN0RXZlbnRJZFF1ZXJ5UGFyYW1ldGVyTmFtZSIsImluaXRpYWxSZXRyeSIsImhlYXJ0YmVhdFRpbWVvdXQiLCJyZXRyeSIsIndhc0FjdGl2aXR5IiwidGV4dExlbmd0aCIsIlRyYW5zcG9ydE9wdGlvbiIsIlRyYW5zcG9ydCIsInRyYW5zcG9ydCIsImFib3J0Q29udHJvbGxlciIsImN1cnJlbnRTdGF0ZSIsImRhdGFCdWZmZXIiLCJsYXN0RXZlbnRJZEJ1ZmZlciIsImV2ZW50VHlwZUJ1ZmZlciIsInRleHRCdWZmZXIiLCJmaWVsZFN0YXJ0IiwidmFsdWVTdGFydCIsInRlc3QiLCJtZXNzYWdlIiwiY2xvc2UiLCJ0ZXh0Q2h1bmsiLCJwb3NpdGlvbiIsImZpZWxkIiwibmV4dEhlYXJ0YmVhdCIsInJlcXVlc3RVUkwiLCJwIiwicGFyYW1OYW1lIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVxdWVzdEhlYWRlcnMiLCJSIiwiZmFjdG9yeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ2IiwiZGVmaW5lIiwiYW1kIiwiZ2xvYmFsVGhpcyIsInNlbGYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/event-source-polyfill/src/eventsource.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/eventsource/browser.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sanity/eventsource/browser.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! event-source-polyfill */ \"(app-pages-browser)/./node_modules/event-source-polyfill/src/eventsource.js\").EventSourcePolyfill;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2V2ZW50c291cmNlL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBQSxvS0FBcUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZXZlbnRzb3VyY2UvYnJvd3Nlci5qcz85NmEzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnQtc291cmNlLXBvbHlmaWxsJykuRXZlbnRTb3VyY2VQb2x5ZmlsbFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiRXZlbnRTb3VyY2VQb2x5ZmlsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/eventsource/browser.js\n"));

/***/ })

}]);